#+TITLE: Implement algorithms in Modern Fortran.
#+AUTHOR: Yuma Osada
#+DATE: {{{time(%Y-%m-%d)}}}.
#+LaTeX_header: \usepackage{minted}
#+LaTeX_header: \usepackage{cleveref}
#+macro: src_line line [[($1)]]
#+options: ^:{}
#+options: toc:t H:4 num:4
* emacs-lisp
** org babel settings
Modify org-babel function to avoid adding ~program...end program~ around ~module...end module~.
#+begin_src emacs-lisp :exports code
  (defun org-babel-fortran-ensure-main-wrap (body params)
    "Wrap body in a \"program ... end program\" block if none exists."
    (if (or (string-match "^[ \t]*program\\>" (capitalize body))
            (string-match "^[ \t]*module\\>" (capitalize body)))
        (let ((vars (org-babel--get-vars params)))
          (when vars (error "Cannot use :vars if `program' statement is present"))
          body)
      (format "program main\n%s\nend program main\n" body)))
  ;; reference: https://stackoverflow.com/questions/40033843/show-the-name-of-a-code-block-in-org-mode-when-export.
  (customize-set-variable 'org-babel-exp-code-template
                          "#+CAPTION: %name label:%name\n#+ATTR_LaTeX: :placement [H] :float t :options label=%name\n#+BEGIN_SRC %lang%switches%flags\n%body\n#+END_SRC")
#+end_src
#+begin_src emacs-lisp :exports both :results output :cache yes
  (customize-set-variable 'org-confirm-babel-evaluate nil)
#+end_src
* utilities
** swap
*** base code
The Fortran code for swap, which is impure subroutine.
The subroutine =swap_${suffix}= is generated once or more in the below org source block.
- =${bash variable}= will be expanded by bash.
  + =${type}= is the type of =arr(:)=.
  + =${type_tmp}= is the type of =tmp= and is usually the same as =${type}=.
#+name: swap-subroutine-description
#+begin_src text :exports code
  ,swap_${suffix}: Swap two elements in arr.
  arguments:
  arr: array of ${type}.
  i, j: integer, indices of array.
  variables:
  tmp: ${type_tmp}, temporary variable for swap.
#+end_src
This is the whole subroutine.
The comment of the subroutine is [[cref:swap-subroutine-description]].
The body of the subroutine is [[cref:swap-subroutine-body]].
#+name: swap-subroutine
#+begin_src fortran :exports code :noweb no-export
  !> <<swap-subroutine-description>>
  subroutine swap_${suffix}(arr, i, j)
    ${type}, intent(inout) :: arr(:)
    integer(int32), intent(in) :: i, j
    ${type_tmp} :: tmp
    <<swap-subroutine-body>>
  end subroutine swap_${suffix}
#+end_src
The algorithm of the swap subroutine is simple.
We store the \(i\)th element of =arr= in =tmp=, substitute \(j\)th element of =arr= into \(i\)th element of =arr= and =tmp= into \(j\)th element of =arr=.
#+name: swap-subroutine-body
#+begin_src fortran :exports code
  tmp    = arr(i)
  arr(i) = arr(j)
  arr(j) = tmp
#+end_src
*** process base code by bash
#+name: swap-subroutine-var
#+begin_src bash :exports code :var type="integer" type_kind="int32" :results output :noweb no-export
  case "${type}" in
      "character")
          suffix="character"
          type_tmp="character(len=:), allocatable"
          type="character(len=*)"
          ;;
      ,*)
          suffix="${type_kind}"
          type_tmp="${type}(${type_kind})"
          type="${type_tmp}"
          ;;
  esac
  cat <<EOF
  <<swap-subroutine>>
  EOF
#+end_src
*** module
#+name: swap-module
#+begin_src fortran :exports code :noweb no-export :tangle "src/swap_m.f90"
  module swap_m
    use, intrinsic :: iso_fortran_env
    implicit none
    private
    public :: swap
    !> ,swap: swap the two elements in the array.
    !> This is generic function for (int32, int64, real32, real64, character).
    interface swap
       module procedure :: swap_int32, swap_int64
       module procedure :: swap_real32, swap_real64
       module procedure :: swap_character
    end interface swap

  contains

    <<swap-subroutine-var(type="integer", type_kind="int32")>>
    <<swap-subroutine-var(type="integer", type_kind="int64")>>
    <<swap-subroutine-var(type="real", type_kind="real32")>>
    <<swap-subroutine-var(type="real", type_kind="real64")>>
    <<swap-subroutine-var(type="character")>>

  end module swap_m
#+end_src
*** test
#+name: swap-test
#+begin_src fortran :exports code :tangle "test/test_swap.f90"
  program test_swap
    use, intrinsic :: iso_fortran_env
    use swap_m
    implicit none
    integer      :: i
    integer      :: a(6) = [1, 2, 3, 4, 5, 6], a_init(6)
    integer      :: tmp_i
    real(real64) :: b(6), b_first(6)
    real(real64) :: epsilon = 1d-6
    character(len=3) :: strs(4) = [character(len=3)::"hi", "hoi", "hey", "hui"], strs_init(4)

    a_init(:) = a(:)
    call swap(a, 1, 1)
    if (sum(a_init - a) /= 0) then
       error stop 1
    end if
    ! print'(*(i0, " "))', (a(i), i = 1, size(a))
    call swap(a, 2, 1)
    ! print'(*(i0, " "))', (a(i), i = 1, size(a))
    if (a_init(2) /= a(1) .or. a_init(1) /= a(2)) then
       error stop 2
    end if

    call random_number(b)
    b_first(:) = b(:)
    ! print'(*(f5.3, " "))', (b(i), i = 1, size(b))
    call swap(b, 3, 4)
    ! print'(*(f5.3, " "))', (b(i), i = 1, size(b))
    if (abs(b_first(4) - b(3)) > epsilon .or. abs(b_first(3) - b(4)) > epsilon) then
       error stop 3
    end if

    strs_init = strs
    ! print'(4(a, ", "))', (strs(i), i = 1, size(strs))
    call swap(strs, 4, 1)
    ! print'(4(a, ", "))', (strs(i), i = 1, size(strs))
    if (strs_init(4) /= strs(1) .or. strs_init(1) /= strs(4)) then
       error stop 4
    end if

  end program test_swap
#+end_src
#+name: test-swap
#+begin_src fortran :exports both :results output :noweb no-export :cache yes
  <<swap-module>>
  <<swap-test>>
#+end_src

#+RESULTS[b955861b0de716ad37774a1e11928e855c0ddac2]:

** is-sorted
*** base
#+name: is-sorted-function
#+begin_src fortran :exports code
  !> ,is_sorted: Check arr is sorted in the ${op} order.
  !> arguments:
  !> arr: array of ${type}.
  !> return:
  !> ${res}: logical, .true. if arr is sorted.
  !> variables:
  !> i: integer, loop counter.
  pure logical function is_sorted_${suffix}(arr) result(${res})
    ${type}, intent(in) :: arr(:)
    integer(int32) :: i
    ${res} = .true.
    do i = 1, size(arr)-1
       if (.not. (arr(i) ${op} arr(i+1))) then
          ${res} = .false.
          return
       end if
    end do
  end function is_sorted_${suffix}
#+end_src
#+name: is-sorted-function-var
#+begin_src bash :exports code :var type="integer" type_kind="int32" op="<=" :results output :noweb yes
  order=""
  if [ "${op}" = ">=" ]; then
      order="descending_"
  fi
  case "${type}" in
      "character")
          type="${type}(len=*)"
          suffix="${order}character"
      ;;
      ,*)
          type="${type}(${type_kind})"
          suffix="${order}${type_kind}"
      ;;
  esac
  res="sorted"
  cat <<EOF
  <<is-sorted-function>>
  EOF
#+end_src
*** module
#+name: is-sorted-module
#+begin_src fortran :exports code :noweb yes :tangle "src/is_sorted_m.f90"
  module is_sorted_m
    use, intrinsic :: iso_fortran_env
    implicit none
    private
    public :: is_sorted, is_sorted_descending
    !> ,is_sorted: Check arr is sorted and return logical value.
    !> This is generic function for (int32, int64, real32, real64, character).
    interface is_sorted
       module procedure :: is_sorted_int32, is_sorted_int64
       module procedure :: is_sorted_real32, is_sorted_real64
       module procedure :: is_sorted_character
    end interface is_sorted
    interface is_sorted_descending
       module procedure :: is_sorted_descending_int32, is_sorted_descending_int64
       module procedure :: is_sorted_descending_real32, is_sorted_descending_real64
       module procedure :: is_sorted_descending_character
    end interface is_sorted_descending

  contains

  !!! Check an array is sorted in the ascending order.
    <<is-sorted-function-var(type="integer", type_kind="int32", op="<=")>>
    <<is-sorted-function-var(type="integer", type_kind="int64", op="<=")>>
    <<is-sorted-function-var(type="real", type_kind="real32", op="<=")>>
    <<is-sorted-function-var(type="real", type_kind="real64", op="<=")>>
    <<is-sorted-function-var(type="character", op="<=")>>
  !!! Check an array is sorted in the descending order.
    <<is-sorted-function-var(type="integer", type_kind="int32", op=">=")>>
    <<is-sorted-function-var(type="integer", type_kind="int64", op=">=")>>
    <<is-sorted-function-var(type="real", type_kind="real32", op=">=")>>
    <<is-sorted-function-var(type="real", type_kind="real64", op=">=")>>
    <<is-sorted-function-var(type="character", op=">=")>>

  end module is_sorted_m
#+end_src
*** test
#+name: is-sorted-test
#+begin_src fortran :exports code :tangle "test/test_is_sorted.f90"
  program is_sorted_test
    use, intrinsic :: iso_fortran_env
    use is_sorted_m
    use merge_sort_m
    implicit none
    integer(int64)    :: sorted_arr(4) = [1_int64, 10_int64, 10_int64, 100_int64]
    real(real32)      :: arr(10)
    character(len=10) :: strings(5) = [character(len=10) :: "apple", "apple", "banana", "brain", "brought"]
    if (.not. is_sorted(sorted_arr)) then
       error stop 1
    end if
    call random_number(arr)
    call merge_sort(arr)
    if (.not. is_sorted(arr)) then
       error stop 2
    end if
    if (.not. is_sorted(strings)) then
       error stop 3
    end if
  end program is_sorted_test
#+end_src
#+name: test-is-sorted
#+begin_src fortran :exports both :results output :cache yes :noweb yes
  <<is-sorted-module>>
  <<merge-sort-module>>
  <<is-sorted-test>>
#+end_src

#+RESULTS[e4ae4f05814e3cf4effe1357e4c9e1b426a73143]: test-is-sorted

* sorting
** insertion-sort
*** base code
The Fortran code for insertion sort, which is impure subroutine.
The subroutine =insertion_sort_${suffix}= is generated once or more in the below org source block.
- =${bash variable}= will be expanded by bash.
  + =${type}= is the type of =arr(:)=.
  + =${type_key}= is the type of =key= and is usually the same as =${type}=.
  + =${suffix}= is the suffix of the name of the subroutine for avoiding name collision.
  + =${op}= is either src_fortran[:exports code]{<} (ascending order) or src_fortran[:exports code]{>} (descending order) .
The subroutine =insertion_sort= takes an argument =arr(:)= in {{{src_line(insertion-sort-arr)}}}, sorts it and =arr(:)= was sorted in the end.
The type of the =key= is usually the same as type of an element in =arr(:)=, but if the type of =arr(:)= is src_fortran[:exports code]{character(len=*)}, =key= must be src_fortran[:exports code]{character(len=:), allocatable}.
The type of =arr_size, i, j= is src_fortran[:exports code]{integer(int32)}.
=arr_size= is size of =arr(:)=.
=i, j= is loop counter.
If \(size(arr) > 2^{31}-1\), this subroutine goes fail, but in this case, we should use more effective sorting algorithms.
#+name: insertion-sort-subroutine
#+begin_src fortran -r :exports code
  !> ,insertion_sort_${suffix}: Sort arr in the ${op} order by insertion-sort.
  !> arguments:
  !> arr: Array of ${type}.
  !> In end of subroutine, arr is sorted.
  !> variables:
  !> key: ${type_key}, insert key into arr(1:i-1).
  !> arr_size: integer, size of arr.
  !> i, j: integer, loop counter.
  subroutine insertion_sort_${suffix}(arr)
    $type, intent(inout) :: arr(:) (ref:insertion-sort-arr)
    $type_key :: key
    integer(int32) :: arr_size, i, j
    arr_size = size(arr)
    do i = 2, arr_size
       key = arr(i)
       do j = i-1, 1, -1
          if (arr(j) $op key) exit
          arr(j+1) = arr(j)
       end do
       arr(j+1) = key
    end do
  end subroutine insertion_sort_${suffix}
#+end_src
*** process base code by bash
We want to expand the variables in the above base code by the various types.
Pass the variables =type=, =type_kind= and =op= by org-babel :var.
#+name: insertion-sort-subroutine-var
#+begin_src bash :exports code :var type="integer" type_kind="int32" op="<" :results output :noweb no-export :cache no :shebang #!/bin/bash
  order=""
  if [ "${op}" = ">" ]; then
      order="descending_"
  fi
  case "${type}" in
      "character")
          type_key="character(len=:), allocatable"
          type="character(len=*)"
          suffix="${order}character"
          ;;
      ,*)
          type_key="${type}(${type_kind})"
          type="${type}(${type_kind})"
          suffix="${order}${type_kind}"
          ;;
  esac
  cat <<EOF
  <<insertion-sort-subroutine>>
  EOF
#+end_src
*** module
We want to expand the variables in the above base code by the various types.
We can pass the arguments to the above org source block.
So, our insertion sort is the generic subroutine for the array of src_fortran[:exports code]{integer(int32)}, src_fortran[:exports code]{integer(int64)}, src_fortran[:exports code]{real(real32)}, src_fortran[:exports code]{real(real64)}, and src_fortran[:exports code]{character(len=*)}
This module exports =insertion_sort= and =insertion_sort_descending=.
#+name: insertion-sort-module
#+begin_src fortran :exports code :noweb no-export :tangle "src/insertion_sort_m.f90"
  module insertion_sort_m
    use, intrinsic :: iso_fortran_env
    implicit none
    private

    public :: insertion_sort, insertion_sort_descending
    !> ,insertion_sort: Sort arr in ascending order.
    !> This is generic subroutine for (int32, int64, real32, real64, character).
    interface insertion_sort
       module procedure :: insertion_sort_int32, insertion_sort_int64
       module procedure :: insertion_sort_real32, insertion_sort_real64
       module procedure :: insertion_sort_character
    end interface insertion_sort
    !> ,insertion_sort_descending: Sort arr in descending order.
    !> This is generic subroutine for (int32, int64, real32, real64, character).
    interface insertion_sort_descending
       module procedure :: insertion_sort_descending_int32, insertion_sort_descending_int64
       module procedure :: insertion_sort_descending_real32, insertion_sort_descending_real64
       module procedure :: insertion_sort_descending_character
    end interface insertion_sort_descending

  contains

  !!! Sort an array in the ascending order.
    <<insertion-sort-subroutine-var(type="integer", type_kind="int32", op="<")>>
    <<insertion-sort-subroutine-var(type="integer", type_kind="int64", op="<")>>
    <<insertion-sort-subroutine-var(type="real", type_kind="real32", op="<")>>
    <<insertion-sort-subroutine-var(type="real", type_kind="real64", op="<")>>
    <<insertion-sort-subroutine-var(type="character", op="<")>>
  !!! Sort an array in the descending order.
    <<insertion-sort-subroutine-var(type="integer", type_kind="int32", op=">")>>
    <<insertion-sort-subroutine-var(type="integer", type_kind="int64", op=">")>>
    <<insertion-sort-subroutine-var(type="real", type_kind="real32", op=">")>>
    <<insertion-sort-subroutine-var(type="real", type_kind="real64", op=">")>>
    <<insertion-sort-subroutine-var(type="character", op=">")>>

  end module insertion_sort_m
#+end_src
*** test
#+name: insertion-sort-test
#+begin_src fortran :exports code :tangle "test/test_insertion_sort.f90"
  program test_insertion_sort
    use, intrinsic :: iso_fortran_env
    use is_sorted_m
    use insertion_sort_m
    implicit none
    integer      :: i
    integer      :: a(6) = [31, 41, 59, 26, 41, 58]
    real(real64) :: b(100)
    character(len=42) :: c(5) = ["a    ", "zzz  ", "123  ", "0    ", "     "]

    ! print'(*(i0, " "))', (a(i), i = 1, size(a))
    call insertion_sort(a)
    if (.not. is_sorted(a)) error stop 1
    ! print'(*(i0, " "))', (a(i), i = 1, size(a))
    call random_number(b)
    ! print'(*(f5.3, " "))', (b(i), i = 1, size(b))
    call insertion_sort(b)
    if (.not. is_sorted(b)) error stop 2
    ! print'(*(f5.3, " "))', (b(i), i = 1, size(b))
    call insertion_sort(c)
    if (.not. is_sorted(c)) error stop 3
  end program test_insertion_sort
#+end_src
#+name: test-insertion-sort
#+begin_src fortran :exports both :results output :noweb no-export :cache yes
  <<is-sorted-module>>
  <<insertion-sort-module>>
  <<insertion-sort-test>>
#+end_src

#+RESULTS[ab9d1aed9e2a01179cddef3596988bcfb45c23c7]: test-insertion-sort

** selection-sort
*** base
#+name: selection-sort
#+begin_src fortran :exports code
    integer :: arr_size, mini_index, i, j
    !> ,selection_sort: Sort arr of some type by selection-sort.
    !> arguments:
    !> arr: array of some type.
    !> variables:
    !> arr_size: integer, size of arr(:).
    !> mini_index: integer, index of minimum value in arr(j:arr_size).
    !> i, j: integer, loop counters.
    arr_size = size(arr)
    do j = 1, arr_size
       mini_index = j
       do i = j+1, arr_size
          if (arr(i) < arr(mini_index)) then
             mini_index = i
          end if
       end do
       call swap(arr, j, mini_index)
    end do
#+end_src
*** module
#+name: selection-sort-module
#+begin_src fortran :exports code :noweb no-export :tangle "src/selection_sort_m.f90"
  module selection_sort_m
    use, intrinsic :: iso_fortran_env
    use swap_m
    implicit none
    private
    public :: selection_sort
    interface selection_sort
       module procedure :: selection_sort_int32, selection_sort_int64
       module procedure :: selection_sort_real32, selection_sort_real64
    end interface selection_sort

  contains

    subroutine selection_sort_int32(arr)
      integer(int32), intent(inout) :: arr(:)
      <<selection-sort>>
    end subroutine selection_sort_int32
    subroutine selection_sort_int64(arr)
      integer(int64), intent(inout) :: arr(:)
      <<selection-sort>>
    end subroutine selection_sort_int64
    subroutine selection_sort_real32(arr)
      real(real32), intent(inout) :: arr(:)
      <<selection-sort>>
    end subroutine selection_sort_real32
    subroutine selection_sort_real64(arr)
      real(real64), intent(inout) :: arr(:)
      <<selection-sort>>
    end subroutine selection_sort_real64

  end module selection_sort_m
#+end_src
*** test
#+name: selection-sort-test
#+begin_src fortran :exports code :noweb no-export
  <<swap-module>>
  <<selection-sort-module>>

  program test_selection_sort
    use, intrinsic :: iso_fortran_env
    use selection_sort_m
    implicit none
    ! integer :: arr(9) = [8, 3, 1, 9, 5, 4, 2, 7, 6]
    integer :: arr(-2:6) = [9, 8, 7, 6, 5, 4, 3, 2, 1]
    integer :: i

    !    do i = -2, 6
    !       arr(i) = i
    !    end do

    print'(*(i0, " "))', (arr(i), i = lbound(arr, dim = 1), ubound(arr, dim = 1))
    call selection_sort(arr)
    print'(*(i0, " "))', (arr(i), i = lbound(arr, dim = 1), ubound(arr, dim = 1))

  end program test_selection_sort
#+end_src

#+RESULTS:
| 9 | 8 | 7 | 6 | 5 | 4 | 3 | 2 | 1 |
| 1 | 2 | 3 | 4 | 5 | 6 | 7 | 8 | 9 |

** bubble-sort
*** base
#+name: bubble-sort
#+begin_src fortran :exports code
    integer(int32) :: size_arr, i, j
    !> ,bubble_sort: Sort arr of some type by bubble-sort.
    !> arguments:
    !> arr: array of some type.
    !> variables:
    !> arr_size: integer, size of arr(:).
    !> i, j: integer, loop counters.
    size_arr = size(arr)
    do i = 1, size_arr
       do j = size_arr, i+1, -1
          if (arr(j) < arr(j-1)) then
             call swap(arr, j, j-1)
          end if
       end do
    end do
#+end_src
*** module
#+name: bubble-sort-module
#+begin_src fortran :exports code :noweb yes :tangle "src/bubble_sort_m.f90"
  module bubble_sort_m
    use, intrinsic :: iso_fortran_env
    use swap_m
    implicit none
    private
    public :: bubble_sort
    interface bubble_sort
       module procedure :: bubble_sort_int32, bubble_sort_int64
       module procedure :: bubble_sort_real32, bubble_sort_real64
    end interface bubble_sort

  contains

    subroutine bubble_sort_int32(arr)
      integer(int32), intent(inout) :: arr(:)
      <<bubble-sort>>
    end subroutine bubble_sort_int32
    subroutine bubble_sort_int64(arr)
      integer(int64), intent(inout) :: arr(:)
      <<bubble-sort>>
    end subroutine bubble_sort_int64
    subroutine bubble_sort_real32(arr)
      real(real32), intent(inout) :: arr(:)
      <<bubble-sort>>
    end subroutine bubble_sort_real32
    subroutine bubble_sort_real64(arr)
      real(real64), intent(inout) :: arr(:)
      <<bubble-sort>>
    end subroutine bubble_sort_real64

  end module bubble_sort_m
#+end_src
*** test
#+name: bubble-sort-test
#+begin_src fortran :exports code :noweb yes
  <<swap-module>>
  <<bubble-sort-module>>

  program test_bubble_sort
    use, intrinsic :: iso_fortran_env
    use bubble_sort_m
    implicit none
    ! integer :: arr(9) = [8, 3, 1, 9, 5, 4, 2, 7, 6]
    integer :: arr(-2:6) = [9, 8, 7, 6, 5, 4, 3, 2, 1]
    integer :: i

    !    do i = -2, 6
    !       arr(i) = i
    !    end do

    print'(*(i0, " "))', (arr(i), i = lbound(arr, dim = 1), ubound(arr, dim = 1))
    call bubble_sort(arr)
    print'(*(i0, " "))', (arr(i), i = lbound(arr, dim = 1), ubound(arr, dim = 1))

  end program test_bubble_sort
#+end_src

#+RESULTS: bubble-sort-test
| 9 | 8 | 7 | 6 | 5 | 4 | 3 | 2 | 1 |
| 1 | 2 | 3 | 4 | 5 | 6 | 7 | 8 | 9 |

** merge-sort
*** base
#+name: merge-sentinel
#+begin_src fortran :exports code
    !> ,merge_sentinel: Algorithm for merge_sort, set sentinel in end of Left and, Right.
    !> arguments:
    !> arr: array of some type, (out) arr(p:r) is sorted.
    !> p, q, r: integer, indices p is start, r is end, q = floor( (p+q)/2 ).
    !> variables:
    !> Left, Right: array of typeof(arr), sorted
    !> i, j, k: integer, loop counter.
    integer(int32), intent(in) :: p, q, r
    integer(int32)             :: i, j, k
    Left(1:q-p+1) = arr(p:q)
    Right(1:r-q)  = arr(q+1:r)
    Left(q-p+2)   = huge(arr(p))
    Right(r-q+1)  = huge(arr(p))
    i = 1
    j = 1
    do k = p, r
       if (Left(i) <= Right(j)) then
          arr(k) = Left(i)
          i = i + 1
       else
          arr(k) = Right(j)
          j = j + 1
       end if
    end do
#+end_src
#+name: merge
#+begin_src fortran :exports code
    integer(int32), intent(in) :: p, q, r
    integer(int32)             :: l_max, r_max
    !> ,merge: Algorithm for merge_sort, check if Left or Right is end in each loop.
    !> arguments:
    !> arr: array of some type, (out) arr(p:r) is sorted.
    !> p, q, r: integer, indices p is start, r is end, q = floor( (p+q)/2 ).
    !> variables:
    !> Left, Right: array of typeof(arr), sorted
    !> l_max, r_max: integer, max index of Left or Right.
    l_max = q-p+1
    r_max = r-q
    block
      !> i, j, k: integer, loop counters.
      integer(int32) :: i, j, k
      Left(1:l_max)  = arr(p:q)
      Right(1:r_max) = arr(q+1:r)
      i = 1
      j = 1
      do k = p, r
         if (Left(i) <= Right(j)) then
            arr(k) = Left(i)
            i = i + 1
            if (i > l_max) then
               arr(k+1:r) = Right(j:)
               return
            end if
         else
            arr(k) = Right(j)
            j = j + 1
            if (j > r_max) then
               arr(k+1:r) = Left(i:)
               return
            end if
         end if
      end do
    end block
#+end_src
#+name: merge-sort-sub
#+begin_src fortran :exports code
    integer(int32), intent(in) :: p, r
    integer(int32)             :: q
    !> ,merge_sort_sub: Recursive function used by merge_sort.
    !> arguments:
    !> arr: array of some type.
    !> p, r: integer, p is start of arr, r is end of arr.
    !> variables:
    !> q: integer, q = floor( (p+q)/2 )
    if (p < r) then
       q = int((r+p)/2, int32)
       call merge_sort_sub(arr, p, q)
       call merge_sort_sub(arr, q+1, r)
       call merge(arr, p, q, r)
    end if
#+end_src
#+name: merge-sort
#+begin_src fortran :exports code
    !> ,merge_sort: Sort arr(:) by sub function merge_sort_sub.
    !> arguments:
    !> arr: array of some type.
    call merge_sort_sub(arr, 1, size(arr))
#+end_src
*** module
#+name: merge-sort-module
#+begin_src fortran :exports code :noweb yes :tangle "src/merge_sort_m.f90"
  module merge_sort_m
    use, intrinsic :: iso_fortran_env
    implicit none
    private
    public :: merge_sort
    interface merge_sentinel
       module procedure :: merge_sentinel_int32, merge_sentinel_int64
       module procedure :: merge_sentinel_real32, merge_sentinel_real64
    end interface merge_sentinel
    interface merge
       module procedure :: merge_int32, merge_int64
       module procedure :: merge_real32, merge_real64
    end interface merge
    interface merge_sort
       module procedure :: merge_sort_int32, merge_sort_int64
       module procedure :: merge_sort_real32, merge_sort_real64
    end interface merge_sort
    interface merge_sort_sub
       module procedure :: merge_sort_sub_int32, merge_sort_sub_int64
       module procedure :: merge_sort_sub_real32, merge_sort_sub_real64
    end interface merge_sort_sub
  contains

    subroutine merge_sentinel_int32(arr, p, q, r)
      integer(int32), intent(inout) :: arr(:)
      integer(int32)                :: Left(1:q-p+2), Right(1:r-q+1)
      <<merge-sentinel>>
    end subroutine merge_sentinel_int32
    subroutine merge_sentinel_int64(arr, p, q, r)
      integer(int64), intent(inout) :: arr(:)
      integer(int64)                :: Left(1:q-p+2), Right(1:r-q+1)
      <<merge-sentinel>>
    end subroutine merge_sentinel_int64
    subroutine merge_sentinel_real32(arr, p, q, r)
      real(real32), intent(inout) :: arr(:)
      real(real32)                :: Left(1:q-p+2), Right(1:r-q+1)
      <<merge-sentinel>>
    end subroutine merge_sentinel_real32
    subroutine merge_sentinel_real64(arr, p, q, r)
      real(real64), intent(inout) :: arr(:)
      real(real64)                :: Left(1:q-p+2), Right(1:r-q+1)
      <<merge-sentinel>>
    end subroutine merge_sentinel_real64

    subroutine merge_int32(arr, p, q, r)
      integer(int32), intent(inout) :: arr(:)
      integer(int32)                :: Left(1:q-p+1), Right(1:r-q)
      <<merge>>
    end subroutine merge_int32
    subroutine merge_int64(arr, p, q, r)
      integer(int64), intent(inout) :: arr(:)
      integer(int64)                :: Left(1:q-p+1), Right(1:r-q)
      <<merge>>
    end subroutine merge_int64
    subroutine merge_real32(arr, p, q, r)
      real(real32), intent(inout) :: arr(:)
      real(real32)                :: Left(1:q-p+1), Right(1:r-q)
      <<merge>>
    end subroutine merge_real32
    subroutine merge_real64(arr, p, q, r)
      real(real64), intent(inout) :: arr(:)
      real(real64)                :: Left(1:q-p+1), Right(1:r-q)
      <<merge>>
    end subroutine merge_real64

    recursive subroutine merge_sort_sub_int32(arr, p, r)
      integer(int32), intent(inout) :: arr(:)
      <<merge-sort-sub>>
    end subroutine merge_sort_sub_int32
    recursive subroutine merge_sort_sub_int64(arr, p, r)
      integer(int64), intent(inout) :: arr(:)
      <<merge-sort-sub>>
    end subroutine merge_sort_sub_int64
    recursive subroutine merge_sort_sub_real32(arr, p, r)
      real(real32), intent(inout) :: arr(:)
      <<merge-sort-sub>>
    end subroutine merge_sort_sub_real32
    recursive subroutine merge_sort_sub_real64(arr, p, r)
      real(real64), intent(inout) :: arr(:)
      <<merge-sort-sub>>
    end subroutine merge_sort_sub_real64

    subroutine merge_sort_int32(arr)
      integer(int32), intent(inout) :: arr(:)
      <<merge-sort>>
    end subroutine merge_sort_int32
    subroutine merge_sort_int64(arr)
      integer(int64), intent(inout) :: arr(:)
      <<merge-sort>>
    end subroutine merge_sort_int64
    subroutine merge_sort_real32(arr)
      real(real32), intent(inout) :: arr(:)
      <<merge-sort>>
    end subroutine merge_sort_real32
    subroutine merge_sort_real64(arr)
      real(real64), intent(inout) :: arr(:)
      <<merge-sort>>
    end subroutine merge_sort_real64

  end module merge_sort_m
#+end_src
*** test
#+name: merge-sort-test
#+begin_src fortran :exports code :tangle "test/test_merge_sort.f90"
  program test_merge
    use, intrinsic :: iso_fortran_env
    use merge_sort_m
    implicit none
    integer :: arr(9) = [8, 3, 1, 9, 5, 4, 2, 7, 6]
    integer :: i

    print'(*(i0, " "))', (arr(i), i = 1, size(arr))
    call merge_sort(arr)
    print'(*(i0, " "))', (arr(i), i = 1, size(arr))

  end program test_merge
#+end_src

#+begin_src fortran :exports both :results output :cache yes :noweb yes
  <<merge-sort-module>>
  <<merge-sort-test>>
#+end_src

#+RESULTS[000d13091ef6658230c2841b92c81c674f0f65c8]:
: 8 3 1 9 5 4 2 7 6
: 1 2 3 4 5 6 7 8 9

* search
** binary-search
*** base
#+name: binary-search
#+begin_src fortran :exports code
  integer(int32), intent(in) :: lb, ub
  integer(int32) :: p, q, r
  !> ,binary_search: Search v from arr
  !> arguments:
  !> v: typeof(v).
  !> arr: array of some type.
  !> lb, ub: integer, lower bound and upper bound of arr.
  !> return:
  !> pos: position of v in arr if lb <= pos <= ub.
  !> v does not exist in arr if pos = lb-1.
  !> variables:
  !> p, r: integer, range of search [p, r]
  !> q: integer, q = floor( (p+r)/2 ).
  p = lb
  r = ub
  do
     if (p > r) then
        pos = lb-1
        return
     end if
     q = int((p+r)/2, int32)
     if (arr(q) == v) then
        pos = q
        return
     else if (arr(q) < v) then
        p = q + 1
     else
        r = q - 1
     end if
  end do
#+end_src
*** module
#+name: binary-search-module
#+begin_src fortran :exports code :noweb yes :tangle "src/binary_search_m.f90"
  module binary_search_m
    use, intrinsic :: iso_fortran_env
    implicit none
    private
    public :: binary_search
    interface binary_search
       module procedure :: binary_search_int32, binary_search_int64
    end interface binary_search

  contains

    pure integer function binary_search_int32(v, arr, lb, ub) result(pos)
      integer(int32), intent(in) :: v
      integer(int32), intent(in) :: arr(lb:ub)
      <<binary-search>>
    end function binary_search_int32
    pure integer function binary_search_int64(v, arr, lb, ub) result(pos)
      integer(int64), intent(in) :: v
      integer(int64), intent(in) :: arr(lb:ub)
      <<binary-search>>
    end function binary_search_int64

  end module binary_search_m
#+end_src
*** test
#+name: binary-search-test
#+begin_src fortran :exports code :tangle "test/test_binary_search.f90"
  program test_binary_search
    use, intrinsic :: iso_fortran_env
    use binary_search_m
    implicit none
    integer :: arr(-1:7) = [1, 2, 3, 4, 4, 6, 7, 8, 9]
    integer :: i
    if (binary_search(2, arr, -1, 7) /= 0) then
       error stop 1
    else if (binary_search(5, arr, -1, 7) /= lbound(arr, dim = 1)-1) then
       error stop 2
    else if (binary_search(9, arr, -1, 7) /= 7) then
       error stop 3
    end if
  end program test_binary_search
#+end_src
#+begin_src fortran :flags -fbacktrace -g :exports both :results output :cache yes :noweb yes
    <<binary-search-module>>

    <<binary-search-test>>
#+end_src

#+RESULTS[ba220b33f2ebf16ce1e74e14608023809130da5e]:

* math
** prime
*** prime factorization
* data structure
** tree
*** integer
#+begin_src fortran :exports code :results output :cache yes
  module tree_int_m
    use, intrinsic :: iso_fortran_env
    implicit none
    private
    public :: tree_parent_int

    type :: tree_parent_int
       private
       type(tree_int), pointer :: parent
    end type tree_parent_int

    type :: tree_int
       private
       integer(int32)          :: val
       type(tree_int), pointer :: left, right
     contains
       procedure :: add => add_tree_int
    end type tree_int

    interface tree_int
       module procedure :: init_tree_int
    end interface tree_int

  contains

    subroutine add_tree_int(this, v)
      class(tree_int), intent(inout) :: this
      integer        , intent(in)    :: v

    end subroutine add_tree_int

  end module tree_int_m
#+end_src
