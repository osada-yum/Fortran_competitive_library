#+TITLE: Implement algorithms in Modern Fortran.
#+AUTHOR: Yuma Osada
#+DATE: {{{time(%Y-%m-%d)}}}.
#+LaTeX_header: \usepackage{minted}
#+LaTeX_header: \usepackage{cleveref}
#+macro: src_line line [[($1)]]
#+options: ^:{}
#+options: toc:t H:4 num:4
* emacs-lisp
** org babel settings
Modify org-babel function to avoid adding ~program...end program~ around ~module...end module~.
#+begin_src emacs-lisp :exports code
  (defun org-babel-fortran-ensure-main-wrap (body params)
    "Wrap body in a \"program ... end program\" block if none exists."
    (if (or (string-match "^[ \t]*program\\>" (capitalize body))
            (string-match "^[ \t]*module\\>" (capitalize body)))
        (let ((vars (org-babel--get-vars params)))
          (when vars (error "Cannot use :vars if `program' statement is present"))
          body)
      (format "program main\n%s\nend program main\n" body)))
  ;; reference: https://stackoverflow.com/questions/40033843/show-the-name-of-a-code-block-in-org-mode-when-export.
  (customize-set-variable 'org-babel-exp-code-template
                          "#+CAPTION: %name label:%name\n#+ATTR_LaTeX: :placement [H] :float t :options label=%name\n#+BEGIN_SRC %lang%switches%flags\n%body\n#+END_SRC")
#+end_src
#+begin_src emacs-lisp :exports both :results output :cache yes
  (customize-set-variable 'org-confirm-babel-evaluate nil)
#+end_src
* org-babel macros
** assertion
#+name: assert-fortran
#+begin_src fortran :exports code
  if (${cond}) then
     write(error_unit, '(a, i0, a)')&
          "Error in "//&
          __FILE__&
          //":", __LINE__, ":"
     write(error_unit, '(a)') "Assertion '${cond_origin}' must be ${true_false}."
     if (len_trim("${message}") /= 0) then
        write(error_unit, '(a)') "Extra message: '${message}'"
     end if
     error stop ${code}
  end if
#+end_src
#+name: assert-true
#+begin_src bash :exports code :var cond=".true." code="127" message="" :results output :noweb no-export
  true_false=false
  cond_origin="${cond}"
  cond="${cond}"
  code=${code}
  message="${message}"
  cat << EOF
  <<assert-fortran>>
  EOF
#+end_src
#+name: assert-false
#+begin_src bash :exports code :var cond=".true." code="127" message="" :results output :noweb no-export
  true_false=true
  cond_origin="${cond}"
  cond=".not. (${cond})"
  code=${code}
  message="${message}"
  cat << EOF
  <<assert-fortran>>
  EOF
#+end_src
#+name: assert-test
#+begin_src fortran :exports code :noweb yes
  program hi
    use, intrinsic :: iso_fortran_env
    implicit none
    integer(int32) :: a = 1, b = 2
    <<assert-true(cond="2<1", code=1, message="in main")>>
    <<assert-false(cond="a < b", code=2, message="")>>
  end program hi
#+end_src

#+RESULTS: assert-test

** error handling
#+name: error-handling-return-ierr
#+begin_src bash :exports code :var ierr=1 :results output :noweb no-export :cache no :shebang #!/bin/bash
  cat <<EOF
    if (present(ierr)) then
      ierr = ${ierr}
      return
    end if
  EOF
#+end_src
#+name: error-handling-filename
#+begin_src fortran :exports code
  write(error_unit, '(a, i0, a)', advance = "no") &
       __FILE__&
       //": ", __LINE__, ": "
#+end_src
#+name: error-handling-error_message-exit
#+begin_src bash :exports code :var err_num=1 string="error message." :results output :noweb no-export :cache no :shebang #!/bin/bash
   cat <<EOF
     write(error_unit, '(a)')&
       "${string}"
     error stop ${err_num}
   EOF
#+end_src
#+name: error-handling-exit
#+begin_src bash :exports code :var err_num=1 :results output :noweb no-export :cache no :shebang #!/bin/bash
  cat <<EOF
    error stop ${err_num}
  EOF
#+end_src
* utilities
** swap
*** base code
We write a swap subroutine by ~Fortran~.
This takes two variables and swaps values of them.
So, this is impure.
We can expand ~bash~ variables that are expressed by =${variable}=, so decide the type of variables later src block.
- Let us explain ~bash~ variables.
  + =${type_arg}= is the type of =i, j=.
  + =${type_tmp}= is the type of =tmp= and is usually the same as =${type_arg}=.
    If =${type_arg}= is src_fortran[:exports code]{character(len=*)}, =${type_tmp}= must be src_fortran[:exports code]{character(len=:), allocatable}.
  + =${suffix}= is the suffix of name of subroutine for generic.
This is the whole subroutine.
The algorithm of the swap is [[cref:swap-subroutine-body]].
#+name: swap-subroutine
#+begin_src fortran :exports code :noweb no-export
  subroutine swap_${suffix}(i, j)
    ${type_arg}, intent(inout) :: i, j
    ${type_tmp} :: tmp
    <<swap-subroutine-body>>
  end subroutine swap_${suffix}
#+end_src
The algorithm of the swap is simple.
We store the =i= in =tmp=, substitute =j= into =i= and =tmp= into =j=.
#+name: swap-subroutine-body
#+begin_src fortran :exports code
  tmp = i
  i   = j
  j   = tmp
#+end_src
*** process base code by bash
#+name: swap-subroutine-var
#+begin_src bash :exports code :var type_arg="integer" type_kind="int32" :results output :noweb no-export
  case "${type_arg}" in
      "character")
          suffix="character"
          type_tmp="character(len=max(len(i), len(j)))"
          type_arg="character(len=*)"
          ;;
      ,*)
          suffix="${type_kind}"
          type_tmp="${type_arg}(${type_kind})"
          type_arg="${type_tmp}"
          ;;
  esac
  cat <<EOF
  <<swap-subroutine>>
  EOF
#+end_src
*** module
#+name: swap-module
#+begin_src fortran :exports code :noweb no-export :tangle "src/swap_m.f90"
  module swap_m
    use, intrinsic :: iso_fortran_env
    implicit none
    private
    public :: swap
    !> ,swap: swap the two elements in the array.
    !> This is generic function for (int32, int64, real32, real64, character).
    interface swap
       module procedure :: swap_int32, swap_int64
       module procedure :: swap_real32, swap_real64
       module procedure :: swap_character
    end interface swap

  contains

    <<swap-subroutine-var(type_arg="integer", type_kind="int32")>>
    <<swap-subroutine-var(type_arg="integer", type_kind="int64")>>
    <<swap-subroutine-var(type_arg="real", type_kind="real32")>>
    <<swap-subroutine-var(type_arg="real", type_kind="real64")>>
    <<swap-subroutine-var(type_arg="character")>>

  end module swap_m
#+end_src
*** test
#+name: swap-test
#+begin_src fortran :exports code :tangle "test/test_swap.f90"
  program test_swap
    use, intrinsic :: iso_fortran_env
    use swap_m
    implicit none
    integer      :: i
    integer      :: a(6) = [1, 2, 3, 4, 5, 6], a_init(6)
    integer      :: tmp_i
    real(real64) :: b(6), b_first(6)
    real(real64) :: epsilon = 1d-6
    character(len=3) :: strs(4) = [character(len=3)::"hi", "hoi", "hey", "hui"], strs_init(4)

    a_init(:) = a(:)
    call swap(a(1), a(1))
    if (sum(a_init - a) /= 0) then
       error stop 1
    end if
    ! print'(*(i0, " "))', (a(i), i = 1, size(a))
    call swap(a(2), a(1))
    ! print'(*(i0, " "))', (a(i), i = 1, size(a))
    if (a_init(2) /= a(1) .or. a_init(1) /= a(2)) then
       error stop 2
    end if

    call random_number(b)
    b_first(:) = b(:)
    ! print'(*(f5.3, " "))', (b(i), i = 1, size(b))
    call swap(b(3), b(4))
    ! print'(*(f5.3, " "))', (b(i), i = 1, size(b))
    if (abs(b_first(4) - b(3)) > epsilon .or. abs(b_first(3) - b(4)) > epsilon) then
       error stop 3
    end if

    strs_init = strs
    ! print'(4(a, ", "))', (strs(i), i = 1, size(strs))
    call swap(strs(4), strs(1))
    ! print'(4(a, ", "))', (strs(i), i = 1, size(strs))
    if (strs_init(4) /= strs(1) .or. strs_init(1) /= strs(4)) then
       error stop 4
    end if

  end program test_swap
#+end_src
#+name: test-swap
#+begin_src fortran :exports both :results output :noweb no-export :cache yes
  <<swap-module>>
  <<swap-test>>
#+end_src

#+RESULTS[812b722e6fbca1b993444bade70915aaa90f1da8]: test-swap

** is-sorted
*** base
#+name: is-sorted-function
#+begin_src fortran :exports code
  !> ,is_sorted: Check arr is sorted in the ${op} order.
  !> arguments:
  !> arr: array of ${type}.
  !> return:
  !> ${res}: logical, .true. if arr is sorted.
  !> variables:
  !> i: integer, loop counter.
  pure logical function is_sorted_${suffix}(arr) result(${res})
    ${type}, intent(in) :: arr(:)
    integer(int32) :: i
    ${res} = .true.
    do i = 1, size(arr)-1
       if (.not. (arr(i) ${op} arr(i+1))) then
          ${res} = .false.
          return
       end if
    end do
  end function is_sorted_${suffix}
#+end_src
#+name: is-sorted-function-var
#+begin_src bash :exports code :var type="integer" type_kind="int32" op="<=" :results output :noweb yes
  order=""
  if [ "${op}" = ">=" ]; then
      order="descending_"
  fi
  case "${type}" in
      "character")
          type="${type}(len=*)"
          suffix="${order}character"
      ;;
      ,*)
          type="${type}(${type_kind})"
          suffix="${order}${type_kind}"
      ;;
  esac
  res="sorted"
  cat <<EOF
  <<is-sorted-function>>
  EOF
#+end_src
*** module
#+name: is-sorted-module
#+begin_src fortran :exports code :noweb yes :tangle "src/is_sorted_m.f90"
  module is_sorted_m
    use, intrinsic :: iso_fortran_env
    implicit none
    private
    public :: is_sorted, is_sorted_descending
    !> ,is_sorted: Check arr is sorted and return logical value.
    !> This is generic function for (int32, int64, real32, real64, character).
    interface is_sorted
       module procedure :: is_sorted_int32, is_sorted_int64
       module procedure :: is_sorted_real32, is_sorted_real64
       module procedure :: is_sorted_character
    end interface is_sorted
    interface is_sorted_descending
       module procedure :: is_sorted_descending_int32, is_sorted_descending_int64
       module procedure :: is_sorted_descending_real32, is_sorted_descending_real64
       module procedure :: is_sorted_descending_character
    end interface is_sorted_descending

  contains

  !!! Check an array is sorted in the ascending order.
    <<is-sorted-function-var(type="integer", type_kind="int32", op="<=")>>
    <<is-sorted-function-var(type="integer", type_kind="int64", op="<=")>>
    <<is-sorted-function-var(type="real", type_kind="real32", op="<=")>>
    <<is-sorted-function-var(type="real", type_kind="real64", op="<=")>>
    <<is-sorted-function-var(type="character", op="<=")>>
  !!! Check an array is sorted in the descending order.
    <<is-sorted-function-var(type="integer", type_kind="int32", op=">=")>>
    <<is-sorted-function-var(type="integer", type_kind="int64", op=">=")>>
    <<is-sorted-function-var(type="real", type_kind="real32", op=">=")>>
    <<is-sorted-function-var(type="real", type_kind="real64", op=">=")>>
    <<is-sorted-function-var(type="character", op=">=")>>

  end module is_sorted_m
#+end_src
*** test
#+name: is-sorted-test
#+begin_src fortran :exports code :tangle "test/test_is_sorted.f90"
  program is_sorted_test
    use, intrinsic :: iso_fortran_env
    use is_sorted_m
    use merge_sort_m
    implicit none
    integer(int64)    :: sorted_arr(4) = [1_int64, 10_int64, 10_int64, 100_int64]
    real(real32)      :: arr(10)
    character(len=10) :: strings(5) = [character(len=10) :: "apple", "apple", "banana", "brain", "brought"]
    if (.not. is_sorted(sorted_arr)) then
       error stop 1
    end if
    call random_number(arr)
    call merge_sort(arr)
    if (.not. is_sorted(arr)) then
       error stop 2
    end if
    if (.not. is_sorted(strings)) then
       error stop 3
    end if
  end program is_sorted_test
#+end_src
#+name: test-is-sorted
#+begin_src fortran :exports both :results output :cache yes :noweb yes
  <<is-sorted-module>>
  <<merge-sort-module>>
  <<is-sorted-test>>
#+end_src

#+RESULTS[e4ae4f05814e3cf4effe1357e4c9e1b426a73143]: test-is-sorted

** polymorphic class(*)
Fortran has polymorphic type =class(*)=.
We can store any values in a variable of =class(*) :: var= and extract value from it by =select type= statement.
*** test
#+begin_src fortran :exports both :results output :cache yes
  module polymorphic_class_m
    use, intrinsic :: iso_fortran_env
    implicit none
    ! interface operator(.as.)
    !    module procedure :: class_to_int32
    !    module procedure :: class_to_real32
    ! end interface operator(.as.)

  contains
    pure integer(int32) function class_to_int32(v)
      class(*), intent(in) :: v
      select type(v)
      type is(integer(int32))
         class_to_int32 = v
      class default
         error stop 2
      end select
    end function class_to_int32

    pure integer(int32) function class_to_int32_dash(v, n)
      class(*), intent(in) :: v
      integer(int32), intent(in) :: n
      select type(v)
      type is(integer(int32))
         class_to_int32_dash = v
      class default
         error stop 2
      end select
    end function class_to_int32_dash
    pure real(real32) function class_to_real32(v, x)
      class(*), intent(in) :: v
      real(real32), intent(in) :: x
      select type(v)
      type is(real(real32))
         class_to_real32 = v
      class default
         error stop 3
      end select
    end function class_to_real32
  end module polymorphic_class_m

  program test_polymorphic_class
    use, intrinsic :: iso_fortran_env
    use polymorphic_class_m
    implicit none
    class(*), pointer :: val
    allocate(val, source = 3)
    ! print*, val .as. 0.0_real32
    print*, class_to_int32(val)
    ! print*, val .as. 0_int32
  end program test_polymorphic_class
#+end_src

#+RESULTS[06aefb575a0f3b072e691d7711c5d7cce0c69e5c]:
: 3

* sorting
** insertion-sort
*** base code
The Fortran code for insertion sort, which is impure subroutine.
The subroutine =insertion_sort_${suffix}= is generated once or more in the below org source block.
- =${bash variable}= will be expanded by bash.
  + =${type}= is the type of =arr(:)=.
  + =${type_key}= is the type of =key= and is usually the same as =${type}=.
  + =${suffix}= is the suffix of the name of the subroutine for avoiding name collision.
  + =${op}= is either src_fortran[:exports code]{<} (ascending order) or src_fortran[:exports code]{>} (descending order) .
The subroutine =insertion_sort= takes an argument =arr(:)= in {{{src_line(insertion-sort-arr)}}}, sorts it and =arr(:)= was sorted in the end.
The type of the =key= is usually the same as type of an element in =arr(:)=, but if the type of =arr(:)= is src_fortran[:exports code]{character(len=*)}, =key= must be src_fortran[:exports code]{character(len=:), allocatable}.
The type of =arr_size, i, j= is src_fortran[:exports code]{integer(int32)}.
=arr_size= is size of =arr(:)=.
=i, j= is loop counter.
If \(size(arr) > 2^{31}-1\), this subroutine goes fail, but in this case, we should use more effective sorting algorithms.
#+name: insertion-sort-subroutine
#+begin_src fortran -r :exports code
  !> ,insertion_sort_${suffix}: Sort arr in the ${op} order by insertion-sort.
  !> arguments:
  !> arr: Array of ${type}.
  !> In end of subroutine, arr is sorted.
  !> variables:
  !> key: ${type_key}, insert key into arr(1:i-1).
  !> arr_size: integer, size of arr.
  !> i, j: integer, loop counter.
  subroutine insertion_sort_${suffix}(arr)
    $type, intent(inout) :: arr(:) (ref:insertion-sort-arr)
    $type_key :: key
    integer(int32) :: arr_size, i, j
    arr_size = size(arr)
    do i = 2, arr_size
       key = arr(i)
       do j = i-1, 1, -1
          if (arr(j) $op key) exit
          arr(j+1) = arr(j)
       end do
       arr(j+1) = key
    end do
  end subroutine insertion_sort_${suffix}
#+end_src
*** process base code by bash
We want to expand the variables in the above base code by the various types.
Pass the variables =type=, =type_kind= and =op= by org-babel :var.
#+name: insertion-sort-subroutine-var
#+begin_src bash :exports code :var type="integer" type_kind="int32" op="<" :results output :noweb no-export :cache no :shebang #!/bin/bash
  order=""
  if [ "${op}" = ">" ]; then
      order="descending_"
  fi
  case "${type}" in
      "character")
          type_key="character(len=:), allocatable"
          type="character(len=*)"
          suffix="${order}character"
          ;;
      ,*)
          type_key="${type}(${type_kind})"
          type="${type}(${type_kind})"
          suffix="${order}${type_kind}"
          ;;
  esac
  cat <<EOF
  <<insertion-sort-subroutine>>
  EOF
#+end_src
*** module
We want to expand the variables in the above base code by the various types.
We can pass the arguments to the above org source block.
So, our insertion sort is the generic subroutine for the array of src_fortran[:exports code]{integer(int32)}, src_fortran[:exports code]{integer(int64)}, src_fortran[:exports code]{real(real32)}, src_fortran[:exports code]{real(real64)}, and src_fortran[:exports code]{character(len=*)}
This module exports =insertion_sort= and =insertion_sort_descending=.
#+name: insertion-sort-module
#+begin_src fortran :exports code :noweb no-export :tangle "src/insertion_sort_m.f90"
  module insertion_sort_m
    use, intrinsic :: iso_fortran_env
    implicit none
    private

    public :: insertion_sort, insertion_sort_descending
    !> ,insertion_sort: Sort arr in ascending order.
    !> This is generic subroutine for (int32, int64, real32, real64, character).
    interface insertion_sort
       module procedure :: insertion_sort_int32, insertion_sort_int64
       module procedure :: insertion_sort_real32, insertion_sort_real64
       module procedure :: insertion_sort_character
    end interface insertion_sort
    !> ,insertion_sort_descending: Sort arr in descending order.
    !> This is generic subroutine for (int32, int64, real32, real64, character).
    interface insertion_sort_descending
       module procedure :: insertion_sort_descending_int32, insertion_sort_descending_int64
       module procedure :: insertion_sort_descending_real32, insertion_sort_descending_real64
       module procedure :: insertion_sort_descending_character
    end interface insertion_sort_descending

  contains

  !!! Sort an array in the ascending order.
    <<insertion-sort-subroutine-var(type="integer", type_kind="int32", op="<")>>
    <<insertion-sort-subroutine-var(type="integer", type_kind="int64", op="<")>>
    <<insertion-sort-subroutine-var(type="real", type_kind="real32", op="<")>>
    <<insertion-sort-subroutine-var(type="real", type_kind="real64", op="<")>>
    <<insertion-sort-subroutine-var(type="character", op="<")>>
  !!! Sort an array in the descending order.
    <<insertion-sort-subroutine-var(type="integer", type_kind="int32", op=">")>>
    <<insertion-sort-subroutine-var(type="integer", type_kind="int64", op=">")>>
    <<insertion-sort-subroutine-var(type="real", type_kind="real32", op=">")>>
    <<insertion-sort-subroutine-var(type="real", type_kind="real64", op=">")>>
    <<insertion-sort-subroutine-var(type="character", op=">")>>

  end module insertion_sort_m
#+end_src
*** test
#+name: insertion-sort-test
#+begin_src fortran :exports code :tangle "test/test_insertion_sort.f90"
  program test_insertion_sort
    use, intrinsic :: iso_fortran_env
    use is_sorted_m
    use insertion_sort_m
    implicit none
    integer      :: i
    integer      :: a(6) = [31, 41, 59, 26, 41, 58]
    real(real64) :: b(100)
    character(len=42) :: c(5) = ["a    ", "zzz  ", "123  ", "0    ", "     "]

    ! print'(*(i0, " "))', (a(i), i = 1, size(a))
    call insertion_sort(a)
    if (.not. is_sorted(a)) error stop 1
    ! print'(*(i0, " "))', (a(i), i = 1, size(a))
    call random_number(b)
    ! print'(*(f5.3, " "))', (b(i), i = 1, size(b))
    call insertion_sort(b)
    if (.not. is_sorted(b)) error stop 2
    ! print'(*(f5.3, " "))', (b(i), i = 1, size(b))
    call insertion_sort(c)
    if (.not. is_sorted(c)) error stop 3
  end program test_insertion_sort
#+end_src
#+name: test-insertion-sort
#+begin_src fortran :exports both :results output :noweb no-export :cache yes
  <<is-sorted-module>>
  <<insertion-sort-module>>
  <<insertion-sort-test>>
#+end_src

#+RESULTS[ab9d1aed9e2a01179cddef3596988bcfb45c23c7]: test-insertion-sort

** selection-sort
*** base
#+name: selection-sort
#+begin_src fortran :exports code
    integer :: arr_size, mini_index, i, j
    !> ,selection_sort: Sort arr of some type by selection-sort.
    !> arguments:
    !> arr: array of some type.
    !> variables:
    !> arr_size: integer, size of arr(:).
    !> mini_index: integer, index of minimum value in arr(j:arr_size).
    !> i, j: integer, loop counters.
    arr_size = size(arr)
    do j = 1, arr_size
       mini_index = j
       do i = j+1, arr_size
          if (arr(i) < arr(mini_index)) then
             mini_index = i
          end if
       end do
       call swap(arr(j), arr(mini_index))
    end do
#+end_src
*** module
#+name: selection-sort-module
#+begin_src fortran :exports code :noweb no-export :tangle "src/selection_sort_m.f90"
  module selection_sort_m
    use, intrinsic :: iso_fortran_env
    use swap_m
    implicit none
    private
    public :: selection_sort
    interface selection_sort
       module procedure :: selection_sort_int32, selection_sort_int64
       module procedure :: selection_sort_real32, selection_sort_real64
    end interface selection_sort

  contains

    subroutine selection_sort_int32(arr)
      integer(int32), intent(inout) :: arr(:)
      <<selection-sort>>
    end subroutine selection_sort_int32
    subroutine selection_sort_int64(arr)
      integer(int64), intent(inout) :: arr(:)
      <<selection-sort>>
    end subroutine selection_sort_int64
    subroutine selection_sort_real32(arr)
      real(real32), intent(inout) :: arr(:)
      <<selection-sort>>
    end subroutine selection_sort_real32
    subroutine selection_sort_real64(arr)
      real(real64), intent(inout) :: arr(:)
      <<selection-sort>>
    end subroutine selection_sort_real64

  end module selection_sort_m
#+end_src
*** test
#+name: selection-sort-test
#+begin_src fortran :exports code :noweb no-export
  <<swap-module>>
  <<selection-sort-module>>

  program test_selection_sort
    use, intrinsic :: iso_fortran_env
    use selection_sort_m
    implicit none
    ! integer :: arr(9) = [8, 3, 1, 9, 5, 4, 2, 7, 6]
    integer :: arr(-2:6) = [9, 8, 7, 6, 5, 4, 3, 2, 1]
    integer :: i

    !    do i = -2, 6
    !       arr(i) = i
    !    end do

    print'(*(i0, " "))', (arr(i), i = lbound(arr, dim = 1), ubound(arr, dim = 1))
    call selection_sort(arr)
    print'(*(i0, " "))', (arr(i), i = lbound(arr, dim = 1), ubound(arr, dim = 1))

  end program test_selection_sort
#+end_src

#+RESULTS:
| 9 | 8 | 7 | 6 | 5 | 4 | 3 | 2 | 1 |
| 1 | 2 | 3 | 4 | 5 | 6 | 7 | 8 | 9 |

** bubble-sort
*** base
#+name: bubble-sort
#+begin_src fortran :exports code
    integer(int32) :: size_arr, i, j
    !> ,bubble_sort: Sort arr of some type by bubble-sort.
    !> arguments:
    !> arr: array of some type.
    !> variables:
    !> arr_size: integer, size of arr(:).
    !> i, j: integer, loop counters.
    size_arr = size(arr)
    do i = 1, size_arr
       do j = size_arr, i+1, -1
          if (arr(j) < arr(j-1)) then
             call swap(arr(j), arr(j-1))
          end if
       end do
    end do
#+end_src
*** module
#+name: bubble-sort-module
#+begin_src fortran :exports code :noweb yes :tangle "src/bubble_sort_m.f90"
  module bubble_sort_m
    use, intrinsic :: iso_fortran_env
    use swap_m
    implicit none
    private
    public :: bubble_sort
    interface bubble_sort
       module procedure :: bubble_sort_int32, bubble_sort_int64
       module procedure :: bubble_sort_real32, bubble_sort_real64
    end interface bubble_sort

  contains

    subroutine bubble_sort_int32(arr)
      integer(int32), intent(inout) :: arr(:)
      <<bubble-sort>>
    end subroutine bubble_sort_int32
    subroutine bubble_sort_int64(arr)
      integer(int64), intent(inout) :: arr(:)
      <<bubble-sort>>
    end subroutine bubble_sort_int64
    subroutine bubble_sort_real32(arr)
      real(real32), intent(inout) :: arr(:)
      <<bubble-sort>>
    end subroutine bubble_sort_real32
    subroutine bubble_sort_real64(arr)
      real(real64), intent(inout) :: arr(:)
      <<bubble-sort>>
    end subroutine bubble_sort_real64

  end module bubble_sort_m
#+end_src
*** test
#+name: bubble-sort-test
#+begin_src fortran :exports code :noweb yes
  <<swap-module>>
  <<bubble-sort-module>>

  program test_bubble_sort
    use, intrinsic :: iso_fortran_env
    use bubble_sort_m
    implicit none
    ! integer :: arr(9) = [8, 3, 1, 9, 5, 4, 2, 7, 6]
    integer :: arr(-2:6) = [9, 8, 7, 6, 5, 4, 3, 2, 1]
    integer :: i

    !    do i = -2, 6
    !       arr(i) = i
    !    end do

    print'(*(i0, " "))', (arr(i), i = lbound(arr, dim = 1), ubound(arr, dim = 1))
    call bubble_sort(arr)
    print'(*(i0, " "))', (arr(i), i = lbound(arr, dim = 1), ubound(arr, dim = 1))

  end program test_bubble_sort
#+end_src

#+RESULTS: bubble-sort-test
| 9 | 8 | 7 | 6 | 5 | 4 | 3 | 2 | 1 |
| 1 | 2 | 3 | 4 | 5 | 6 | 7 | 8 | 9 |

** merge-sort
*** base
#+name: merge-sentinel
#+begin_src fortran :exports code
    !> ,merge_sentinel: Algorithm for merge_sort, set sentinel in end of Left and, Right.
    !> arguments:
    !> arr: array of some type, (out) arr(p:r) is sorted.
    !> p, q, r: integer, indices p is start, r is end, q = floor( (p+q)/2 ).
    !> variables:
    !> Left, Right: array of typeof(arr), sorted
    !> i, j, k: integer, loop counter.
    integer(int32), intent(in) :: p, q, r
    integer(int32)             :: i, j, k
    Left(1:q-p+1) = arr(p:q)
    Right(1:r-q)  = arr(q+1:r)
    Left(q-p+2)   = huge(arr(p))
    Right(r-q+1)  = huge(arr(p))
    i = 1
    j = 1
    do k = p, r
       if (Left(i) <= Right(j)) then
          arr(k) = Left(i)
          i = i + 1
       else
          arr(k) = Right(j)
          j = j + 1
       end if
    end do
#+end_src
#+name: merge
#+begin_src fortran :exports code
    integer(int32), intent(in) :: p, q, r
    integer(int32)             :: l_max, r_max
    !> ,merge: Algorithm for merge_sort, check if Left or Right is end in each loop.
    !> arguments:
    !> arr: array of some type, (out) arr(p:r) is sorted.
    !> p, q, r: integer, indices p is start, r is end, q = floor( (p+q)/2 ).
    !> variables:
    !> Left, Right: array of typeof(arr), sorted
    !> l_max, r_max: integer, max index of Left or Right.
    l_max = q-p+1
    r_max = r-q
    block
      !> i, j, k: integer, loop counters.
      integer(int32) :: i, j, k
      Left(1:l_max)  = arr(p:q)
      Right(1:r_max) = arr(q+1:r)
      i = 1
      j = 1
      do k = p, r
         if (Left(i) <= Right(j)) then
            arr(k) = Left(i)
            i = i + 1
            if (i > l_max) then
               arr(k+1:r) = Right(j:)
               return
            end if
         else
            arr(k) = Right(j)
            j = j + 1
            if (j > r_max) then
               arr(k+1:r) = Left(i:)
               return
            end if
         end if
      end do
    end block
#+end_src
#+name: merge-sort-sub
#+begin_src fortran :exports code
    integer(int32), intent(in) :: p, r
    integer(int32)             :: q
    !> ,merge_sort_sub: Recursive function used by merge_sort.
    !> arguments:
    !> arr: array of some type.
    !> p, r: integer, p is start of arr, r is end of arr.
    !> variables:
    !> q: integer, q = floor( (p+q)/2 )
    if (p < r) then
       q = int((r+p)/2, int32)
       call merge_sort_sub(arr, p, q)
       call merge_sort_sub(arr, q+1, r)
       call merge(arr, p, q, r)
    end if
#+end_src
#+name: merge-sort
#+begin_src fortran :exports code
    !> ,merge_sort: Sort arr(:) by sub function merge_sort_sub.
    !> arguments:
    !> arr: array of some type.
    call merge_sort_sub(arr, 1, size(arr))
#+end_src
*** module
#+name: merge-sort-module
#+begin_src fortran :exports code :noweb yes :tangle "src/merge_sort_m.f90"
  module merge_sort_m
    use, intrinsic :: iso_fortran_env
    implicit none
    private
    public :: merge_sort
    interface merge_sentinel
       module procedure :: merge_sentinel_int32, merge_sentinel_int64
       module procedure :: merge_sentinel_real32, merge_sentinel_real64
    end interface merge_sentinel
    interface merge
       module procedure :: merge_int32, merge_int64
       module procedure :: merge_real32, merge_real64
    end interface merge
    interface merge_sort
       module procedure :: merge_sort_int32, merge_sort_int64
       module procedure :: merge_sort_real32, merge_sort_real64
    end interface merge_sort
    interface merge_sort_sub
       module procedure :: merge_sort_sub_int32, merge_sort_sub_int64
       module procedure :: merge_sort_sub_real32, merge_sort_sub_real64
    end interface merge_sort_sub
  contains

    subroutine merge_sentinel_int32(arr, p, q, r)
      integer(int32), intent(inout) :: arr(:)
      integer(int32)                :: Left(1:q-p+2), Right(1:r-q+1)
      <<merge-sentinel>>
    end subroutine merge_sentinel_int32
    subroutine merge_sentinel_int64(arr, p, q, r)
      integer(int64), intent(inout) :: arr(:)
      integer(int64)                :: Left(1:q-p+2), Right(1:r-q+1)
      <<merge-sentinel>>
    end subroutine merge_sentinel_int64
    subroutine merge_sentinel_real32(arr, p, q, r)
      real(real32), intent(inout) :: arr(:)
      real(real32)                :: Left(1:q-p+2), Right(1:r-q+1)
      <<merge-sentinel>>
    end subroutine merge_sentinel_real32
    subroutine merge_sentinel_real64(arr, p, q, r)
      real(real64), intent(inout) :: arr(:)
      real(real64)                :: Left(1:q-p+2), Right(1:r-q+1)
      <<merge-sentinel>>
    end subroutine merge_sentinel_real64

    subroutine merge_int32(arr, p, q, r)
      integer(int32), intent(inout) :: arr(:)
      integer(int32)                :: Left(1:q-p+1), Right(1:r-q)
      <<merge>>
    end subroutine merge_int32
    subroutine merge_int64(arr, p, q, r)
      integer(int64), intent(inout) :: arr(:)
      integer(int64)                :: Left(1:q-p+1), Right(1:r-q)
      <<merge>>
    end subroutine merge_int64
    subroutine merge_real32(arr, p, q, r)
      real(real32), intent(inout) :: arr(:)
      real(real32)                :: Left(1:q-p+1), Right(1:r-q)
      <<merge>>
    end subroutine merge_real32
    subroutine merge_real64(arr, p, q, r)
      real(real64), intent(inout) :: arr(:)
      real(real64)                :: Left(1:q-p+1), Right(1:r-q)
      <<merge>>
    end subroutine merge_real64

    recursive subroutine merge_sort_sub_int32(arr, p, r)
      integer(int32), intent(inout) :: arr(:)
      <<merge-sort-sub>>
    end subroutine merge_sort_sub_int32
    recursive subroutine merge_sort_sub_int64(arr, p, r)
      integer(int64), intent(inout) :: arr(:)
      <<merge-sort-sub>>
    end subroutine merge_sort_sub_int64
    recursive subroutine merge_sort_sub_real32(arr, p, r)
      real(real32), intent(inout) :: arr(:)
      <<merge-sort-sub>>
    end subroutine merge_sort_sub_real32
    recursive subroutine merge_sort_sub_real64(arr, p, r)
      real(real64), intent(inout) :: arr(:)
      <<merge-sort-sub>>
    end subroutine merge_sort_sub_real64

    subroutine merge_sort_int32(arr)
      integer(int32), intent(inout) :: arr(:)
      <<merge-sort>>
    end subroutine merge_sort_int32
    subroutine merge_sort_int64(arr)
      integer(int64), intent(inout) :: arr(:)
      <<merge-sort>>
    end subroutine merge_sort_int64
    subroutine merge_sort_real32(arr)
      real(real32), intent(inout) :: arr(:)
      <<merge-sort>>
    end subroutine merge_sort_real32
    subroutine merge_sort_real64(arr)
      real(real64), intent(inout) :: arr(:)
      <<merge-sort>>
    end subroutine merge_sort_real64

  end module merge_sort_m
#+end_src
*** test
#+name: merge-sort-test
#+begin_src fortran :exports code :tangle "test/test_merge_sort.f90"
  program test_merge
    use, intrinsic :: iso_fortran_env
    use merge_sort_m
    implicit none
    integer :: arr(9) = [8, 3, 1, 9, 5, 4, 2, 7, 6]
    integer :: i

    print'(*(i0, " "))', (arr(i), i = 1, size(arr))
    call merge_sort(arr)
    print'(*(i0, " "))', (arr(i), i = 1, size(arr))

  end program test_merge
#+end_src

#+begin_src fortran :exports both :results output :cache yes :noweb yes
  <<merge-sort-module>>
  <<merge-sort-test>>
#+end_src

#+RESULTS[000d13091ef6658230c2841b92c81c674f0f65c8]:
: 8 3 1 9 5 4 2 7 6
: 1 2 3 4 5 6 7 8 9

** heap-sort
*** base code
#+name: heap_sort
#+begin_src fortran :exports code
  subroutine heap_sort${suffix}(arr)
    ${type_arg}, intent(inout) :: arr(:)
    integer(int32) :: size, i
    size = size(arr)
    do i = 1, size
       call shift_up(arr, i)
    end do
    do i = size-1, 1, -1
       call swap(1, arr(i))
       call shift_down(arr, i)
    end do
  end subroutine heap_sort${suffix}
#+end_src
#+name: shift_up
#+begin_src fortran :exports code
  subroutine shift_up${suffix}(arr, n)
    ${type_arg}, intent(inout) :: arr(:)
    integer(int32), intent(in) :: n
    integer(int32) :: pos
    pos = n
    do
       if (pos == 1) exit
       if (arr(pos) > arr(pos/2)) exit
       call swap(arr(pos), arr(pos/2))
       pos = pos/2
    end do
  end subroutine shift_up${suffix}
#+end_src
#+name: shift_down
#+begin_src fortran :exports code
  subroutine shift_down${suffix}(arr, n)
    ${type_arg}, intent(inout) :: arr(:)
    integer(int32), intent(in) :: n
    integer(int32) :: pos
    pos = 1
    do
       if (pos*2 > n) exit
       if (arr(pos*2) > arr(pos)) then
          pos = pos*2
          if (pos == n) then
             call swap(arr(pos), arr(pos/2))
             exit
          end if
          if (arr(pos*2+1) > arr(pos*2)) pos = pos+1
          call swap(arr(pos), arr(pos/2))
       end if
    end do
  end subroutine shift_down${suffix}
#+end_src
*** test
* search
** binary-search
*** base
#+name: binary-search
#+begin_src fortran :exports code
  integer(int32), intent(in) :: lb, ub
  integer(int32) :: p, q, r
  !> ,binary_search: Search v from arr
  !> arguments:
  !> v: typeof(v).
  !> arr: array of some type.
  !> lb, ub: integer, lower bound and upper bound of arr.
  !> return:
  !> pos: position of v in arr if lb <= pos <= ub.
  !> v does not exist in arr if pos = lb-1.
  !> variables:
  !> p, r: integer, range of search [p, r]
  !> q: integer, q = floor( (p+r)/2 ).
  p = lb
  r = ub
  do
     if (p > r) then
        pos = lb-1
        return
     end if
     q = int((p+r)/2, int32)
     if (arr(q) == v) then
        pos = q
        return
     else if (arr(q) < v) then
        p = q + 1
     else
        r = q - 1
     end if
  end do
#+end_src
*** module
#+name: binary-search-module
#+begin_src fortran :exports code :noweb yes :tangle "src/binary_search_m.f90"
  module binary_search_m
    use, intrinsic :: iso_fortran_env
    implicit none
    private
    public :: binary_search
    interface binary_search
       module procedure :: binary_search_int32, binary_search_int64
    end interface binary_search

  contains

    pure integer function binary_search_int32(v, arr, lb, ub) result(pos)
      integer(int32), intent(in) :: v
      integer(int32), intent(in) :: arr(lb:ub)
      <<binary-search>>
    end function binary_search_int32
    pure integer function binary_search_int64(v, arr, lb, ub) result(pos)
      integer(int64), intent(in) :: v
      integer(int64), intent(in) :: arr(lb:ub)
      <<binary-search>>
    end function binary_search_int64

  end module binary_search_m
#+end_src
*** test
#+name: binary-search-test
#+begin_src fortran :exports code :tangle "test/test_binary_search.f90"
  program test_binary_search
    use, intrinsic :: iso_fortran_env
    use binary_search_m
    implicit none
    integer :: arr(-1:7) = [1, 2, 3, 4, 4, 6, 7, 8, 9]
    integer :: i
    if (binary_search(2, arr, -1, 7) /= 0) then
       error stop 1
    else if (binary_search(5, arr, -1, 7) /= lbound(arr, dim = 1)-1) then
       error stop 2
    else if (binary_search(9, arr, -1, 7) /= 7) then
       error stop 3
    end if
  end program test_binary_search
#+end_src
#+begin_src fortran :flags -fbacktrace -g :exports both :results output :cache yes :noweb yes
    <<binary-search-module>>

    <<binary-search-test>>
#+end_src

#+RESULTS[ba220b33f2ebf16ce1e74e14608023809130da5e]:

* math
** prime
*** prime factorization
* data structure
** Comparable
*** whole module of comparable class
The children of =comparable= implement relational operators(=<=, =>=, =<==, =>==, ====, =/==).
The user of the child class must implement two operators (=<== and ===), (=<==, and =/==).
#+name: comparable-module
#+begin_src fortran :exports code :tangle "src/comparable_m.f90" :comments link :noweb no-export
  module comparable_m
    use, intrinsic :: iso_fortran_env
    implicit none
    private
    <<declaration-comparable>>
  contains
    <<procedures-comparable>>
  end module comparable_m
#+end_src
**** declaration of the comparable class
#+name: declaration-comparable
#+begin_src fortran :exports code
    public :: comparable
    type :: comparable
     contains
       procedure, pass :: less    => less_comparable
       procedure, pass :: less_equal    => less_equal_comparable
       procedure, pass :: greater => greater_comparable
       procedure, pass :: greater_equal => greater_equal_comparable
       procedure, pass :: equal => equal_comparable
       procedure, pass :: not_equal => not_equal_comparable
       generic :: operator(<) => less
       generic :: operator(<=) => less_equal
       generic :: operator(>) => greater
       generic :: operator(>=) => greater_equal
       generic :: operator(==) => equal
       generic :: operator(/=) => not_equal
    end type comparable
#+end_src
**** procedures of the comparable class
:PROPERTIES:
:header-args: :noweb-ref procedures-comparable
:END:
***** definition of <

The definition of =<= is given by =<== and =/==.
#+name: definition-less
#+begin_src fortran :exports code
  logical function less_comparable(lhs, rhs)
    class(comparable), intent(in) :: lhs
    class(comparable), intent(in) :: rhs
    less_comparable = (lhs <= rhs) .and. (lhs /= rhs)
  end function less_comparable
#+end_src
***** definition of <=

The definition of =<== must be overridden.
#+name: definition-less-equal
#+begin_src fortran :exports code
  logical function less_equal_comparable(lhs, rhs)
    class(comparable), intent(in) :: lhs
    class(comparable), intent(in) :: rhs
    error stop "You must implement less_equal in the child class of comparable."
  end function less_equal_comparable
#+end_src
***** definition of >

The definition of =>= is given by =<==.
#+name: definition-greater
#+begin_src fortran :exports code
  logical function greater_comparable(lhs, rhs)
    class(comparable), intent(in) :: lhs
    class(comparable), intent(in) :: rhs
    greater_comparable = .not. (lhs <= rhs)
  end function greater_comparable
#+end_src
***** definition of >=

The definition of =>== is given by ==== and =<==.
#+name: definition-greater-equal
#+begin_src fortran :exports code
  logical function greater_equal_comparable(lhs, rhs)
    class(comparable), intent(in) :: lhs
    class(comparable), intent(in) :: rhs
    greater_equal_comparable = (lhs == rhs) .or. (.not. (lhs <= rhs))
  end function greater_equal_comparable
#+end_src
***** definition of ==

The definition of ==== is given by =/==.
The definition of either ==== or =/== must be overridden.
#+name: definition-equal
#+begin_src fortran :exports code
  logical function equal_comparable(lhs, rhs)
    class(comparable), intent(in) :: lhs
    class(comparable), intent(in) :: rhs
    equal_comparable = .not. (lhs /= rhs)
  end function equal_comparable
#+end_src
***** definition of =/==

The definition of =/== is given by ====.
The definition of either ==== or =/== must be overridden.
#+name: definition-not-equal
#+begin_src fortran :exports code
  logical function not_equal_comparable(lhs, rhs)
    class(comparable), intent(in) :: lhs
    class(comparable), intent(in) :: rhs
    not_equal_comparable = .not. (lhs == rhs)
  end function not_equal_comparable
#+end_src
*** test
**** test module
#+name: comparable-test-module
#+begin_src fortran :exports code :tangle "test/test_comparable_m.F90" :comments link :noweb no-export
  module comparable_test_m
    use, intrinsic :: iso_fortran_env
    use comparable_m
    implicit none
    private
    public :: comp_int
    type, extends(comparable) :: comp_int
       integer(int32) :: val_
     contains
       procedure, pass :: val => val_comp_int
       procedure, pass :: less_equal => less_equal_comp_int
       procedure, pass :: equal => equal_comp_int
    end type comp_int
  contains
    pure integer(int32) function val_comp_int(this)
      class(comp_int), intent(in) :: this
      val_comp_int = this%val_
    end function val_comp_int
    logical function less_equal_comp_int(lhs, rhs)
      class(comp_int), intent(in) :: lhs
      class(comparable), intent(in) :: rhs
      <<assert-false(cond="same_type_as(lhs, rhs)", code=1, message="in comparable_test_m:less_equal_comp_int: Do not compare different types.")>>
      select type (rhs)
      type is (comp_int)
         less_equal_comp_int = lhs%val() <= rhs%val()
      end select
    end function less_equal_comp_int
    logical function equal_comp_int(lhs, rhs)
      class(comp_int), intent(in) :: lhs
      class(comparable), intent(in) :: rhs
      <<assert-false(cond="same_type_as(lhs, rhs)", code=2, message="in comparable_test_m:less_equal_comp_int: Do not compare different types.")>>
      select type (rhs)
      type is (comp_int)
         equal_comp_int = lhs%val() == rhs%val()
      end select
    end function equal_comp_int
  end module comparable_test_m
#+end_src
**** main
#+name: comparable-test
#+begin_src fortran :exports code :tangle "test/test_comparable.F90" :comments link :noweb no-export
  program test_comparable
    use, intrinsic :: iso_fortran_env
    use comparable_m
    use comparable_test_m
    implicit none
    type(comp_int) :: a
    class(comparable), pointer :: b
    a = comp_int(39)
    allocate(b, source = comp_int(42))
    <<assert-false(cond="a < b", code=1, message="in main")>>
    <<assert-false(cond="a <= b", code=2, message="in main")>>
    <<assert-true(cond="a >= b", code=3, message="in main")>>
    <<assert-true(cond="a > b", code=4, message="in main")>>
    <<assert-false(cond="a < b", code=5, message="in main")>>
    <<assert-false(cond="a <= a", code=6, message="in main")>>
    <<assert-false(cond="a == a", code=7, message="in main")>>
    <<assert-true(cond="a /= a", code=8, message="in main")>>
    <<assert-true(cond="b < a", code=9, message="in main")>>
    <<assert-true(cond="b <= a", code=10, message="in main")>>
    <<assert-false(cond="b >= a", code=11, message="in main")>>
    <<assert-false(cond="b > a", code=12, message="in main")>>
  end program test_comparable
#+end_src
**** whole test
#+begin_src fortran :flags -fbacktrace -g :exports both :results output :cache yes :noweb no-export
    <<comparable-module>>
    <<comparable-test-module>>
    <<comparable-test>>
#+end_src

#+RESULTS[8a03d93a42e56c4ce762831226dc68cbde7e917e]:

** linked list
*** by pointer
**** whole module of linked list
#+name: linked_list-module
#+begin_src fortran :exports code :tangle "src/linked_list_m.f90" :comment link :noweb no-export
  module linked_list_m
    use, intrinsic :: iso_fortran_env
    implicit none
    <<declaration-linked_list-var(type="integer", type_kind="int32")>>
    <<declaration-linked_list-var(type="integer", type_kind="int64")>>
    <<declaration-linked_list-var(type="real", type_kind="real32")>>
    <<declaration-linked_list-var(type="real", type_kind="real64")>>
  contains
    <<procedures-linked_list-var(type="integer", type_kind="int32")>>
    <<procedures-linked_list-var(type="integer", type_kind="int64")>>
    <<procedures-linked_list-var(type="real", type_kind="real32")>>
    <<procedures-linked_list-var(type="real", type_kind="real64")>>
  end module linked_list_m
#+end_src
**** declaration of linked list
First, We define type of linked list.
This linked list is implemented by a head of list and some lists (0 or more than).
The list can add new values, delete, and search some elements.

Variables like ${variable} are expanded by bash.
- ${type} is type of elements in the list.
#+name: declaration-linked_list
#+begin_src fortran :exports code
  private :: linked_list_${suffix}
  type :: linked_list_${suffix}
     private
     ${type} :: val_
     type(linked_list_${suffix}), pointer :: next_ => null()
  end type linked_list_${suffix}

  public :: linked_list_${suffix}_head
  type :: linked_list_${suffix}_head
     private
     type(linked_list_${suffix}), pointer :: head_ => null()
   contains
     procedure, pass :: add    => add_linked_list_${suffix}_head
     procedure, pass :: delete => delete_linked_list_${suffix}_head
     procedure, pass :: search => search_linked_list_${suffix}_head
  end type linked_list_${suffix}_head

  interface linked_list_${suffix}
     module procedure :: init_linked_list_${suffix}
  end interface linked_list_${suffix}
  interface linked_list_${suffix}_head
     module procedure :: init_linked_list_${suffix}_head
     module procedure :: init_linked_list_${suffix}_head_by_array
  end interface linked_list_${suffix}_head
#+end_src
**** procedures of linked list
:PROPERTIES:
:header-args: :noweb-ref procedures-linked_list
:END:
There are four procedures for the linked list.
***** init
=function init= initialize linked_list and linked_list
#+name: init-linked_list
#+begin_src fortran :exports code
  !> init_linked_list_${suffix}: Initialize the linked_list_${suffix} by val.
  impure function init_linked_list_${suffix}(val) result(lst)
    type(linked_list_${suffix}), pointer :: lst
    ${type} :: val
    allocate(lst)
    lst%val_ = val
    return
  end function init_linked_list_${suffix}
#+end_src
#+name: init-linked_list_head
#+begin_src fortran :exports code
  !> init_linked_list_${suffix}_head: Initialize the empty linked_list_${suffix}_head.
  impure function init_linked_list_${suffix}_head() result(lst_head)
    type(linked_list_${suffix}_head) :: lst_head
    lst_head%head_ => null()
    return
  end function init_linked_list_${suffix}_head
  !> init_linked_list_${suffix}_head_by_array: Initialize the empty linked_list_${suffix}_head by array.
  impure function init_linked_list_${suffix}_head_by_array(arr) result(lst_head)
    type(linked_list_${suffix}_head) :: lst_head
    ${type} :: arr(:)
    integer(int32) :: s, i
    s = size(arr)
    do i = s, 1, -1
       call lst_head%add(arr(i))
    end do
    return
  end function init_linked_list_${suffix}_head_by_array
#+end_src
***** add
=Subroutine add= adds value into the linked list.
#+name: add-linked_list_head
#+begin_src fortran :exports code
  !> add_linked_list_${suffix}: Add val into head of linked list.
  subroutine add_linked_list_${suffix}_head(lst_head, val)
    class(linked_list_${suffix}_head), intent(inout) :: lst_head
    ${type}, intent(in) :: val
    type(linked_list_${suffix}), pointer :: lst_elem
    lst_elem => linked_list_${suffix}(val)
    lst_elem%next_ => lst_head%head_
    lst_head%head_ => lst_elem
  end subroutine add_linked_list_${suffix}_head
#+end_src
***** delete
=Subroutine delete= delete elements in linked list.
#+name: delete-linked_list_head
#+begin_src fortran :exports code
  !> delete_linked_list_${suffix}: Delete val from element of linked list.
  !> Do nothing if lst does not elem val.
  subroutine delete_linked_list_${suffix}_head(lst_head, val)
    class(linked_list_${suffix}_head), intent(inout) :: lst_head
    ${type}, intent(in) :: val
    type(linked_list_${suffix}), pointer :: lst_elem, lst_del
    if (.not. associated(lst_head%head_)) return
    lst_elem => lst_head%head_
    if (lst_elem%val_ == val) then
       lst_head%head_ => lst_elem%next_
       deallocate(lst_elem)
       return
    end if
    do
       if (.not. associated(lst_elem%next_)) return
       if (lst_elem%next_%val_ == val) then
          lst_del => lst_elem%next_
          lst_elem%next_ => lst_elem%next_%next_
          deallocate(lst_del)
          return
       end if
    end do
  end subroutine delete_linked_list_${suffix}_head
#+end_src
***** search
=Subroutine search= search value from linked list and return =.true.= if success.
#+name: search-linked_list_head
#+begin_src fortran :exports code
  !> search_linked_list_${suffix}: Search val from element of linked list.
  !> Return .true. if success.
  logical function search_linked_list_${suffix}_head(lst_head, val) result(find)
    class(linked_list_${suffix}_head), intent(in) :: lst_head
    ${type}, intent(in) :: val
    type(linked_list_${suffix}), pointer :: lst_elem
    if (.not. associated(lst_head%head_)) return
    lst_elem => lst_head%head_
    find = .false.
    do
       if (.not. associated(lst_elem)) return
       if (lst_elem%val_ == val) then
          find = .true.
          return
       end if
       lst_elem => lst_elem%next_
    end do
  end function search_linked_list_${suffix}_head
#+end_src
**** process definition and procedures of linked list
#+name: declaration-linked_list-var
#+begin_src bash :exports code :var type="integer" type_kind="int32" :results output :noweb no-export :cache no :shebang #!/bin/bash
  case "${type}" in
      "character")
          type="character(len=:), allocatable"
          suffix="character"
          ;;
      ,*)
          type="${type}(${type_kind})"
          suffix="${type_kind}"
          ;;
  esac
  cat <<EOF
  <<declaration-linked_list>>
  EOF
#+end_src
#+name: procedures-linked_list-var
#+begin_src bash :exports code :var type="integer" type_kind="int32" :results output :noweb no-export :cache no :shebang #!/bin/bash
  case "${type}" in
      "character")
          type="character(len=:), allocatable"
          suffix="character"
          ;;
      ,*)
          type="${type}(${type_kind})"
          suffix="${type_kind}"
          ;;
  esac
  cat <<EOF
  <<procedures-linked_list>>
  EOF
#+end_src
**** test
#+name: linked_list-test
#+begin_src fortran :exports code :tangle "test/test_linked_list.f90"
  program test_linked_list
    use, intrinsic :: iso_fortran_env
    use linked_list_m
    implicit none
    integer(int32) :: i
    type(linked_list_int32_head) :: lst_i32
    do i = 1, 10
       call lst_i32%add(i)
    end do
    print*, lst_i32%search(3)
    print*, lst_i32%search(-1)
  end program test_linked_list
#+end_src
#+name: test-linked_list
#+begin_src fortran :exports both :results output :noweb no-export :cache yes
<<linked_list-module>>
<<linked_list-test>>
#+end_src

#+RESULTS[94846b1ec8b475a77907acdcedad9a0da205232b]: test-linked_list
: T
: F

** Vector (Variable array)
*** whole module of the vector
#+name: vector-module
#+begin_src fortran :exports code :tangle "src/vector_m.F90" :comment link :noweb no-export
  module vector_m
    use, intrinsic :: iso_fortran_env
    implicit none
  <<declaration-vector-var(type="integer", type_kind="int32")>>
  <<declaration-vector-var(type="integer", type_kind="int64")>>
  <<declaration-vector-var(type="real", type_kind="real32")>>
  <<declaration-vector-var(type="real", type_kind="real64")>>
  <<declaration-vector-var(type="logical")>>
  contains
  <<procedures-vector-var(type="integer", type_kind="int32")>>
  <<procedures-vector-var(type="integer", type_kind="int64")>>
  <<procedures-vector-var(type="real", type_kind="real32")>>
  <<procedures-vector-var(type="real", type_kind="real64")>>
  <<procedures-vector-var(type="logical")>>
  end module vector_m
#+end_src
*** declaration of the vector
First, We define type of the vector.
These vectors are implemented by the array that shrink and expand.
The list can add new values, delete, and search some elements.

Variables like ${variable} are expanded by bash.
- ${type} is type of elements in the list.
#+name: declaration-vector
#+begin_src fortran :exports code
  public :: vector_${suffix}
  type :: vector_${suffix}
     private
     ${type}, allocatable :: arr_(:)
     integer(int32) :: size_ = 0, capa_ = 0, lb_ = 0
   contains
     procedure, pass :: init      => init_vector_${suffix}, init_vector_range_${suffix}
     procedure, pass :: push_back => push_back_vector_${suffix}
     procedure, pass :: pop_back  => pop_back_vector_${suffix}
     procedure, pass :: size      => size_vector_${suffix}
     procedure, pass :: lbound    => lbound_vector_${suffix}
     procedure, pass :: ubound    => ubound_vector_${suffix}
     procedure, pass :: resize    => resize_vector_${suffix}, resize_range_vector_${suffix}
     procedure, pass :: at        => at_vector_${suffix}
     procedure, pass :: replace   => replace_vector_${suffix}
     ! procedure, pass :: make_iter => make_iter_vector_${suffix}
  end type vector_${suffix}

  ! public :: iterator_vector_${suffix}
  ! type :: iterator_vector_${suffix}
  !    private
  !    type(vector_${suffix}), pointer :: vec_ptr
  !    integer(int32) :: iter_
  !  contains
  !    procedure, pass :: next  => next_iterator_vector_${suffix}
  !    procedure, pass :: prev  => prev_iterator_vector_${suffix}
  !    procedure, pass :: begin => begin_iterator_vector_${suffix}
  !    procedure, pass :: end   => end_iterator_vector_${suffix}
  !    procedure, pass :: val   => val_iterator_vector_${suffix}
  ! end type vector_${suffix}
#+end_src
*** procedures of the vector
:PROPERTIES:
:header-args: :noweb-ref procedures-vector
:END:
**** init
=subroutine init= initialize vector by size.
#+name: init-vector
#+begin_src fortran :exports code :noweb no-export
  !> init_vector_${suffix}: Initialize the vector_${suffix} by size.
  subroutine init_vector_${suffix}(this, n)
    class(vector_${suffix}), intent(inout) :: this
    integer(int32), intent(in) :: n
    if (.not. allocated(this%arr_)) then
       allocate(this%arr_(n))
       this%size_ = 0
       this%capa_ = n
       this%lb_   = 1
  #ifdef DEBUG
    else
       <<error-handling-filename>>
       <<error-handling-error_message-exit(err_num=1,string="Vector is already allocated...")>>
  #endif
    end if
  end subroutine init_vector_${suffix}

  !> init_vector_range_${suffix}: Initialize the vector_${suffix} by size.
  subroutine init_vector_range_${suffix}(this, lb, ub, ierr)
    class(vector_${suffix}), intent(inout) :: this
    integer(int32), intent(in) :: lb, ub
    integer(int32), intent(out), optional :: ierr
    if (lb > ub) then
       <<error-handling-return-ierr(ierr=1)>>
       <<error-handling-filename>>
       <<error-handling-error_message-exit(err_num=2,string="init_vector_range_${suffix}: `ub` must be larger than or equal tox `lb`")>>
    end if
    call this%init(ub-lb+1)
    this%lb_ = lb
    if (present(ierr)) ierr = 0
  end subroutine init_vector_range_${suffix}
#+end_src
**** push_back
=subroutine push_back= insert value to the tail of elements of the vector.
#+name: push_back-vector
#+begin_src fortran :exports code
  !> push_back_vector_${suffix}: Insert value to the tail of elements of the vector.
  subroutine push_back_vector_${suffix}(this, val)
    class(vector_${suffix}), intent(inout) :: this
    ${type}, intent(in) :: val
    if (.not. allocated(this%arr_)) call this%init(1)
    if (this%size_ == this%capa_) then
       call this%resize(2*this%capa_)
    end if
    this%size_ = this%size_ + 1
    this%arr_(this%size_) = val
  end subroutine push_back_vector_${suffix}
#+end_src
**** pop_back
=function pop_back= deletes the value in the end of arr_(:) of the vector and returns it.
#+name: pop_back-vector
#+begin_src fortran :exports code :noweb no-export
  !> push_back_vector_${suffix}: Delete the value in the end of arr_(:) of the vector and return it.
  ${type} function pop_back_vector_${suffix}(this, ierr)
    class(vector_${suffix}), intent(inout) :: this
    integer(int32), intent(out), optional :: ierr
    if (this%size_ == 0) then
       <<error-handling-return-ierr(ierr=1)>>
       <<error-handling-filename>>
       <<error-handling-error_message-exit(err_num=3,string="There are no elements that can pop_back.">>
    end if
    pop_back_vector_${suffix} = this%arr_(this%size_)
    this%size_ = this%size_ - 1
    if (present(ierr)) ierr = 0
  end function pop_back_vector_${suffix}
#+end_src
**** size
=function size= return current size of the vector.
#+name: size-vector
#+begin_src fortran :exports code
  !> size_vector_${suffix}: Return current size of the vector.
  pure integer(int32) function size_vector_${suffix}(this)
    class(vector_${suffix}), intent(in) :: this
    size_vector_${suffix} = this%size_
  end function size_vector_${suffix}
#+end_src
**** lbound
=function size= return current lbound of the vector.
#+name: lbound-vector
#+begin_src fortran :exports code
  !> size_vector_${suffix}: Return current lbound of the vector.
  pure integer(int32) function lbound_vector_${suffix}(this)
    class(vector_${suffix}), intent(in) :: this
    lbound_vector_${suffix} = this%lb_
  end function lbound_vector_${suffix}
#+end_src
**** ubound
=function size= return current ubound of the vector.
#+name: ubound-vector
#+begin_src fortran :exports code
  !> size_vector_${suffix}: Return current ubonud of the vector.
  pure integer(int32) function ubound_vector_${suffix}(this)
    class(vector_${suffix}), intent(in) :: this
    ubound_vector_${suffix} = this%lb_ + this%size_ - 1
  end function ubound_vector_${suffix}
#+end_src
**** resize
=subroutine resize= shrinks or expands arr_(:) of the vector.
#+name: resize-vector
#+begin_src fortran :exports code :noweb no-export
  !> resize_vector_${suffix}: Shrink or expand arr_(:) of the vector.
  subroutine resize_vector_${suffix}(this, resize)
    class(vector_${suffix}), intent(inout) :: this
    integer(int32), intent(in) :: resize
    ${type}, allocatable :: tmp(:)
    if (this%capa_ == resize) return
    allocate(tmp(resize))
    this%size_ = min(this%size_, resize)
    tmp(1:this%size_) = this%arr_(1:this%size_)
    call move_alloc(from = tmp, to = this%arr_)
    this%capa_ = resize
  end subroutine resize_vector_${suffix}

  !> resize_range_vector_${suffix}: Shrink or expand arr_(:) of the vector by lb and ub.
  subroutine resize_range_vector_${suffix}(this, lb, ub, ierr)
    class(vector_${suffix}), intent(inout) :: this
    integer(int32), intent(in) :: lb, ub
    integer(int32), intent(out), optional :: ierr
    if (ub > lb) then
       <<error-handling-return-ierr(ierr=1)>>
         <<error-handling-filename>>
         <<error-handling-error_message-exit(err_num=2,string="resize_range_vector_range_${suffix}: `ub` must be larger than or equal tox `lb`")>>
    end if
    call this%resize(ub-lb+1)
    this%lb_ = lb
    if (present(ierr)) ierr = 0
  end subroutine resize_range_vector_${suffix}
#+end_src
**** at
=function at= return the element that locate at `i` of the vector.
#+name: at-vector
#+begin_src fortran :exports code :noweb no-export
  !> at_vector_${suffix}: Return the element that locate at `i` of the vector.
  ${type} function at_vector_${suffix}(this, i, ierr)
    class(vector_${suffix}), intent(in) :: this
    integer(int32), intent(in) :: i
    integer(int32), intent(out), optional :: ierr
  <<error-handling-vector-bounds-out>>
    at_vector_${suffix} = this%arr_(i - this%lb_ + 1)
    if (present(ierr)) ierr = 0
  end function at_vector_${suffix}
#+end_src
**** replace
=subroutine replace= replace the element of arr_(i).
#+name: replace-vector
#+begin_src fortran :exports code :noweb no-export
  !> replace_vector_${suffix}: Shrink or expand arr_(:) of the vector.
  subroutine replace_vector_${suffix}(this, i, val, ierr)
    class(vector_${suffix}), intent(inout) :: this
    integer(int32), intent(in) :: i
    integer(int32), intent(out), optional :: ierr
    ${type}, intent(in) :: val
  <<error-handling-vector-bounds-out>>
    this%arr_(i - this%lb_ + 1) = val
    if (present(ierr)) ierr = 0
  end subroutine replace_vector_${suffix}
#+end_src
**** error-handling
#+name: error-handling-vector-bounds-out
#+begin_src fortran :exports code :noweb no-export
  if (i < this%lbound() .or. i > this%ubound()) then
     <<error-handling-return-ierr(ierr="i - this%lbound()")>>
  #ifdef DEBUG
     <<error-handling-filename>>
     write(error_unit, '(a, *(i0, a))')&
          "Index ", i, " Out of bounds(", this%lbound(), ", ", this%ubound(), ")"
     <<error-handling-exit(err_num=1)>>
  #endif
  end if
#+end_src
*** process definition and procedures of the vector
#+name: declaration-vector-var
#+begin_src bash :exports code :var type="integer" type_kind="int32" :results output :noweb no-export :cache no :shebang #!/bin/bash
  case "${type}" in
      "character")
          type="character(len=:), allocatable"
          suffix="character"
          ;;
      "logical")
          type="logical"
          suffix="logical"
          ;;
      ,*)
          type="${type}(${type_kind})"
          suffix="${type_kind}"
          ;;
  esac
  cat <<EOF
  <<declaration-vector>>
  EOF
#+end_src
#+name: procedures-vector-var
#+begin_src bash :exports code :var type="integer" type_kind="int32" :results output :noweb no-export :cache no :shebang #!/bin/bash
  case "${type}" in
      "character")
          type="character(len=:), allocatable"
          suffix="character"
          ;;
      "logical")
          type="logical"
          suffix="logical"
          ;;
      ,*)
          type="${type}(${type_kind})"
          suffix="${type_kind}"
          ;;
  esac
  cat <<EOF
  <<procedures-vector>>
  EOF
#+end_src
*** test
#+name: vector-test
#+begin_src fortran :exports code :tangle "test/test_vector.F90" :noweb no-export
  program test_vector
    use, intrinsic :: iso_fortran_env
    use vector_m
    implicit none
    integer(int32) :: i, j
    integer(int32) :: ierr
    integer(int32), parameter :: n = 10
    type(vector_int32) :: v
    do i = 1, n
       call v%push_back(i)
    end do
    do i = 1, n
       if (v%at(i) /= i) then
          <<error-handling-filename>>
          <<error-handling-exit(err_num=20)>>
       end if
       call v%replace(i, -i)
       if (v%at(i) /= -i) then
          <<error-handling-filename>>
          <<error-handling-exit(err_num=21)>>
       end if
    end do
    j = v%at(n+1, ierr)
    if (ierr == 0) then
       write(error_unit, *) ierr
       <<error-handling-filename>>
       <<error-handling-error_message-exit(err_num=23,string="Return value of `at` is illegal.")>>
    end if
    do i = 1, n
       j = v%pop_back()
    end do
    j = v%pop_back(ierr)
    if (ierr == 0) then
       <<error-handling-filename>>
       <<error-handling-error_message-exit(err_num=24,string="Return value of `pop_back` is illegal.")>>
    end if
  end program test_vector
#+end_src
#+name: test-vector
#+begin_src fortran :exports both :results output :noweb no-export :cache yes
<<vector-module>>
<<vector-test>>
#+end_src

#+RESULTS[0e0d8c8a48affab822b4ec9effcc3a39a94686dc]: test-vector

** Hash table
*** open addressing hash by double hash
We implement open addressing hash table that use double hash by ~Fortran~.
The size of hash table is \(m\).
We cannot store the number of elements that is over \(m\).
**** The whole module of the hash table
This is the whole module.
The element of hash table is below.
#+name: hash_table-module
#+begin_src fortran :exports code :tangle "src/hash_table_m.F90" :comment link :noweb no-export
  module hash_table_m
    use, intrinsic :: iso_fortran_env
    implicit none
    private
    integer, parameter :: max_elem = 701, small_m = 700, cardinal = 128
    public :: size

    type :: variable_char
       character(len=:), allocatable :: s
    end type variable_char
    <<expand-declaration-hash_table(type="integer", type_kind="int32")>>
    <<expand-declaration-hash_table(type="integer", type_kind="int64")>>
    <<expand-declaration-hash_table(type="real", type_kind="real32")>>
    <<expand-declaration-hash_table(type="real", type_kind="real64")>>
  contains

    pure integer(int32) function hash1(key)
      character(len=*), intent(in) :: key
      integer(int32) :: h, i
      h = 0_int32
      do i = len(key), 1, -1
         h = mod(h * cardinal + ichar(key(i:i)), max_elem)
      end do
      hash1 = h
    end function hash1
    pure integer(int32) function hash2(key)
      character(len=*), intent(in) :: key
      integer(int32) :: h, i
      h = 0_int32
      do i = len(key), 1, -1
         h = mod(h * cardinal + ichar(key(i:i)), small_m)
      end do
      hash2 = h + 1
    end function hash2

    <<expand-procedures-hash_table(type="integer", type_kind="int32")>>
    <<expand-procedures-hash_table(type="integer", type_kind="int64")>>
    <<expand-procedures-hash_table(type="real", type_kind="real32")>>
    <<expand-procedures-hash_table(type="real", type_kind="real64")>>
  end module hash_table_m
#+end_src
**** The type declaration of the hash table
#+name: declaration-hash_table
#+begin_src fortran :exports code
  public :: ${hash_table}
  type :: ${hash_table}
     private
     integer(int32) :: num_elems_
     type(variable_char), allocatable :: keys_(:)
     ${type_elements}, allocatable :: elems_(:)
     logical, allocatable :: vacancy_(:)
     logical, allocatable :: deleted_(:)
   contains
     procedure, pass :: insert => insert_${hash_table}
     procedure, pass :: delete => delete_${hash_table}
     procedure, pass :: search => search_${hash_table}
     procedure, pass :: write_${hash_table}
     generic :: write(formatted) => write_${hash_table}
  end type ${hash_table}

  interface ${hash_table}
     module procedure :: init_${hash_table}
  end interface ${hash_table}
  interface size
     module procedure :: size_${hash_table}
  end interface
#+end_src
**** The procedures of the hash table
#+name: procedures-hash_table
#+begin_src fortran :exports code :noweb no-export
    <<init-hash_table>>
    <<size-hash_table>>
    <<insert-hash_table>>
    <<delete-hash_table>>
    <<search-hash_table>>
    <<write-hash_table>>
#+end_src
***** initialize
#+name: init-hash_table
#+begin_src fortran :exports code
  impure type(${hash_table}) function init_${hash_table}() result(res)
    res%num_elems_ = 0
    allocate(res%elems_(0:max_elem-1))
    allocate(res%keys_(0:max_elem-1))
    allocate(res%vacancy_(0:max_elem-1), source = .true.)
    allocate(res%deleted_(0:max_elem-1), source = .false.)
  end function init_${hash_table}
#+end_src
***** size
#+name: size-hash_table
#+begin_src fortran :exports code
  pure integer(int32) function size_${hash_table}(ht) result(res)
    type(${hash_table}), intent(in) :: ht
    res = ht%num_elems_
  end function size_${hash_table}
#+end_src
***** insert-hash_table
Insert =val= into hash table.
If =key= is already in the hash table, change to new =val= corresponding to =key=.
#+name: insert-hash_table
#+begin_src fortran :exports code :noweb no-export
  subroutine insert_${hash_table} (this, key, val, ierr)
    class(${hash_table}), intent(inout) :: this
    character(len=*), intent(in) :: key
    ${type_elements}, intent(in) :: val
    integer(int32), optional, intent(out) :: ierr
    integer(int32) :: h1, h2, pos, i
    <<error-handing-initialize-ierr-hash_table>>
    h1 = hash1(key)
    h2 = hash2(key)
    pos = h1
    do i = 1, max_elem
       if (this%vacancy_(pos)) then
          this%keys_(pos)%s = key
          this%elems_(pos) = val
          this%vacancy_(pos) = .false.
          this%num_elems_ = this%num_elems_ + 1
          return
       else if (this%keys_(pos)%s == key) then
          this%elems_(pos) = val
          return
       end if
       pos = mod(pos + h2, max_elem)
    end do
    <<error-handing-capacity-over-hash_table>>
  end subroutine insert_${hash_table}
#+end_src
#+name: error-handing-initialize-ierr-hash_table
#+begin_src fortran :exports code
    if (present(ierr)) ierr = 0
#+end_src
#+name: error-handing-capacity-over-hash_table
#+begin_src fortran :exports code
    write(error_unit, '(a)') "Size limit: Hash table is too large."
    write(error_unit, '(a, i0)') __FILE__//": ", __LINE__
    if (present(ierr)) then
       ierr = 1
    else
       error stop 1
    end if
#+end_src
***** delete-hash_table
#+name: delete-hash_table
#+begin_src fortran :exports code
  subroutine delete_${hash_table} (this, key, found)
    class(${hash_table}), intent(inout) :: this
    character(len=*), intent(in) :: key
    logical, optional, intent(out) :: found
    integer(int32) :: h1, h2, pos, i
    h1 = hash1(key)
    h2 = hash2(key)
    pos = h1
    do i = 1, max_elem
       if (this%vacancy_(pos) .and. (.not. this%deleted_(pos))) exit
       if (this%keys_(pos)%s == key) then
          this%vacancy_(pos) = .true.
          this%deleted_(pos) = .true.
          this%num_elems_ = this%num_elems_ - 1
          if (present(found)) found = .true.
          return
       end if
       pos = mod(pos + h2, max_elem)
    end do
    if (present(found)) found = .false.
  end subroutine delete_${hash_table}
#+end_src
***** search-hash_table
#+name: search-hash_table
#+begin_src fortran :exports code
  ${type_elements} function search_${hash_table} (this, key, found) result(res)
    class(${hash_table}), intent(in) :: this
    character(len=*), intent(in) :: key
    logical, optional, intent(out) :: found
    integer(int32) :: h1, h2, pos, i
    res = -1
    h1 = hash1(key)
    h2 = hash2(key)
    pos = h1
    do i = 1, max_elem
       if (this%vacancy_(pos) .and. (.not. this%deleted_(pos))) exit
       if (this%keys_(pos)%s == key) then
          res = this%elems_(pos)
          if (present(found)) found = .true.
          return
       end if
       pos = mod(pos + h2, max_elem)
    end do
    if (present(found)) found = .false.
  end function search_${hash_table}
#+end_src
***** write-hash_table
#+name: write-hash_table
#+begin_src fortran :exports code
  subroutine write_${hash_table}(this, unit, iotype, v_list, iostat, iomsg)
    class(${hash_table}), intent(in) :: this
    integer             , intent(in)    :: unit
    character(len=*)    , intent(in)    :: iotype
    integer             , intent(in)    :: v_list(:)
    integer             , intent(out)   :: iostat
    character(len=*)    , intent(inout) :: iomsg
    integer(int32) :: i
    do i = 0, max_elem-1
       if (.not. this%vacancy_(i)) then
          write(unit, fmt='(a, i0, a, g18.10)', advance = "No", iostat=iostat, iomsg=iomsg) &
               "|", i, ": ht["//this%keys_(i)%s//"] => ", this%elems_(i)
       end if
    end do
  end subroutine write_${hash_table}
#+end_src
**** process definition and procedures of hash table
#+name: expand-hash_table
#+begin_src bash :exports code :shebang #!/bin/bash
   case "${type}" in
      "character")
          type_elements="type(variable_char)"
          type_val="character(len=:), allocatable"
          hash_table="hash_table_character"
          ;;
      ,*)
          type_elements="${type}(${type_kind})"
          type_val="${type_elements}"
          hash_table="hash_table_${type_kind}"
          ;;
  esac
#+end_src
#+name: expand-declaration-hash_table
#+begin_src bash :exports code :var type="integer" type_kind="int32" :results output :noweb no-export :cache no :shebang #!/bin/bash
  <<expand-hash_table>>
  cat <<EOF
  <<declaration-hash_table>>
  EOF
#+end_src
#+name: expand-procedures-hash_table
#+begin_src bash :exports code :var type="integer" type_kind="int32" :results output :noweb no-export :cache no :shebang #!/bin/bash
  <<expand-hash_table>>
  cat <<EOF
  <<procedures-hash_table>>
  EOF
#+end_src
**** test
#+name: hash_table-test
#+begin_src fortran :exports code :tangle "test/test_hash_table.f90" :comments link
  program test_hash_table
    use, intrinsic :: iso_fortran_env
    use hash_table_m
    implicit none
    integer(int32) :: v, i, j, k, ierr
    logical :: found
    character(len=:), allocatable :: s
    type(hash_table_int32) :: ht_i32, ht_i32_2
    ht_i32 = hash_table_int32()
    !> check empty character.
    call ht_i32%insert("", 0, ierr=ierr)
    v = ht_i32%search("", found=found)
    if (.not. found) then
       write(error_unit, *) "Empty string '' not found or not inserted..."
       error stop 2
    end if
    if (v /= 0) then
       write(error_unit, *) "Value of arr[''] must be 0"
       error stop 3
    end if
    !> check size
    !> insert 701 elements
    !> first, insert 10*10*7 elements
    do i = ichar("a"), ichar("a")+10-1
       do j = ichar("A"), ichar("A")+10-1
          do k = ichar(" "), ichar(" ")+7-1
             s = achar(i)//achar(j)//achar(k)
             call ht_i32%insert(s, 128**2*i+128*j+k, ierr)
          end do
       end do
    end do
    call ht_i32%insert("abcde", 0, ierr) ! size of hash table is maximum
    if (ierr == 0) then
       write(error_unit, *) "Insert in fully hash table must fail...", size(ht_i32)
       error stop 4
    end if
    call ht_i32%delete("aB$", found) ! delete elements in hash table.
    if (.not. found) then
       write(error_unit, *) "Delete failed...", size(ht_i32)
       error stop 5
    end if
    call ht_i32%insert("abcdef", 0, ierr) ! be able to insert
    if (ierr /= 0) then
       write(error_unit, *) "Delete or insert failed..."
       error stop 6
    end if
    !> insert 700 elements
    !> delete 700 elements
    !> first, insert 10*10*7 elements
    ht_i32_2 = hash_table_int32()
    do i = ichar("a"), ichar("a")+10-1
       do j = ichar("A"), ichar("A")+10-1
          do k = ichar(" "), ichar(" ")+7-1
             s = achar(i)//achar(j)//achar(k)
             call ht_i32_2%insert(s, 0, ierr)
             call ht_i32_2%delete(s, found=found)
             if (ierr /= 0) then
                write(error_unit, *) "Insert failed...", size(ht_i32_2)
                error stop 7
             end if
             if (.not. found) then
                write(error_unit, *) "Insert and Delete failed...", size(ht_i32_2)
                error stop 8
             end if
          end do
       end do
    end do
    if (size(ht_i32_2) /= 0) then
       write(error_unit, *) "Insert and delete failed...", size(ht_i32_2)
       error stop 9
    end if
    !> insert 700 elements
    !> delete 700 elements
    !> insert 700 elements
    !> first, insert 10*10*7 elements
    ht_i32_2 = hash_table_int32()
    do i = ichar("a"), ichar("a")+10-1
       do j = ichar("A"), ichar("A")+10-1
          do k = ichar(" "), ichar(" ")+7-1
             s = achar(i)//achar(j)//achar(k)
             call ht_i32_2%insert(s, 0)
             call ht_i32_2%delete(s, found=found)
             call ht_i32_2%insert(s, 0, ierr)
             if (ierr /= 0) then
                write(error_unit, *) "Insert failed...", size(ht_i32_2)
                error stop 10
             end if
             if (.not. found) then
                write(error_unit, *) "Delete failed...", size(ht_i32_2)
                error stop 11
             end if
          end do
       end do
    end do
    if (size(ht_i32_2) /= 700) then
       write(error_unit, *) "Insert and delete and insert failed...", size(ht_i32_2)
       error stop 12
    end if
  end program test_hash_table
#+end_src
#+name: test-hash_table
#+begin_src fortran :flags -g -fbacktrace -fcheck=all :exports both :results output :noweb no-export :cache yes
<<hash_table-module>>
<<hash_table-test>>
#+end_src

#+RESULTS[7012e9003deba0e9eb25cf053fa62c3a4d23f793]: test-hash_table

** tree
*** binary_tree
We implement a binary tree that consists of the root, the pointers to its children, and some keys by ~Fortran~.
The keys of the binary tree are not duplicated.
**** The whole module of binary tree
This is the whole module of the binary tree.
The declaration [[cref:expand-declaration-binary_tree]] and procedures [[cref:expand-declaration-binary_tree]] are below.
#+name: binary-tree-module
#+begin_src fortran :exports code :tangle "src/binary_tree_m.f90" :comment link :noweb no-export
  module binary_tree_m
    use, intrinsic :: iso_fortran_env
    implicit none
    private
    public :: size
    public :: depth
    <<expand-declaration-binary-tree(type="integer", type_kind="int32")>>
    <<expand-declaration-binary-tree(type="integer", type_kind="int64")>>
  contains
    <<expand-procedures-binary-tree(type="integer", type_kind="int32")>>
    <<expand-procedures-binary-tree(type="integer", type_kind="int64")>>
  end module binary_tree_m
#+end_src
**** The type declaration of the binary tree
${type_key} is the type of key that is comparable.
${type_element} is the type of elements.
#+name: declaration-binary-tree
#+begin_src fortran :exports code
  public :: ${binary_tree}
  type :: ${binary_tree}
     private
     integer(int32) :: num_elems_
     type(${binary_tree_node}), pointer :: root_ => null()
   contains
     procedure, pass :: insert => insert_${binary_tree}
     procedure, pass :: delete => delete_${binary_tree}
     ! procedure, pass :: search => search_${binary_tree}
     procedure, pass :: minimum => minimum_${binary_tree}
     procedure, pass :: maximum => maximum_${binary_tree}
     procedure, pass :: begin => begin_${binary_tree}
     procedure, pass :: end   => end_${binary_tree}
     procedure, pass :: to_array         => to_array_${binary_tree}
     procedure, pass :: to_array_reverse => to_array_reverse_${binary_tree}
     procedure, pass :: write_${binary_tree}
     generic :: write(formatted) => write_${binary_tree}
  end type ${binary_tree}
  public :: ${binary_tree_iterator}
  type :: ${binary_tree_iterator}
     private
     type(${binary_tree_node}), pointer :: ptr_ => null()
   contains
     procedure, pass :: val => val_${binary_tree_iterator}
     procedure, pass :: next => next_${binary_tree_iterator}
     procedure, pass :: pred => pred_${binary_tree_iterator}
     procedure, pass :: is_null => is_null_${binary_tree_iterator}
     procedure, pass :: to => to_${binary_tree_iterator}
  end type ${binary_tree_iterator}
  type :: ${binary_tree_node}
     private
     ${type_element} :: elem_
     type(${binary_tree_node}), pointer :: p_     => null()
     type(${binary_tree_node}), pointer :: left_  => null()
     type(${binary_tree_node}), pointer :: right_ => null()
   contains
     procedure, pass :: minimum   => minimum_${binary_tree_node}
     procedure, pass :: maximum   => maximum_${binary_tree_node}
     procedure, pass :: successor   => successor_${binary_tree_node}
     procedure, pass :: predecessor => predecessor_${binary_tree_node}
  end type ${binary_tree_node}

  interface ${binary_tree}
     module procedure :: init_${binary_tree}, init_${binary_tree}_by_arr
  end interface ${binary_tree}
  interface ${binary_tree_node}
     module procedure :: init_${binary_tree_node}
  end interface ${binary_tree_node}
  interface size
     module procedure :: size_${binary_tree}
  end interface size
  interface depth
     module procedure :: depth_${binary_tree}
  end interface depth
#+end_src
**** The procedures of the binary tree
:PROPERTIES:
:header-args: :noweb-ref procedures-binary-tree
:END:
***** initialize the binary tree
There are two procedures for initializing.
The first procedure initializes the values to zero or null.
#+begin_src fortran :exports code
  impure type(${binary_tree}) function init_${binary_tree}() result(res)
    res%num_elems_ = 0
    res%root_ => null()
  end function init_${binary_tree}
#+end_src
The second procedure initializes the values by elements of an array.
#+begin_src fortran :exports code
  impure type(${binary_tree}) function init_${binary_tree}_by_arr(arr) result(res)
    ${type_element}, intent(in) :: arr(:)
    integer(int32) :: i, n
    res%num_elems_ = 0
    n = size(arr)
    do i = 1, n
       call res%insert(arr(i))
    end do
  end function init_${binary_tree}_by_arr
#+end_src
#+begin_src fortran :exports code
  impure function init_${binary_tree_node}(val) result(node)
    type(${binary_tree_node}), pointer :: node
    ${type_element}, intent(in) :: val
    allocate(node)
    node%elem_  = val
    node%p_     => null()
    node%left_  => null()
    node%right_ => null()
    return
  end function init_${binary_tree_node}
#+end_src
***** insert an element in the binary tree
The subroutine that inserts an element into the binary tree.
If the root of tree is null, we create the new node in the root of tree.
#+begin_src fortran :exports code
  subroutine insert_${binary_tree}(tree, val)
    class(${binary_tree}), intent(inout) :: tree
    ${type_element}, intent(in) :: val
    type(${binary_tree_node}), pointer :: node, new_node, parent
    new_node => ${binary_tree_node}(val)
    parent => null()
    node => tree%root_
    if (.not. associated(node)) then
       tree%root_  => new_node
       new_node%p_ => null()
       tree%num_elems_ = 1
       return
    end if
    do
       if (val == node%elem_) then
          return
       else if (val < node%elem_) then
          parent => node
          node   => node%left_
          if (.not. associated(node)) then
             parent%left_ => new_node
             new_node%p_  => parent
             tree%num_elems_ = tree%num_elems_ + 1
             return
          end if
       else
          parent => node
          node   => node%right_
          if (.not. associated(node)) then
             parent%right_ => new_node
             new_node%p_   => parent
             tree%num_elems_ = tree%num_elems_ + 1
             return
          end if
       end if
    end do
  end subroutine insert_${binary_tree}
#+end_src
***** delete an element in the binary tree
#+begin_src fortran :exports code
  subroutine delete_${binary_tree}(tree, val)
    class(${binary_tree}), intent(inout) :: tree
    ${type_element}, intent(in) :: val
    type(${binary_tree_node}), pointer :: child, left, right
    if (.not. associated(tree%root_)) then
       return
    end if
    child => tree%root_
    do
       !> undefined...
    end do
  end subroutine delete_${binary_tree}
#+end_src
***** the minimum value in the binary tree
#+begin_src fortran :exports code
  ${type_element} function minimum_${binary_tree}(tree) result(mini)
    class(${binary_tree}), intent(in) :: tree
    type(${binary_tree_node}), pointer :: node, min_node
    if (.not. associated(tree%root_)) then
       write(error_unit, *) "Manipulation to empty tree is not allowed."
       return
    end if
    node => tree%root_
    min_node => node%minimum()
    mini = min_node%elem_
  end function minimum_${binary_tree}
#+end_src
***** the maximum value in the binary tree
#+begin_src fortran :exports code
  ${type_element} function maximum_${binary_tree}(tree) result(maxi)
    class(${binary_tree}), intent(in) :: tree
    type(${binary_tree_node}), pointer :: node, max_node
    if (.not. associated(tree%root_)) then
       write(error_unit, *) "Manipulation to empty tree is not allowed."
       return
    end if
    node => tree%root_
    max_node => node%maximum()
    maxi = max_node%elem_
  end function maximum_${binary_tree}
#+end_src
***** the begin node in the binary tree
#+begin_src fortran :exports code
  function begin_${binary_tree}(tree) result(begin)
    class(${binary_tree}), intent(in) :: tree
    type(${binary_tree_node}), pointer :: begin
    if (.not. associated(tree%root_)) then
       write(error_unit, *) "Manipulation to empty tree is not allowed."
       return
    end if
    begin => tree%root_%minimum()
  end function begin_${binary_tree}
#+end_src
***** the end node in the binary tree
#+begin_src fortran :exports code
  function end_${binary_tree}(tree) result(end)
    class(${binary_tree}), intent(in) :: tree
    type(${binary_tree_node}), pointer :: end
    if (.not. associated(tree%root_)) then
       write(error_unit, *) "Manipulation to empty tree is not allowed."
       return
    end if
    end => tree%root_%maximum()
  end function end_${binary_tree}
#+end_src
***** Convert the tree to sorted array
#+begin_src fortran :exports code
  subroutine to_array_${binary_tree}(tree, arr)
    class(${binary_tree}), intent(in) :: tree
    ${type_element}, intent(out) :: arr(:)
    type(${binary_tree_iterator}) :: iter
    type(${binary_tree_node}), pointer :: beg_ptr
    integer(int32) :: i
    beg_ptr => tree%begin()
    call iter%to(beg_ptr)
    do i = 1, size(tree)
       if (iter%is_null()) exit
       arr(i) = iter%val()
       call iter%next()
    end do
  end subroutine to_array_${binary_tree}
  subroutine to_array_reverse_${binary_tree}(tree, arr)
    class(${binary_tree}), intent(in) :: tree
    ${type_element}, intent(out) :: arr(:)
    type(${binary_tree_iterator}) :: iter
    type(${binary_tree_node}), pointer :: end_ptr
    integer(int32) :: i
    end_ptr => tree%end()
    call iter%to(end_ptr)
    do i = 1, size(tree)
       if (iter%is_null()) exit
       arr(i) = iter%val()
       call iter%pred()
    end do
  end subroutine to_array_reverse_${binary_tree}
#+end_src
***** COMMENT search an element in the binary tree
The search is not necessarily...?
#+begin_src fortran :exports code
  logical function search_${binary_tree}(tree, val) result(found)
    class(${binary_tree}), intent(in) :: tree
    ${type_element}, intent(in) :: val
    !> undefined...
  end function search_${binary_tree}
#+end_src
***** node
****** minimum
The function minimum returns a pointer to the minimum node under the tree node.
#+begin_src fortran :exports code
  function minimum_${binary_tree_node}(this) result(min_node)
    class(${binary_tree_node}), target, intent(in) :: this
    type(${binary_tree_node}) , pointer :: min_node
    min_node => this
    do
       if (.not. associated(min_node%left_)) return
       min_node => min_node%left_
    end do
  end function minimum_${binary_tree_node}
#+end_src
****** maximum
The function maximum returns a pointer to the maximum node under the tree node.
#+begin_src fortran :exports code
  function maximum_${binary_tree_node}(this) result(max_node)
    class(${binary_tree_node}), target, intent(in) :: this
    type(${binary_tree_node}) , pointer :: max_node
    max_node => this
    do
       if (.not. associated(max_node%right_)) return
       max_node => max_node%right_
    end do
  end function maximum_${binary_tree_node}
#+end_src
****** successor
The function successor returns a pointer to the node whose next larger value.
#+begin_src fortran :exports code
  function successor_${binary_tree_node}(this) result(succ)
    class(${binary_tree_node}), target, intent(in) :: this
    type(${binary_tree_node}) , pointer :: succ
    succ => this
    if (associated(succ%right_)) then ! succ has right.
       succ => succ%right_%minimum()
       return
    end if
    do
       if (.not. associated(succ%p_)) then
          succ => null()
          return
       else if (associated(succ, succ%p_%left_)) then
          succ => succ%p_
          return
       end if
       succ => succ%p_
    end do
  end function successor_${binary_tree_node}
#+end_src
****** predecessor
The function successor returns a pointer to the node whose next larger value.
#+begin_src fortran :exports code
  function predecessor_${binary_tree_node}(this) result(pred_node)
    class(${binary_tree_node}), target, intent(in) :: this
    type(${binary_tree_node}) , pointer :: node, pred_node
    node => this
    if (associated(node%left_)) then ! node has left.
       pred_node => node%left_%maximum()
       return
    end if
    do
       if (.not. associated(node%p_)) then
          pred_node => null()
          return
       else if (associated(node, node%p_%right_)) then
          pred_node => node%p_
          return
       end if
       node => node%p_
    end do
  end function predecessor_${binary_tree_node}
#+end_src
***** iterator
****** point to node
#+begin_src fortran :exports code
  subroutine to_${binary_tree_iterator}(iter, node_ptr)
    class(${binary_tree_iterator}), intent(out) :: iter
    type(${binary_tree_node}), pointer, intent(in) :: node_ptr
    iter%ptr_ => node_ptr
  end subroutine to_${binary_tree_iterator}
#+end_src
****** val
#+begin_src fortran :exports code
  ${type_element} function val_${binary_tree_iterator}(iter) result(res)
    class(${binary_tree_iterator}), intent(in) :: iter
    res = iter%ptr_%elem_
  end function val_${binary_tree_iterator}
#+end_src
****** next
#+begin_src fortran :exports code
  subroutine next_${binary_tree_iterator}(iter)
    class(${binary_tree_iterator}), intent(inout) :: iter
    if (associated(iter%ptr_)) iter%ptr_ => iter%ptr_%successor()
  end subroutine next_${binary_tree_iterator}
#+end_src
****** pred
#+begin_src fortran :exports code
  subroutine pred_${binary_tree_iterator}(iter)
    class(${binary_tree_iterator}), intent(inout) :: iter
    iter%ptr_ => iter%ptr_%predecessor()
  end subroutine pred_${binary_tree_iterator}
#+end_src
****** is_null
#+begin_src fortran :exports code
  logical function is_null_${binary_tree_iterator}(iter) result(is_null)
    class(${binary_tree_iterator}), intent(in) :: iter
    is_null = .not. associated(iter%ptr_)
  end function is_null_${binary_tree_iterator}
#+end_src
***** size
#+begin_src fortran :exports code
  pure integer(int32) function size_${binary_tree}(tree) result(res)
    type(${binary_tree}), intent(in) :: tree
    res = tree%num_elems_
  end function size_${binary_tree}
#+end_src
***** depth
#+begin_src fortran :exports code
  integer(int32) function depth_${binary_tree}(tree) result(res)
    type(${binary_tree}), intent(in) :: tree
    type(${binary_tree_node}), pointer :: child
    child => tree%root_
    if (.not. associated(child)) then
       res = 0
    end if
    res = depth_${binary_tree_node}(child)
  end function depth_${binary_tree}
  pure recursive integer(int32) function depth_${binary_tree_node}(node) result(res)
    type(${binary_tree_node}), intent(in) :: node
    logical :: exist_left, exist_right
    exist_left  = associated(node%left_)
    exist_right = associated(node%right_)
    if (exist_left .and. exist_right) then
       res = 1 + max(depth_${binary_tree_node}(node%left_)&
            , depth_${binary_tree_node}(node%right_))
    else if (exist_left) then
       res = 1 + depth_${binary_tree_node}(node%left_)
    else if (exist_right) then
       res = 1 + depth_${binary_tree_node}(node%right_)
    else
       res = 1
    end if
  end function depth_${binary_tree_node}
#+end_src
***** write the whole elements in the binary tree
#+begin_src fortran :exports code
  subroutine write_${binary_tree}(this, unit, iotype, v_list, iostat, iomsg)
    class(${binary_tree}), intent(in) :: this
    type(${binary_tree_iterator}) :: iter
    integer              , intent(in)    :: unit
    character(len=*)     , intent(in)    :: iotype
    integer              , intent(in)    :: v_list(:)
    integer              , intent(out)   :: iostat
    character(len=*)     , intent(inout) :: iomsg
    if (.not. associated(this%root_)) return
    write(unit, *, iostat=iostat, iomsg=iomsg) "| "
    call print_nodes_${binary_tree}(this%root_, unit=unit, iostat=iostat, iomsg=iomsg)
    write(unit, *, iostat=iostat, iomsg=iomsg) "| "
  end subroutine write_${binary_tree}

  recursive subroutine print_nodes_${binary_tree}(node, unit, iostat, iomsg)
    type(${binary_tree_node}), intent(in) :: node
    integer         , intent(in)    :: unit
    integer         , intent(out)   :: iostat
    character(len=*), intent(inout) :: iomsg
    if (associated(node%left_)) call print_nodes_${binary_tree}(node%left_, unit=unit, iostat=iostat, iomsg=iomsg)
    write(unit, *, iostat=iostat, iomsg=iomsg) node%elem_
    if (associated(node%right_)) call print_nodes_${binary_tree}(node%right_, unit=unit, iostat=iostat, iomsg=iomsg)
  end subroutine print_nodes_${binary_tree}
#+end_src
**** expand
#+name: expand-binary-tree
#+begin_src bash :exports code :shebang #!/bin/bash
  type_element="${type}(${type_kind})"
  binary_tree="binary_tree_${type_kind}"
  binary_tree_node="binary_tree_node_${type_kind}"
  binary_tree_iterator="binary_tree_iterator_${type_kind}"
#+end_src
#+name: expand-declaration-binary-tree
#+begin_src bash :exports code :var type="integer" type_kind="int32" :results output :noweb no-export :cache no :shebang #!/bin/bash
  <<expand-binary-tree>>
  cat <<EOF
  <<declaration-binary-tree>>
  EOF
#+end_src
#+name: expand-procedures-binary-tree
#+begin_src bash :exports code :var type="integer" type_kind="int32" :results output :noweb no-export :cache no :shebang #!/bin/bash
  <<expand-binary-tree>>
  cat <<EOF
  <<procedures-binary-tree>>
  EOF
#+end_src
**** test
#+name: binary-tree-test
#+begin_src fortran :exports code :tangle "test/test_binary_tree.f90" :comments link
  program test_binary_tree
    use, intrinsic :: iso_fortran_env
    use is_sorted_m
    use binary_tree_m
    implicit none
    integer(int32) :: i
    type(binary_tree_int32) :: bt_int32, bt2, bt_only_l, bt_only_r
    type(binary_tree_iterator_int32) :: bt_iter
    bt_int32 = binary_tree_int32()
    bt2 = binary_tree_int32([10, 5, 6, 7, 8, 9, 15, 3, 18, 2, 4, 19, 17, 1, 0, -1, -2, 11, 16, 14, 12, 13])
    bt_only_l = binary_tree_int32([(i, i = 10, 1, -1)])
    bt_only_r = binary_tree_int32([(i, i = 1, 10)])
    call bt_int32%insert(10)
    call bt_int32%insert(-11)
    call bt_int32%insert(1)
    call bt_int32%insert(20)
    call bt_int32%insert(17)
    if (size(bt_int32) /= 5) then
       write(error_unit, *) "size error: ", size(bt_int32)
       error stop 1
    end if
    block
      integer(int32) :: sorted_arr(size(bt_only_l)), sorted_arr2(size(bt_only_l))
      call bt_iter%to(bt_only_l%begin())
      do i = 1, size(bt_only_l)
         if (bt_iter%is_null()) exit
         sorted_arr(i) = bt_iter%val()
         call bt_iter%next()
      end do
      if (.not. is_sorted(sorted_arr)) then
         write(error_unit, *) sorted_arr(:)
         error stop 2
      end if
      call bt_only_l%to_array(sorted_arr2)
      if (any(sorted_arr2 /= sorted_arr)) then
         write(error_unit, *) sorted_arr
         write(error_unit, *) sorted_arr2
         error stop 3
      end if
    end block
    block
      integer(int32) :: sorted_arr(size(bt_only_l)), sorted_arr2(size(bt_only_l))
      call bt_iter%to(bt_only_l%end())
      do i = 1, size(bt_only_l)
         if (bt_iter%is_null()) exit
         sorted_arr(i) = bt_iter%val()
         call bt_iter%pred()
      end do
      if (.not. is_sorted_descending(sorted_arr)) then
         write(error_unit, *) sorted_arr(:)
         error stop 4
      end if
      call bt_only_l%to_array_reverse(sorted_arr2)
      if (any(sorted_arr2 /= sorted_arr)) then
         write(error_unit, *) sorted_arr
         write(error_unit, *) sorted_arr2
         error stop 5
      end if
    end block
    block
      integer(int32) :: sorted_arr(size(bt_only_r)), sorted_arr2(size(bt_only_r))
      call bt_iter%to(bt_only_r%end())
      do i = 1, size(bt_only_r)
         if (bt_iter%is_null()) exit
         sorted_arr(i) = bt_iter%val()
         call bt_iter%pred()
      end do
      if (.not. is_sorted_descending(sorted_arr)) then
         write(error_unit, *) sorted_arr(:)
         error stop 6
      end if
      call bt_only_r%to_array_reverse(sorted_arr2)
      if (any(sorted_arr2 /= sorted_arr)) then
         write(error_unit, *) sorted_arr
         write(error_unit, *) sorted_arr2
         error stop 7
      end if
    end block
    block
      integer(int32) :: sorted_arr(size(bt2)), sorted_arr2(size(bt2))
      call bt_iter%to(bt2%begin())
      do i = 1, size(bt2)
         if (bt_iter%is_null()) exit
         sorted_arr(i) = bt_iter%val()
         call bt_iter%next()
      end do
      if (.not. is_sorted(sorted_arr)) then
         write(error_unit, *) sorted_arr(:)
         error stop 8
      end if
      call bt2%to_array(sorted_arr2)
      if (any(sorted_arr2 /= sorted_arr)) then
         write(error_unit, *) sorted_arr
         write(error_unit, *) sorted_arr2
         error stop 9
      end if
    end block
  end program
#+end_src
#+name: test-binary-tree
#+begin_src fortran :flags -g -fbacktrace -fcheck=all :exports both :results output :noweb no-export :cache yes
<<is-sorted-module>>
<<binary-tree-module>>
<<binary-tree-test>>
#+end_src

#+RESULTS[64e568d1e9d4160a294eced8983afb6ee0a5d3d8]: test-binary-tree

*** integer tree
#+begin_src fortran :exports code :results output :cache yes
  module tree_int_m
    use, intrinsic :: iso_fortran_env
    implicit none
    private
    public :: tree_parent_int

    type :: tree_parent_int
       private
       type(tree_int), pointer :: parent
    end type tree_parent_int

    type :: tree_int
       private
       integer(int32)          :: val
       type(tree_int), pointer :: left, right
     contains
       procedure :: add => add_tree_int
    end type tree_int

    interface tree_int
       module procedure :: init_tree_int
    end interface tree_int

  contains

    subroutine add_tree_int(this, v)
      class(tree_int), intent(inout) :: this
      integer        , intent(in)    :: v

    end subroutine add_tree_int

  end module tree_int_m
#+end_src
