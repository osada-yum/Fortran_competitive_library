** B-Tree
*** B木モジュールの全体
Rustに倣ってB木を実装する.
\(t = 6\) でノード内の内部ノードの数は \(2t-1 = 11\) とする.
=iter_max_depth= は30程度あればよい(というか過剰).
#+name: btree-module
#+begin_src fortran :exports code :tangle "btree_m.F90" :comment link :noweb no-export
  module btree_m
    use, intrinsic :: iso_fortran_env
    implicit none
    private
    !> `t-1` must be the least number of elements in `btree_node` without root (minimum degree).
    integer(int32), parameter :: t = 6
    !> the number of internal node in `btree_node`.
    integer(int32), parameter :: inode = 2*t-1
    integer(int32), parameter :: iter_max_depth = 30
    <<declaration-btree-var(key_base="integer", key_kind="int32", val_base="integer", val_kind="int32")>>
    <<declaration-btree-var(key_base="integer", key_kind="int64", val_base="integer", val_kind="int64")>>
    <<declaration-btree-var(key_base="character", key_kind="100", val_base="integer", val_kind="int32")>>
    <<declaration-btree-var(key_base="character", key_kind="100", val_base="integer", val_kind="int64")>>
  contains
    <<procedures-btree-var(key_base="integer", key_kind="int32", val_base="integer", val_kind="int32")>>
    <<procedures-btree-var(key_base="integer", key_kind="int64", val_base="integer", val_kind="int64")>>
    <<procedures-btree-var(key_base="character", key_kind="100", val_base="integer", val_kind="int32")>>
    <<procedures-btree-var(key_base="character", key_kind="100", val_base="integer", val_kind="int64")>>
  end module btree_m
#+end_src
*** B木の型宣言
#+name: declaration-btree
#+begin_src fortran :exports code
  !> pointer to ${btree_node}.
  type :: ${btree_node_ptr}
     type(${btree_node}), pointer :: p_ => null()
   contains
     procedure, pass :: size => size_${btree_node_ptr}
     procedure, pass :: is_leaf => is_leaf_${btree_node_ptr}
     procedure, pass :: get_iter => get_iter_${btree_node_ptr}
     procedure, pass :: split_child => split_child_${btree_node_ptr}
     procedure, pass :: insert => insert_${btree_node_ptr}
     procedure, pass :: remove     => remove_${btree_node_ptr}
     procedure, pass :: remove_key => remove_key_${btree_node_ptr}
     procedure, pass :: merge_children => merge_children_${btree_node_ptr}
     procedure, pass :: rotate_left  => rotate_left_${btree_node_ptr}
     procedure, pass :: rotate_right => rotate_right_${btree_node_ptr}
     procedure, pass :: shrink_left  => shrink_left_${btree_node_ptr}
     procedure, pass :: expand_right => expand_right_${btree_node_ptr}
     procedure, pass :: print => print_${btree_node_ptr}
     procedure, pass :: check_invariant => check_invariant_${btree_node_ptr}
  end type ${btree_node_ptr}
  !> node of B-Tree.
  type :: ${btree_node}
     integer(int32) :: nelem_ = 0
     ${key} :: key_(inode)
     ${val} :: val_(inode)
     type(${btree_node_ptr}) :: children_(inode+1)
     logical :: is_leaf_ = .true.
  end type ${btree_node}

  public :: ${btree}
  !> `${btree}` has pointer to root of B-Tree.
  type :: ${btree}
     private
     type(${btree_node_ptr}) :: root_
     integer(int32) :: size_   = 0
     integer(int32) :: height_ = 0
   contains
     procedure, pass :: size   => size_${btree}
     procedure, pass :: height => height_${btree}
     procedure, pass :: init   => init_${btree}
     procedure, pass :: get      => get_${btree}
     procedure, pass :: get_iter => get_iter_${btree}
     procedure, pass :: contains => contains_${btree}
     procedure, pass :: insert => insert_${btree}
     procedure, pass :: remove => remove_${btree}
     procedure, pass :: minimum => minimum_${btree}
     procedure, pass :: maximum => maximum_${btree}
     procedure, pass :: minimum_iter => minimum_iter_${btree}
     procedure, pass :: maximum_iter => maximum_iter_${btree}
     ! procedure, pass :: lower_bound => lower_bound_${btree}
     ! procedure, pass :: upper_bound => upper_bound_${btree}
     procedure, pass :: print => print_${btree}
     procedure, pass :: check_invariant => check_invariant_${btree}
  end type ${btree}
  public ${btree_node_iter}
  type :: ${btree_node_iter}
     private
     integer(int32) :: idx_ = -1 !> [1:iter%nptr_%size()], ノード内の節点を指す.
     type(${btree_node_ptr}) :: nptr_
     integer(int32) :: depth_ = 1
     integer(int32) :: indices_(iter_max_depth) !> [1:iter%nptr_%size()+1], 下ったポインタのインデックス.
     type(${btree_node_ptr}) :: parents_(iter_max_depth)
   contains
     procedure, pass :: key => key_${btree_node_iter}
     procedure, pass :: val => val_${btree_node_iter}
     procedure, pass :: mut_val => mut_val_${btree_node_iter}
     procedure, pass :: next => next_${btree_node_iter}
     procedure, pass :: prev => prev_${btree_node_iter}
     procedure, pass :: is_begin     => is_begin_${btree_node_iter}
     procedure, pass :: is_not_begin => is_not_begin_${btree_node_iter}
     procedure, pass :: is_end     => is_end_${btree_node_iter}
     procedure, pass :: is_not_end => is_not_end_${btree_node_iter}
     procedure, pass :: exist     => exist_${btree_node_iter}
     procedure, pass :: not_exist => not_exist_${btree_node_iter}
  end type ${btree_node_iter}
#+end_src
*** B木 の実装
:PROPERTIES:
:header-args: :noweb-ref procedures-btree
:END:
**** btree のメソッド
***** initialize
B木を初期化する.
#+name: initialize_btree
#+begin_src fortran :exports code
  subroutine init_${btree}(this)
    class(${btree}), intent(inout) :: this
    type(${btree_node}), pointer :: x
    allocate(x)
    x%is_leaf_ = .true.
    x%nelem_ = 0
    this%size_   = 0
    this%height_ = 0
    this%root_%p_ => x
  end subroutine init_${btree}
#+end_src
***** size
B木に含まれている要素数を返す.
#+name: size_btree
#+begin_src fortran :exports code
  pure integer(int32) function size_${btree}(this) result(res)
    class(${btree}), intent(in) :: this
    res = this%size_
  end function size_${btree}
#+end_src
***** height
B木の高さを返す.
#+name: height_btree
#+begin_src fortran :exports code
  pure integer(int32) function height_${btree}(this) result(res)
    class(${btree}), intent(in) :: this
    res = this%height_
  end function height_${btree}
#+end_src
***** get
`key` の位置の値を返す.
#+name: get_btree
#+begin_src fortran :exports code
  ${val} function get_${btree}(this, key) result(res)
    class(${btree}), intent(in) :: this
    ${key}, intent(in) :: key
    type(${btree_node_iter}) :: iter
    iter = this%root_%get_iter(key)
    if (iter%idx_ /= -1) then
       res = iter%nptr_%p_%val_(iter%idx_)
    else
    end if
  end function get_${btree}
#+end_src
***** get_iter
`key` を指す iterator を返す.
#+name: get_iter_btree
#+begin_src fortran :exports code
  type(${btree_node_iter}) function get_iter_${btree}(this, key) result(res)
    class(${btree}), intent(in) :: this
    ${key}, intent(in) :: key
    res = this%root_%get_iter(key)
  end function get_iter_${btree}
#+end_src
***** contains
`key` がB木の中に含まれているかを返す.
#+name: contains_btree
#+begin_src fortran :exports code
  logical function contains_${btree}(this, key) result(res)
    class(${btree}), intent(in) :: this
    ${key}, intent(in) :: key
    type(${btree_node_iter}) :: iter
    iter = this%root_%get_iter(key)
    res = iter%idx_ /= -1
  end function contains_${btree}
#+end_src
***** insert
`key` の位置に `val` を挿入する.
実装は `btree_node_ptr` 任せる.
#+name: insert_btree
#+begin_src fortran :exports code
  subroutine insert_${btree}(this, key, val)
    class(${btree}), intent(inout) :: this
    ${key}, intent(in) :: key
    ${val}, intent(in) :: val
    type(${btree_node_ptr}) :: r
    type(${btree_node_iter}) :: iter
    r%p_ => this%root_%p_
    if (r%p_%nelem_ == 2*t - 1) then
       block
         type(${btree_node_ptr}) :: s
         allocate(s%p_)
         this%root_%p_ => s%p_
         s%p_%is_leaf_ = .false.
         s%p_%nelem_ = 0
         s%p_%children_(1)%p_ => r%p_
         call s%split_child(1)
         this%height_ = this%height_ + 1
         iter = s%insert(key, val)
       end block
    else
       iter = r%insert(key, val)
    end if
    if (iter%idx_ > 0) &
         this%size_ = this%size_ + 1
  end subroutine insert_${btree}
#+end_src
***** remove
`key` をB木から削除する.
実装は `btree_node_ptr` に任せる.
#+name: remove_btree
#+begin_src fortran :exports code
  subroutine remove_${btree}(this, key)
    class(${btree}), intent(inout) :: this
    ${key}, intent(in) :: key
    type(${btree_node_ptr}) :: tmp
    call this%root_%remove(key)
    if (this%root_%p_%nelem_ == 0 .and. (.not. this%root_%is_leaf())) then
       tmp%p_ => this%root_%p_
       this%root_%p_ => this%root_%p_%children_(1)%p_
       deallocate(tmp%p_)
       nullify(tmp%p_)
       this%height_ = this%height_ - 1
    end if
    this%size_ = this%size_ - 1
  end subroutine remove_${btree}
#+end_src
***** minimum
#+name: minimum_btree
#+begin_src fortran :exports code
  !> minimum_${btree}: Return the minimum value.
  ${key} function minimum_${btree}(this) result(res)
    class(${btree}), intent(in) :: this
    type(${btree_node_iter}) :: iter
    iter = this%minimum_iter()
    res = iter%key()
  end function minimum_${btree}
#+end_src
***** minimum_iter
最小値の場所を指す ${btree_node_iter} を返す.
#+name: minimum_iter_${btree}
#+begin_src fortran :exports code
  !> minimum_iter_${btree}: Return the iterator to node that has minimum key.
  type(${btree_node_iter}) function minimum_iter_${btree}(this) result(res)
    class(${btree}), intent(in) :: this
    res%nptr_%p_ => this%root_%p_
    res%depth_ = 1
    res%idx_ = 0
    call res%next()
  end function minimum_iter_${btree}
#+end_src
***** maximum
#+name: maximum_btree
#+begin_src fortran :exports code
  !> maximum_${btree}: Return the maximum value.
  ${key} function maximum_${btree}(this) result(res)
    class(${btree}), intent(in) :: this
    type(${btree_node_iter}) :: iter
    iter = this%maximum_iter()
    res = iter%key()
  end function maximum_${btree}
#+end_src
***** maximum_iter
#+name: maximum_iter_btree
#+begin_src fortran :exports code
  !> maximum_iter_${btree}: Return the iterator to node that has maximum key.
  type(${btree_node_iter}) function maximum_iter_${btree}(this) result(res)
    class(${btree}), intent(in) :: this
    res%nptr_%p_ => this%root_%p_
    res%depth_ = 1
    res%idx_ = res%nptr_%size() + 1
    call res%prev()
  end function maximum_iter_${btree}
#+end_src
***** COMMENT lower_bound => lower_bound_${btree}
#+name: lower_bound_btree
#+begin_src fortran :exports code
#+end_src
***** COMMENT upper_bound => upper_bound_${btree}
#+name: upper_bound_btree
#+begin_src fortran :exports code
#+end_src
***** print
デバッグ用. 全ての要素をprintする.
#+name: print_btree
#+begin_src fortran :exports code
  !> print_btree: Print whole node in B-tree for debug.
  !> For debug.
  subroutine print_${btree}(this, unit)
    class(${btree}), intent(in) :: this
    integer(int32), intent(in) :: unit
    if (associated(this%root_%p_)) &
         call this%root_%print(unit, 0)
  end subroutine print_${btree}
#+end_src
***** check_invariant
デバッグ用.
B木の不変条件:
- `root` を除く `node` は最小でも `t-1` 個の `key` を持つ.
- 左側の `key` は右側の `key` よりも小さい.
を確かめる.
#+name: check_invariant_btree
#+begin_src fortran :exports code
  !> check_invariant_${btree}: Check invariant for debug.
  !> invariant condition: The number of keys of each node in B-tree excluded root node must have at least `t - 1` keys.
  !> The keys in left children is less than key of current node.
  !> The keys in right children is greater than key of current node.
  subroutine check_invariant_${btree}(this)
    class(${btree}), intent(in) :: this
    type(${btree_node_iter}) :: bt_iter
    ${key} :: k, k_bef
    integer(int32) :: i
    if (this%size() == 0) return
    bt_iter = this%minimum_iter()
    k_bef = bt_iter%key()
    call bt_iter%next()
    do while (bt_iter%is_not_end())
       k = bt_iter%key()
       ! write(error_unit, *) k_bef, k
       if (k_bef >= k) then
          write(error_unit, '(a)') "Error: B-tree is not ordered."
          write(error_unit, '(a)') "Something wrong occurred in 'minimum_iter' or 'next'."
          error stop 5
       end if
       k_bef = k
       call bt_iter%next()
    end do
    bt_iter = this%maximum_iter()
    k_bef = bt_iter%key()
    call bt_iter%prev()
    do while (bt_iter%is_not_begin())
       k = bt_iter%key()
       ! write(error_unit, *) k_bef, k
       if (k_bef <= k) then
          write(error_unit, '(a)') "Error: B-tree is not ordered."
          write(error_unit, '(a)') "Something wrong occurred in 'maximum_iter' or 'prev'."
          error stop 6
       end if
       k_bef = k
       call bt_iter%prev()
    end do
    if (this%root_%is_leaf()) return
    do i = 1, this%root_%size() + 1
       call this%root_%p_%children_(i)%check_invariant()
    end do
  end subroutine check_invariant_${btree}
#+end_src
**** btreee_node_ptr のメソッド
***** size
B木のノードに含まれている要素数を返す.
#+name: size_btree_node_ptr
#+begin_src fortran :exports code
  pure integer(int32) function size_${btree_node_ptr}(this) result(res)
    class(${btree_node_ptr}), intent(in) :: this
    res = this%p_%nelem_
  end function size_${btree_node_ptr}
#+end_src
***** is_leaf
ノードが葉か否かを返す.
#+name: is_leaf_btree_node_ptr
#+begin_src fortran :exports code
  pure logical function is_leaf_${btree_node_ptr}(this) result(res)
    class(${btree_node_ptr}), intent(in) :: this
    res = this%p_%is_leaf_
  end function is_leaf_${btree_node_ptr}
#+end_src
***** get_iter
`key` の位置を指す iterator を返す.
#+name: get_iter_btree_node_ptr
#+begin_src fortran :exports code :noweb no-export
  type(${btree_node_iter}) function get_iter_${btree_node_ptr}(this, key) result(res)
    class(${btree_node_ptr}), intent(in) :: this
    ${key}, intent(in) :: key
    integer(int32) :: pos
    res%nptr_%p_ => this%p_
    if (res%nptr_%size() == 0) then
       res%idx_ = -1
       return
    end if
    res%depth_ = 1
    do !> search `i+1`, which satisfied arr(pos) < key <= arr(pos+1), arr(0) == -infinity, arr(n+1) == +infinity
       pos = lower_bound(1, res%nptr_%size(), res%nptr_%p_%key_(1:res%nptr_%size()), key)
       ! write(error_unit, '(3(a, i0, 1x), *(i0, 1x))') "pos: ", pos, "key: ", key, "arr: ", res%nptr_%p_%key_(1:res%nptr_%size())
       !> key <= key_(pos)
       if (pos <= res%nptr_%size()) then
          if (res%nptr_%p_%key_(pos) == key) then !> key found.
             res%idx_ = pos
             return
          end if
       end if
       if (res%nptr_%is_leaf()) exit
       res%indices_(res%depth_) = pos
       res%parents_(res%depth_)%p_ => res%nptr_%p_
       res%nptr_%p_ => res%nptr_%p_%children_(pos)%p_
       res%depth_ = res%depth_ + 1
    end do
    !> not found.
    nullify(res%nptr_%p_)
    res%idx_ = -1
    return
  contains
    <<btree_sub_lower_bound>>
  end function get_iter_${btree_node_ptr}
#+end_src
***** split_child
`insert` するときに, 不変条件を保つために用いる.
要素数が上限に達した子ノードを分割する.
#+name: split_child_btree_node_ptr
#+begin_src fortran :exports code
  subroutine split_child_${btree_node_ptr}(this, idx)
    class(${btree_node_ptr}), intent(in) :: this
    integer(int32), intent(in) :: idx
    type(${btree_node_ptr}) :: y, z
    integer(int32) :: i
    allocate(z%p_)
    y%p_ => this%p_%children_(idx)%p_
    z%p_%is_leaf_ = y%p_%is_leaf_
    z%p_%nelem_ = t - 1
    do i = 1, t - 1
       z%p_%key_(i) = y%p_%key_(i+t)
       z%p_%val_(i) = y%p_%val_(i+t)
    end do
    if (.not. y%is_leaf()) then
       do i = 1, t
          z%p_%children_(i)%p_ => y%p_%children_(i+t)%p_
       end do
    end if
    y%p_%nelem_ = t - 1
    do i = this%size()+1, idx+1, -1
       this%p_%children_(i+1)%p_ => this%p_%children_(i)%p_
    end do
    this%p_%children_(idx+1)%p_ => z%p_
    do i = this%p_%nelem_, idx, -1
       this%p_%key_(i+1) = this%p_%key_(i)
       this%p_%val_(i+1) = this%p_%val_(i)
    end do
    this%p_%key_(idx) = y%p_%key_(t)
    this%p_%val_(idx) = y%p_%val_(t)
    this%p_%nelem_ = this%p_%nelem_ + 1
  end subroutine split_child_${btree_node_ptr}
#+end_src
***** insert
#+name: insert_btree_node_ptr
#+begin_src fortran :exports code :noweb no-export
  !> insert_${btree_node_ptr}: Insert (`key`, `val`) into B-tree.
  type(${btree_node_iter}) function insert_${btree_node_ptr}(this, key, val) result(res)
    class(${btree_node_ptr}), intent(in) :: this
    ${key}, intent(in) :: key
    ${val}, intent(in) :: val
    type(${btree_node_ptr}) :: x
    integer(int32) :: pos
    x%p_ => this%p_
    if (x%size() == 0) then
       x%p_%key_(1) = key
       x%p_%val_(1) = val
       x%p_%nelem_ = 1
       res%nptr_%p_ => x%p_
       res%idx_ = 1
       return
    end if
    ! write(error_unit, '(L)') x%p_%is_leaf_
    do while (.not. x%is_leaf())
       pos = lower_bound(1, x%size(), x%p_%key_(1:x%size()), key)
       if (x%p_%children_(pos)%size() == 2*t - 1) then
          call x%split_child(pos)
          if (key > x%p_%key_(pos)) pos = pos + 1
       end if
       if (pos <= x%size()) then
          if (key == x%p_%key_(pos)) then
             nullify(res%nptr_%p_)
             res%idx_ = -1
             return
          end if
       end if
       x%p_ => x%p_%children_(pos)%p_
    end do
    pos = lower_bound(1, x%size(), x%p_%key_(1:x%size()), key)
    if (pos <= x%size()) then !> `key` <= `x%p_%key(s)`, where s == x%size().
       if (key == x%p_%key_(pos)) then !> `key` already exists in B-tree.
          nullify(res%nptr_%p_)
          res%idx_ = -1
          return
       else !> expand for insertion.
          call x%expand_right(pos)
       end if
    else !> `key` > `x%p_%key(s)`, where s == x%size().
       x%p_%nelem_ = x%p_%nelem_ + 1
    end if
    ! write(error_unit, '(a, i0, 2(1x, i0))') "insert: ", pos+1, key, x%p_%key_(pos+1)
    x%p_%key_(pos) = key
    x%p_%val_(pos) = val
    res%nptr_%p_ => x%p_
    res%idx_ = pos
  contains
    <<btree_sub_lower_bound>>
  end function insert_${btree_node_ptr}
#+end_src
***** remove
B木から `key` を削除する.
採用したアルゴリズムは "アルゴリズムイントロダクション 第3版 総合版 (世界標準MIT教科書)" を参考にしている.
#+name: remove_btree_node_ptr
#+begin_src fortran :exports code :noweb no-export
  !> remove_${btree_node_ptr}: Remove `key` from B-tree.
  !> invariant condition: the node `this%p_` has at least `t` keys.
  recursive subroutine remove_${btree_node_ptr}(this, key)
    class(${btree_node_ptr}), intent(in) :: this
    ${key}, intent(in) :: key
    type(${btree_node_ptr}) :: x, c
    integer(int32) :: pos, s
    ! write(error_unit, '(a, i0)') "search: ", key
    x%p_ => this%p_
    pos = lower_bound(1, x%size(), x%p_%key_(1:x%size()), key)
    if (x%p_%key_(min(pos, x%size())) == key) then !> `key` exists in current internal node.
       call x%remove_key(key, pos)
       return
    end if
    !> `key` does not exist in current internal node.
    if (x%is_leaf()) then
       write(error_unit, '(a, i0, a)') "key: ", key, " is not found."
       call this%print(error_unit, 0)
       error stop 2
       return
    end if
    c%p_ => x%p_%children_(pos)%p_
    if (c%size() >= t) then
       ! write(error_unit, '(a)') "pattern 3, recursive remove"
       ! remove `key` recurrently.
       call c%remove(key)
       ! write(error_unit, '(a, i0)') "pattern 3 end: ", key
       return
    end if
    !> size of child has `t - 1` keys.
    s = x%size()
    if (pos == s + 1) then
       if (x%p_%children_(s)%size() == t - 1) then
          !> x: _w      key (== x(s))
          !>      \    /   \
          !>       c_to     c_from
          !> ------------------------------
          !> x: _w
          !>       \
          !>         (c_to//key//c_from)
          call x%merge_children(s)
          call x%p_%children_(x%size() + 1)%remove(key)
          ! write(error_unit, '(a, i0)') "pattern 3b end: ", key
          return
       end if
    else !> pos: [1, s]
       if (x%p_%children_(pos+1)%size() == t - 1) then
          !>        key            _w
          !>      /     \        /    \
          !> c_to         c_from        c3
          !> ------------------------------
          !>                    _w
          !>                   /   \
          !> c(c_to//x//c_from)      c3
          call x%merge_children(pos)
          call x%p_%children_(pos)%remove(key)
          ! write(error_unit, '(a, i0)') "pattern 3b end: ", key
          return
       end if
    end if
    !> left or right child have n (>= t) keys.
    ! write(error_unit, '(a, i0)') "pattern 3a: ", key
    if (pos == s + 1) then
       ! write(error_unit, '(a, i0)') "pattern 3a-1: ", key
       !> x:            key
       !>             /     \
       !> (c_from:v1)         c_to
       !> ------------------------------
       !> x:         v1
       !>          /    \
       !>   c_from        (x:c_to)
       call x%rotate_right(s)
       call x%p_%children_(x%size() + 1)%remove(key)
    else !> pos: [1, s]
       ! write(error_unit, '(a, i0)') "pattern 3a-2: ", key
       !>      x
       !> c_to   (v1:c_from)
       !> ------------------------------
       !>          v1
       !> (c_to:x)    c_from
       call x%rotate_left(pos)
       call x%p_%children_(pos)%remove(key)
    end if
    ! write(error_unit, '(a, i0)') "pattern 3a end: ", key
    return
  contains
    <<btree_sub_lower_bound>>
  end subroutine remove_${btree_node_ptr}
#+end_src
***** remove_key
`key` のあるノードから `key` を削除する.
#+name: remove_key_btree_node_ptr
#+begin_src fortran :exports code
  !> remove_key_${btree_node_ptr}: If some of current nodes have `key`, call this.
  recursive subroutine remove_key_${btree_node_ptr}(x, key, pos)
    class(${btree_node_ptr}), intent(in) :: x
    ${key}, intent(in) :: key
    integer(int32), intent(in) :: pos
    !> pos: [1, x%size()].
    if (x%is_leaf()) then
       ! write(error_unit, '(a, i0)') "pattern 1: ", key
       call x%shrink_left(pos, pos)
       return
    end if
    !> x is not leaf.
    if (x%p_%children_(pos)%size() >= t) then
       !> Exchange previous `key` if left child has n (>= t) keys.
       ! write(error_unit, '(a)') "pattern 2a"
       !>   x             _y
       !>  /
       !> c           _c2
       !>  \
       !>   (c':v1)
       !> ------------------------------
       !>   v1     _y
       !>  /
       !> c    _c2
       !>  \
       !>   c'
       block
         ${key} :: key_tmp
         ${val} :: val_tmp
         type(${btree_node_ptr}) :: prev
         prev%p_ => x%p_%children_(pos)%p_
         do while (.not. prev%is_leaf())
            prev%p_ => prev%p_%children_(prev%size()+1)%p_
         end do
         key_tmp = prev%p_%key_(prev%size())
         val_tmp = prev%p_%val_(prev%size())
         ! write(error_unit, '(a, *(i0, 1x))') "prev: ", key_tmp, key
         call x%remove(key_tmp)
         x%p_%key_(pos) = key_tmp
         x%p_%val_(pos) = val_tmp
         ! write(error_unit, '(a, 2(i0, 1x))') "pattern 2a end: ", key, key_tmp
         return
       end block
    else if (x%p_%children_(pos+1)%size() >= t) then !> right child has n (>= t) keys.
       ! write(error_unit, '(a)') "pattern 2b"
       !>     x         _y
       !>           \
       !> _c1         c
       !>            /
       !>     (v1:c')
       !> ------------------------------
       !>     v1   _y
       !>       \
       !> _c1    c
       !>       /
       !>     c'
       block
         ${key} :: key_tmp
         ${val} :: val_tmp
         type(${btree_node_ptr}) :: next
         next%p_ => x%p_%children_(pos+1)%p_
         do while (.not. next%is_leaf())
            next%p_ => next%p_%children_(1)%p_
         end do
         key_tmp = next%p_%key_(1)
         val_tmp = next%p_%val_(1)
         ! write(error_unit, '(a, *(i0, 1x))') "next: ", key, key_tmp
         call x%remove(key_tmp)
         x%p_%key_(pos) = key_tmp
         x%p_%val_(pos) = val_tmp
         ! write(error_unit, '(a, 2(i0, 1x))') "pattern 2b end: ", key, key_tmp
         return
       end block
    else !> left and right children have `t - 1` keys.
       ! write(error_unit, '(a)') "pattern 2c"
       !>   x                _y
       !> c   c2(deallocate)    _c3
       !> --------------------------------
       !>            _y
       !> (c//x//c2)    _c3
       call x%merge_children(pos)
       call x%p_%children_(pos)%remove(key)
       ! write(error_unit, '(a, i0)') "pattern 2c end: ", key
       return
    end if
  end subroutine remove_key_${btree_node_ptr}
#+end_src
***** merge_children
#+name: merge_children_btree_node_ptr
#+begin_src fortran :exports code
  !> merge_${btree_node_ptr}: Merge left child, middle key and right child.
  !> Then shrink left and deallocate right child.
  !>      x                   _y
  !> left   right(deallocate)    _c
  !> --------------------------------
  !>                  _y
  !> (left//x//right)    _c
  subroutine merge_children_${btree_node_ptr}(x, pos)
    class(${btree_node_ptr}), intent(in) :: x
    integer(int32), intent(in) :: pos
    type(${btree_node_ptr}) :: left, right
    integer(int32) :: i
    left%p_  => x%p_%children_(pos)%p_
    right%p_ => x%p_%children_(pos+1)%p_

    left%p_%key_(t) = x%p_%key_(pos)
    left%p_%val_(t) = x%p_%val_(pos)
    left%p_%key_(t+1:2*t-1) = right%p_%key_(1:t-1)
    left%p_%val_(t+1:2*t-1) = right%p_%val_(1:t-1)
    do i = t+1, 2*t
       left%p_%children_(i)%p_ => right%p_%children_(i-t)%p_
    end do
    left%p_%nelem_ = 2*t - 1
    deallocate(right%p_)
    nullify(right%p_)
    call x%shrink_left(pos, pos+1) ! unlink right child.
  end subroutine merge_children_${btree_node_ptr}
#+end_src
***** rotate_left
#+name: rotate_left_btree_node_ptr
#+begin_src fortran :exports code
  !> rotate_left_${btree_node_ptr}: Rotate keys.
  !> Increase the number of left node keys and decrease that of right node keys.
  !> The number of right node keys must have at least `t` keys.
  !> x:     key
  !>      /     \
  !> left         right(v1:rest)
  !> ------------------------------
  !> x:           v1
  !>            /    \
  !> (left:key)        rest
  subroutine rotate_left_${btree_node_ptr}(x, pos)
    class(${btree_node_ptr}), intent(in) :: x
    integer(int32), intent(in) :: pos
    type(${btree_node_ptr}) :: left, right
    integer(int32) :: ls
    left%p_  => x%p_%children_(pos)%p_
    right%p_ => x%p_%children_(pos+1)%p_
    ls = left%size() + 1
    left%p_%key_(ls) = x%p_%key_(pos)
    left%p_%val_(ls) = x%p_%val_(pos)
    left%p_%children_(ls+1)%p_ => right%p_%children_(1)%p_
    left%p_%nelem_ = ls
    x%p_%key_(pos) = right%p_%key_(1)
    x%p_%val_(pos) = right%p_%val_(1)
    call right%shrink_left(1, 1) !> right%size() -= 1
  end subroutine rotate_left_${btree_node_ptr}
#+end_src
***** rotate_right
#+name: rotate_right_btree_node_ptr
#+begin_src fortran :exports code
  !> rotate_right_${btree_node_ptr}: Rotate keys.
  !> Increase the number of right node keys and decrease that of left node keys.
  !> The number of left node keys must have at least `t` keys.
  !> x:              key
  !>               /     \
  !> left(init:v1)         right
  !> ------------------------------
  !> x:       v1
  !>        /    \
  !>   init        (key:right)
  subroutine rotate_right_${btree_node_ptr}(x, pos)
    class(${btree_node_ptr}), intent(in) :: x
    integer(int32), intent(in) :: pos
    type(${btree_node_ptr}) :: left, right
    left%p_  => x%p_%children_(pos)%p_
    right%p_ => x%p_%children_(pos+1)%p_
    call right%expand_right(1) !> right%size() += 1
    right%p_%key_(1) = x%p_%key_(pos)
    right%p_%val_(1) = x%p_%val_(pos)
    right%p_%children_(1)%p_ => left%p_%children_(left%size() + 1)%p_
    x%p_%key_(pos) = left%p_%key_(left%size())
    x%p_%val_(pos) = left%p_%val_(left%size())
    call left%shrink_left(left%size(), left%size()+1) !> unlink right child.
  end subroutine rotate_right_${btree_node_ptr}
#+end_src
***** shrink_left
#+name: shrink_left_btree_node_ptr
#+begin_src fortran :exports code
  !> shrink_left_${btree_node_ptr}: Remove the `key` and `val` from the `pos` of `this%p_` and shrink it.
  !> before: key(1), key(2), ... key(pos-1), key(pos), key(pos+1), ..., key(s)
  !> after : key(1), key(2), ... key(pos-1), key(pos+1), ..., key(s)
  !> before: child(1), child(2), ... child(pos_child-1), child(pos_child), child(pos_child+1), ..., child(s+1)
  !> after : child(1), child(2), ... child(pos_child-1),                   child(pos_child+1), ..., child(s+1)
  subroutine shrink_left_${btree_node_ptr}(this, pos, pos_child)
    class(${btree_node_ptr}), intent(in) :: this
    integer(int32), intent(in) :: pos, pos_child
    type(${btree_node_ptr}) :: x
    integer(int32) :: s
    integer(int32) :: i
    x%p_ => this%p_
    s = x%size()
    !> copy [pos+1, s] to [pos, s-1].
    !> delete `pos` of array.
    x%p_%key_(pos:s-1) = x%p_%key_(pos+1:s)
    x%p_%val_(pos:s-1) = x%p_%val_(pos+1:s)
    x%p_%nelem_ = s - 1
    if (x%is_leaf()) return
    do i = pos_child, s
       x%p_%children_(i)%p_ => x%p_%children_(i+1)%p_
    end do
  end subroutine shrink_left_${btree_node_ptr}
#+end_src
***** expand_right
#+name: expand_right_btree_node_ptr
#+begin_src fortran :exports code
  subroutine expand_right_${btree_node_ptr}(this, pos)
    class(${btree_node_ptr}), intent(in) :: this
    integer(int32), intent(in) :: pos
    type(${btree_node_ptr}) :: x
    integer(int32) :: s
    integer(int32) :: i
    x%p_ => this%p_
    s = x%size()
    !> copy [pos, s] to [pos+1, s+1].
    !> `pos` of array is empty.
    x%p_%key_(pos+1:s+1) = x%p_%key_(pos:s)
    x%p_%val_(pos+1:s+1) = x%p_%val_(pos:s)
    x%p_%nelem_ = s + 1
    if (x%is_leaf()) return
    do i = s+1, pos, -1
       x%p_%children_(i+1)%p_ => x%p_%children_(i)%p_
    end do
  end subroutine expand_right_${btree_node_ptr}
#+end_src
***** print
#+name: print_btree_node_ptr
#+begin_src fortran :exports code
  recursive subroutine print_${btree_node_ptr}(this, unit, depth)
    class(${btree_node_ptr}), intent(in) :: this
    integer(int32), intent(in) :: unit, depth
    type(${btree_node_ptr}) :: x
    integer(int32) :: i
    x%p_ => this%p_
    write(unit, *) repeat("|", min(1, depth))//repeat("-", depth), depth, ": ", x%p_%key_(1:x%size())
    if (x%is_leaf()) return
    do i = 1, x%p_%nelem_ + 1
       call x%p_%children_(i)%print(unit, depth + 1)
    end do
  end subroutine print_${btree_node_ptr}
#+end_src
***** check_invariant
#+name: check_invariant_btree_node_ptr
#+begin_src fortran :exports code
  recursive subroutine check_invariant_${btree_node_ptr}(this)
    class(${btree_node_ptr}), intent(in) :: this
    integer(int32) :: i
    if (this%size() < t - 1) then
       write(error_unit, '(a)') "Error: invariant, node must have at least `t - 1` keys."
       error stop 1
    end if
    if (this%is_leaf()) return
    do i = 1, this%size() + 1
       call this%p_%children_(i)%check_invariant()
    end do
  end subroutine check_invariant_${btree_node_ptr}
#+end_src
**** btreee_node_iter のメソッド
***** key
#+name: key_btree_node_ptr
#+begin_src fortran :exports code
  impure ${key} function key_${btree_node_iter}(this) result(res)
    class(${btree_node_iter}), intent(in) :: this
    res = this%nptr_%p_%key_(this%idx_)
  end function key_${btree_node_iter}
#+end_src
***** val
#+name: val_btree_node_iter
#+begin_src fortran :exports code
  impure ${val} function val_${btree_node_iter}(this) result(res)
    class(${btree_node_iter}), intent(in) :: this
    res = this%nptr_%p_%val_(this%idx_)
  end function val_${btree_node_iter}
#+end_src
***** mut_val
#+name: mut_val_btree_node_iter
#+begin_src fortran :exports code
  subroutine mut_val_${btree_node_iter}(this, val)
    class(${btree_node_iter}), intent(in) :: this
    ${val}, intent(in) :: val
    type(${btree_node_ptr}) :: x
    x%p_ => this%nptr_%p_
    x%p_%val_(this%idx_) = val
  end subroutine mut_val_${btree_node_iter}
#+end_src
***** next
#+name: next_btree_node_iter
#+begin_src fortran :exports code
  subroutine next_${btree_node_iter}(this)
    class(${btree_node_iter}), intent(inout) :: this
    if (this%is_end()) then
       write(error_unit, '(a)') "Error in `next`: exceed end of iterator."
       error stop 4
    end if
    if (this%nptr_%is_leaf()) then
       this%idx_ = this%idx_ + 1
       if (this%idx_ <= this%nptr_%size()) return
       !> this%idx_ == this%nptr_%size() + 1.
       do !> visit parent of current node if `this%idx_` exceeds the range of `this%nptr_%p_%key_(1:s)`, where s == this%nptr_%size().
          if (this%depth_ == 1) return !> end of iterator if `this%idx_ == this%nptr_%size() + 1` and `this%nptr_%p_` is root of B-tree.
          this%depth_ = this%depth_ - 1
          this%nptr_%p_ => this%parents_(this%depth_)%p_
          this%idx_ = this%indices_(this%depth_)
          nullify(this%parents_(this%depth_)%p_)
          if (this%idx_ <= this%nptr_%size()) return !> this%idx_: [1:s], where s == this%nptr_%size().
       end do
    else !> visit right node and then visit the most left value.
       this%parents_(this%depth_)%p_ => this%nptr_%p_
       this%indices_(this%depth_) = this%idx_ + 1
       this%depth_ = this%depth_ + 1
       this%nptr_%p_ => this%nptr_%p_%children_(this%idx_ + 1)%p_
       do while (.not. this%nptr_%is_leaf())
          this%parents_(this%depth_)%p_ => this%nptr_%p_
          this%indices_(this%depth_) = 1
          this%depth_ = this%depth_ + 1
          this%nptr_%p_ => this%nptr_%p_%children_(1)%p_
       end do
       !> this%nptr_%is_leaf() is .true..
       this%idx_ = 1
    end if
  end subroutine next_${btree_node_iter}
#+end_src
***** prev
#+name: prev_btree_node_iter
#+begin_src fortran :exports code
  subroutine prev_${btree_node_iter}(this)
    class(${btree_node_iter}), intent(inout) :: this
    if (this%is_begin()) then !> `this%idx_ == 0` and `this%p_` is root of B-tree.
       !> beginning of iterator.
       write(error_unit, '(a)') "Error in `prev`: beginning of iterator."
       error stop 4
    end if
    if (this%nptr_%is_leaf()) then
       this%idx_ = this%idx_ - 1
       if (this%idx_ >= 1) return
       !> this%idx_ == 0
       do !> visit parent of current node if `this%idx_` exceeds the range of `this%nptr_%p_%key_(1:s)`, where s == this%nptr_%size().
          if (this%depth_ == 1) return !> beginning of iterator if `this%idx_ == 0` and `this%p_` is root of B-tree.
          this%depth_ = this%depth_ - 1
          this%nptr_%p_ => this%parents_(this%depth_)%p_
          nullify(this%parents_(this%depth_)%p_)
          this%idx_ = this%indices_(this%depth_) - 1
          if (this%idx_ >= 1) return !> this%idx_: [1:s], where s == this%nptr_%size().
       end do
    else !> visit left node and then visit the most right value.
       this%parents_(this%depth_)%p_ => this%nptr_%p_
       this%indices_(this%depth_) = this%idx_
       this%depth_ = this%depth_ + 1
       this%nptr_%p_ => this%nptr_%p_%children_(this%idx_)%p_
       do while (.not. this%nptr_%is_leaf())
          this%parents_(this%depth_)%p_ => this%nptr_%p_
          this%indices_(this%depth_) = this%nptr_%size() + 1
          this%depth_ = this%depth_ + 1
          this%nptr_%p_ => this%nptr_%p_%children_(this%nptr_%size() + 1)%p_
       end do
       !> this%nptr_%is_leaf() is .true.
       this%idx_ = this%nptr_%size()
    end if
  end subroutine prev_${btree_node_iter}
#+end_src
***** is_begin
#+name: is_begin_btree_node_iter
#+begin_src fortran :exports code
  !> is_begin_${btree_node_iter}: return iter is begining of B-tree.
  logical function is_begin_${btree_node_iter}(this) result(res)
    class(${btree_node_iter}), intent(in) :: this
    res = this%depth_ == 1 .and. this%idx_ == 0
  end function is_begin_${btree_node_iter}
#+end_src
***** is_not_begin
#+name: is_not_begin_btree_node_iter
#+begin_src fortran :exports code
  !> is_not_begin_${btree_node_iter}: return iter is not begining of B-tree.
  logical function is_not_begin_${btree_node_iter}(this) result(res)
    class(${btree_node_iter}), intent(in) :: this
    res = .not. this%is_begin()
  end function is_not_begin_${btree_node_iter}
#+end_src
***** is_end
#+name: is_end_btree_node_iter
#+begin_src fortran :exports code
  !> is_end_${btree_node_iter}: return iter is end of B-tree.
  logical function is_end_${btree_node_iter}(this) result(res)
    class(${btree_node_iter}), intent(in) :: this
    res = this%depth_ == 1 .and. this%idx_ == this%nptr_%size() + 1
  end function is_end_${btree_node_iter}
#+end_src
***** is_not_end
#+name: is_not_end_btree_node_iter
#+begin_src fortran :exports code
  !> is_not_end_${btree_node_iter}: return iter is not end of B-tree.
  logical function is_not_end_${btree_node_iter}(this) result(res)
    class(${btree_node_iter}), intent(in) :: this
    res = .not. this%is_end()
  end function is_not_end_${btree_node_iter}
#+end_src
***** exist
#+name: exist_btree_node_iter
#+begin_src fortran :exports code
  logical function exist_${btree_node_iter}(this) result(res)
    class(${btree_node_iter}), intent(in) :: this
    res = this%idx_ /= -1
  end function exist_${btree_node_iter}
#+end_src
***** not_exist
#+name: not_exist_btree_node_iter
#+begin_src fortran :exports code
  logical function not_exist_${btree_node_iter}(this) result(res)
    class(${btree_node_iter}), intent(in) :: this
    res = .not. this%exist()
  end function not_exist_${btree_node_iter}
#+end_src
*** 補助関数
**** lower_bound
#+name: btree_sub_lower_bound
#+begin_src fortran :exports code
  !> lower_bound: search `i+1`, which satisfied arr(i) < key <= arr(i+1), arr(0) == -infinity.
  pure integer(int32) function lower_bound(lb, ub, arr, key) result(res)
    integer(int32), intent(in) :: lb, ub
    ${key}, intent(in) :: arr(lb:ub)
    ${key}, intent(in) :: key
    integer(int32) :: p, q, r
    p = lb
    r = ub
    if (key <= arr(p)) then
       res = p
    else if (arr(r) < key) then
       res = r + 1
    else !> arr(p) < key <= arr(r)
       ! invariant condition:
       ! key > arr(p) .and. key <= arr(r)
       binary_search: do while(p + 1 < r)
          q = (p+r) / 2
          if (arr(q) < key) then
             p = q
          else !> key <= arr(q)
             r = q
          end if
       end do binary_search
       res = r
    end if
  end function lower_bound
#+end_src

*** B木の展開
**** 変数の宣言
#+name: btree-var
#+begin_src bash :exports code :cache no :shebang #!/bin/bash
  case "${key_base}" in
      "character")
          key="${key_base}(${key_kind})"
          suffix="${key_base}${key_kind}"
          ;;
      "type")
          key="type(${key_kind})"
          suffix="${key_kind}"
          ;;
      ,*)
          key="${key_base}(${key_kind})"
          suffix="${key_kind}"
          ;;
  esac
  case "${val_base}" in
      "character")
          val="${val_base}(${val_kind})"
          suffix="${suffix}_to_${val_base}${val_kind}"
          ;;
      "type")
          val="type(${val_kind})"
          suffix="${suffix}_to_${val_kind}"
          ;;
      ,*)
          val="${val_base}(${val_kind})"
          suffix="${suffix}_to_${val_kind}"
          ;;
  esac
  btree="btree_${suffix}"
  btree_node="btree_node_${suffix}"
  btree_node_ptr="btree_node_ptr_${suffix}"
  btree_node_iter="btree_node_iter_${suffix}"
#+end_src
**** 宣言の展開
#+name: declaration-btree-var
#+begin_src bash :exports code :var key_base="integer" key_kind="int32" val_base="integer" val_kind="int32" :results output :noweb no-export :cache no :shebang #!/bin/bash
  <<btree-var>>
  cat <<EOF
  <<declaration-btree>>
  EOF
#+end_src
#+name: procedures-btree-var
#+begin_src bash :exports code :var key_base="integer" key_kind="int32" val_base="integer" val_kind="int32" :results output :noweb no-export :cache no :shebang #!/bin/bash
  <<btree-var>>
  cat <<EOF
  <<procedures-btree>>
  EOF
#+end_src
*** B木のテスト
**** test本体.
#+name: test-btree
#+begin_src fortran :flags "-cpp -g -fbacktrace -fcheck=bounds" :exports code :results output file :file "btree.log" :noweb no-export :cache yes
<<btree-module>>
<<btree-test>>
#+end_src

#+RESULTS[a7886dd625a79f94ce2a5543fe9fbf627bf7da3d]: test-btree
[[file:btree.log]]

**** testプログラム
#+name: btree-test
#+begin_src fortran :exports code :tangle "../../test/test_btree.F90" :noweb no-export
  program test_btree_m
    use, intrinsic :: iso_fortran_env
    use btree_m
    implicit none
    type(btree_int32_to_int32) :: m
    integer(int32), parameter :: n = 3*10**4
    call m%init()
    ! write(error_unit, '(a, *(i0, 1x))') "random insertion: s, h: ", m%size(), m%height()
    call check_insertion_random(n)
    ! write(error_unit, '(a, *(i0, 1x))') "ascending insertion: s, h: ", m%size(), m%height()
    call check_insertion_ascending(n)
    ! write(error_unit, '(a, *(i0, 1x))') "descending insertion: s, h: ", m%size(), m%height()
    call check_insertion_descending(n)
    call check_deletion_latter_to_former(n)
    call check_deletion_latter_to_former(n-1)
    call check_deletion_front_back_in_turn(n)
    call check_deletion_front_back_in_turn(n-1)
    call check_deletion_minimum(n)
    call check_deletion_minimum(n-1)
    call check_insertion_character100()
    ! write(error_unit, '(a, *(i0, 1x))') "all done: s, h: ", m%size(), m%height()
    call check_iterator_next(n)
    call check_iterator_prev(n)
    ! write(error_unit, '(a)') "Success!"
  contains
    <<btree-test-check_insertion_random>>
    <<btree-test-check_insertion_ascending>>
    <<btree-test-check_insertion_descending>>
    <<btree-test-check_deletion_latter_to_former>>
    <<btree-test-check_deletion_front_back_in_turn>>
    <<btree-test-check_deletion_minimum>>
    <<btree-test-check_insertion_character100>>
    <<btree-test-check_iterator_next>>
    <<btree-test-check_iterator_prev>>
  end program test_btree_m
#+end_src
**** ランダムな大きさの要素を挿入.
#+name: btree-test-check_insertion_random
#+begin_src fortran :exports code :noweb no-export
  subroutine check_insertion_random(n)
    integer(int32), intent(in) :: n
    integer(int32) :: seedsize
    integer(int32), allocatable :: seed(:)
    integer(int32), allocatable :: arr(:)
    logical, allocatable :: used(:)
    integer(int32) :: i
    real(real64) :: r
    allocate(arr(n))
    allocate(used(0:10*n-1), source = .false.)
    call random_seed(size = seedsize)
    allocate(seed(seedsize))
    ! call random_seed(get=seed)
    ! write(output_unit, '(*(i0, 1x))') seed(:)
    ! stop
    ! seed(:) = [1491111790, -1572383, 827114786, -2082456701, 1635664076, -1541841097, -1561155676, -20848911]
    ! seed(:) = [-200678384, 1172132809, 124451245, 104878683, 643972878, 359873178, 1075753119, -200657478, 554946086, 24937149&
    !      , -268657053, -197381607, 216039971, 1432749834, 990875914, -2110703970, 2126530906, 1473942311, 1489084070, -932897027&
    !      , -620123104, 1538555552, 715169866, -426413934, 1522025556, -432716, -882668547, -346073549, -1849722518, 111186990&
    !      , -50097180, 1633091563, 0]
    seed(:) = [(i, i = 1, seedsize)]
    call random_seed(put=seed)
    do i = 1, n
       do
          call random_number(r)
          arr(i) = floor(10*n*r)
          if (.not. used(arr(i))) then
             used(arr(i)) = .true.
             exit
          end if
       end do
       call m%insert(arr(i), i)
    end do
    call m%check_invariant()
    ! write(error_unit, '(a, *(i0, 1x))') "s, h: ", m%size(), m%height()
    do i = 1, n
       <<../Implementations.org:assert-eq(eq1="m%get(arr(i))", eq2="i", code=4, message="Btree method `insert` or `get` are something wrong.")>>
    end do
    do i = 1, n
       call m%remove(arr(i))
    end do
    <<../Implementations.org:assert-eq(eq1="m%size()", eq2="0", code=5, message="Btree method `remove` are something wrong.")>>
  end subroutine check_insertion_random
#+end_src
**** 昇順に挿入.
#+name: btree-test-check_insertion_ascending
#+begin_src fortran :exports code :noweb no-export
  subroutine check_insertion_ascending(n)
    integer(int32), intent(in) :: n
    integer(int32) :: i
    type(btree_node_iter_int32_to_int32) :: iter
    do i = 1, n
       call m%insert(i, i)
    end do
    <<../Implementations.org:assert-eq(eq1="m%size()", eq2="n", code=11, message="Btree method `insert` are something wrong.")>>
    call m%check_invariant()
    do i = 1, n
       call m%remove(i)
    end do
    <<../Implementations.org:assert-eq(eq1="m%size()", eq2="0", code=12, message="Btree method `remove` are something wrong.")>>
    do i = 1, n
       call m%insert(i, i)
    end do
    ! call m%print(output_unit)
    call m%check_invariant()
    <<../Implementations.org:assert-eq(eq1="m%size()", eq2="n", code=13, message="Btree method `insert` are something wrong.")>>
    do i = n, 1, -1
       call m%remove(i)
    end do
    <<../Implementations.org:assert-eq(eq1="m%size()", eq2="0", code=14, message="Btree method `remove` are something wrong.")>>
  end subroutine check_insertion_ascending
#+end_src
**** 降順に要素を挿入
#+name: btree-test-check_insertion_descending
#+begin_src fortran :exports code :noweb no-export
  subroutine check_insertion_descending(n)
    integer(int32), intent(in) :: n
    integer(int32) :: i
    do i = n, 1, -1
       call m%insert(i, i)
    end do
    call m%check_invariant()
    <<../Implementations.org:assert-eq(eq1="m%size()", eq2="n", code=21, message="Btree method `insert` are something wrong.")>>
    do i = 1, n
       call m%remove(i)
    end do
    call m%check_invariant()
    <<../Implementations.org:assert-eq(eq1="m%size()", eq2="0", code=22, message="Btree method `remove` are something wrong.")>>
    do i = n, 1, -1
       call m%insert(i, i)
    end do
    call m%check_invariant()
    <<../Implementations.org:assert-eq(eq1="m%size()", eq2="n", code=23, message="Btree method `insert` are something wrong.")>>
    do i = n, 1, -1
       call m%remove(i)
    end do
    call m%check_invariant()
    <<../Implementations.org:assert-eq(eq1="m%size()", eq2="0", code=24, message="Btree method `remove` are something wrong.")>>
  end subroutine check_insertion_descending
#+end_src
**** 要素を後ろ半分を削除して前半分を削除
#+name: btree-test-check_deletion_latter_to_former
#+begin_src fortran :exports code :noweb no-export
  subroutine check_deletion_latter_to_former(n)
    integer(int32), intent(in) :: n
    integer(int32) :: i
    do i = 1, n
       call m%insert(i, i)
    end do
    call m%check_invariant()
    <<../Implementations.org:assert-eq(eq1="m%size()", eq2="n", code=21, message="Btree method `insert` are something wrong.")>>
    do i = n/2, n
       call m%remove(i)
    end do
    <<../Implementations.org:assert-eq(eq1="m%size()", eq2="n-(n-n/2+1)", code=22, message="Btree method `remove` are something wrong.")>>
    do i = 1, n/2-1
       call m%remove(i)
    end do
    call m%check_invariant()
    <<../Implementations.org:assert-eq(eq1="m%size()", eq2="0", code=23, message="Btree method `remove` are something wrong.")>>
    do i = n, 1, -1
       call m%insert(i, i)
    end do
    call m%check_invariant()
    <<../Implementations.org:assert-eq(eq1="m%size()", eq2="n", code=24, message="Btree method `insert` are something wrong.")>>
    do i = n, n/2, -1
       call m%remove(i)
    end do
    call m%check_invariant()
    <<../Implementations.org:assert-eq(eq1="m%size()", eq2="n-(n-n/2+1)", code=25, message="Btree method `remove` are something wrong.")>>
    do i = n/2-1, 1, -1
       call m%remove(i)
    end do
    call m%check_invariant()
    <<../Implementations.org:assert-eq(eq1="m%size()", eq2="0", code=26, message="Btree method `remove` are something wrong.")>>
  end subroutine check_deletion_latter_to_former
#+end_src
**** 要素を前と後ろで交互に
#+name: btree-test-check_deletion_front_back_in_turn
#+begin_src fortran :exports code :noweb no-export
  subroutine check_deletion_front_back_in_turn(n)
    integer(int32), intent(in) :: n
    integer(int32) :: i
    do i = 1, n
       call m%insert(i, i)
    end do
    call m%check_invariant()
    <<../Implementations.org:assert-eq(eq1="m%size()", eq2="n", code=21, message="Btree method `insert` are something wrong.")>>
    do i = 1, (n+1)/2
       call m%remove(i)
       if (i == n-i+1) exit
       call m%remove(n-i+1)
    end do
    <<../Implementations.org:assert-eq(eq1="m%size()", eq2="0", code=22, message="Btree method `remove` are something wrong.")>>
    call m%check_invariant()
    do i = n, 1, -1
       call m%insert(i, i)
    end do
    call m%check_invariant()
    <<../Implementations.org:assert-eq(eq1="m%size()", eq2="n", code=24, message="Btree method `insert` are something wrong.")>>
    do i = 1, (n+1)/2
       call m%remove(i)
       if (i == n-i+1) exit
       call m%remove(n-i+1)
    end do
    call m%check_invariant()
    <<../Implementations.org:assert-eq(eq1="m%size()", eq2="0", code=26, message="Btree method `remove` are something wrong.")>>
  end subroutine check_deletion_front_back_in_turn
#+end_src
**** minimumの要素を削除
#+name: btree-test-check_deletion_minimum
#+begin_src fortran :exports code :noweb no-export
  subroutine check_deletion_minimum(n)
    integer(int32), intent(in) :: n
    integer(int32) :: mini
    integer(int32) :: i
    do i = 1, n
       call m%insert(i, i)
    end do
    call m%check_invariant()
    <<../Implementations.org:assert-eq(eq1="m%size()", eq2="n", code=21, message="Btree method `insert` are something wrong.")>>
    do i = 1, n
       if (m%size() == 0) exit
       mini = m%minimum()
       if (i + n/2 >= 29952) then
          write(error_unit, '(*(i0, 1x))') m%size(), i, mini
          call m%print(error_unit)
       end if
       <<../Implementations.org:assert(cond="m%contains(mini)", code=19, message="Btree method `remove` or `minimum` are something wrong.")>>
       call m%remove(mini)
       <<../Implementations.org:assert-eq(eq1="mini", eq2="i", code=20, message="Btree method `remove` are something wrong.")>>
       call m%remove(i+n/2)
    end do
    call m%check_invariant()
    do i = n, 1, -1
       call m%insert(i, i)
    end do
    call m%check_invariant()
    <<../Implementations.org:assert-eq(eq1="m%size()", eq2="n", code=24, message="Btree method `insert` are something wrong.")>>
    do i = 1, n
       if (m%size() == 0) exit
       mini = m%minimum()
       <<../Implementations.org:assert(cond="m%contains(mini)", code=26, message="Btree method `remove` or `minimum` are something wrong.")>>
       call m%remove(mini)
       <<../Implementations.org:assert-eq(eq1="mini", eq2="i", code=25, message="Btree method `remove` are something wrong.")>>
       call m%remove(i+n/2)
    end do
    call m%check_invariant()
  end subroutine check_deletion_minimum
#+end_src
**** character(len=100)を挿入
#+name: btree-test-check_insertion_character100
#+begin_src fortran :exports code :noweb no-export
  subroutine check_insertion_character100()
    type(btree_character100_to_int32) :: m_c100
    character(len=10), parameter :: cs(*) = ["apple     ", "banana    ", "chocolate ", "donuts    ", "egg       ", "chocobanan"]
    character(len=100) :: c
    integer(int32) :: i
    call m_c100%init()
    do i = 1, size(cs)
       c = cs(i)
       call m_c100%insert(c, i)
    end do
    do i = 1, size(cs)
       c = cs(i)
       <<../Implementations.org:assert-eq(eq1="m_c100%get(c)", eq2="i", code="40", "Btree method `insert` or `get` are something wrong.")>>
    end do
  end subroutine check_insertion_character100
#+end_src
**** iteratorを前へ操作(next)
#+name: btree-test-check_iterator_next
#+begin_src fortran :exports code :noweb no-export
  subroutine check_iterator_next(n)
    integer(int32), intent(in) :: n
    type(btree_int32_to_int32) :: m
    type(btree_node_iter_int32_to_int32) :: iter
    integer(int32) :: i
    call m%init()
    do i = 1, n
       call m%insert(i, i)
    end do
    iter = m%minimum_iter()
    i = 1
    do while (iter%is_not_end())
       <<../Implementations.org:assert-eq(eq1="iter%key()", eq2="i", code="50", "Btree iter method `minimum_iter`, `next` are something wrong.")>>
       i = i + 1
       call iter%next()
    end do
    <<../Implementations.org:assert-eq(eq1="i", eq2="n+1", code="51", "Btree iter method `minimum_iter`, `next` are something wrong.")>>
    iter = m%get_iter(n/2)
    i = n/2
    do while (iter%is_not_end())
       <<../Implementations.org:assert-eq(eq1="iter%key()", eq2="i", code="52", "Btree iter method `get_iter`, `next` are something wrong.")>>
       i = i + 1
       call iter%next()
    end do
    <<../Implementations.org:assert-eq(eq1="i", eq2="n+1", code="53", "Btree iter method `get_iter`, `next` are something wrong.")>>
  end subroutine check_iterator_next
#+end_src
**** iteratorを後ろへ操作(prev)
#+name: btree-test-check_iterator_prev
#+begin_src fortran :exports code :noweb no-export
  subroutine check_iterator_prev(n)
    integer(int32), intent(in) :: n
    type(btree_int32_to_int32) :: m
    type(btree_node_iter_int32_to_int32) :: iter
    integer(int32) :: i
    call m%init()
    do i = 1, n
       call m%insert(i, i)
    end do
    iter = m%maximum_iter()
    i = n
    do while (iter%is_not_begin())
       <<../Implementations.org:assert-eq(eq1="iter%key()", eq2="i", code="61", "Btree iter method `maximum_reti`,  `prev` are something wrong.")>>
       i = i - 1
       call iter%prev()
    end do
    <<../Implementations.org:assert-eq(eq1="i", eq2="0", code="62", "Btree iter method `maximum_iter`, `prev` are something wrong.")>>
    iter = m%get_iter(n/2)
    i = n/2
    do while (iter%is_not_begin())
       <<../Implementations.org:assert-eq(eq1="iter%key()", eq2="i", code="63", "Btree iter method `get_iter`, `prev` are something wrong.")>>
       i = i - 1
       call iter%prev()
    end do
    <<../Implementations.org:assert-eq(eq1="i", eq2="0", code="64", "Btree iter method `get_iter`, `prev` are something wrong.")>>
  end subroutine check_iterator_prev
#+end_src
*** 解けたAtCoderの問題
- ABC296C
  [[https://atcoder.jp/contests/ABC296/submissions/43783893]]
- 鉄則本A54
  [[https://atcoder.jp/contests/tessoku-book/submissions/43783501]]
- 鉄則本B54
  [[https://atcoder.jp/contests/tessoku-book/submissions/43783609]]
