#+TITLE: Implement algorithms in Modern Fortran.
#+AUTHOR: Yuma Osada
#+DATE: {{{time(%Y-%m-%d)}}}.
#+LaTeX_header: \usepackage{minted}
#+LaTeX_header: \usepackage{cleveref}
#+macro: src_line line [[($1)]]
#+options: ^:{}
#+options: toc:t H:4 num:4
* emacs-lisp
** org babel settings
Modify org-babel function to avoid adding ~program...end program~ around ~module...end module~.
#+name: set-fortran-wrap
#+begin_src emacs-lisp :exports code
  (defun org-babel-fortran-ensure-main-wrap (body params)
    "Wrap body in a \"program ... end program\" block if none exists."
    (if (or (string-match "^[ \t]*program\\>" (capitalize body))
            (string-match "^[ \t]*module\\>" (capitalize body)))
        (let ((vars (org-babel--get-vars params)))
          (when vars (error "Cannot use :vars if `program' statement is present"))
          body)
      (format "program main\n%s\nend program main\n" body)))
  ;; reference: https://stackoverflow.com/questions/40033843/show-the-name-of-a-code-block-in-org-mode-when-export.
  (customize-set-variable 'org-babel-exp-code-template
                          "#+CAPTION: %name(%lang) label:%name\n#+ATTR_LaTeX: :placement [H] :float t\n#+BEGIN_SRC %lang%switches%flags\n%body\n#+END_SRC")
#+end_src
#+name: disabled_org-confirm-babel-evaluate
#+begin_src emacs-lisp :exports code :results output :cache yes
  (customize-set-variable 'org-confirm-babel-evaluate nil)
#+end_src
* org-babel macros
** error handling
#+name: error-handling-return-ierr
#+begin_src bash :exports code :var ierr=1 :results output :noweb no-export :cache no :shebang #!/bin/bash
  cat <<EOF
    if (present(ierr)) then
      ierr = ${ierr}
      return
    end if
  EOF
#+end_src
#+name: error-handling-filename
#+begin_src fortran :exports code
   write(error_unit, '(a, i0, a)', advance = "no")&
        "Error in "//&
        __FILE__&
        //":", __LINE__, ":"
#+end_src
#+name: error-handling-error_message-exit
#+begin_src bash :exports code :var err_num=1 string="error message." :results output :noweb no-export :cache no :shebang #!/bin/bash
   cat <<EOF
     write(error_unit, '(a)')&
       "${string}"
     error stop ${err_num}
   EOF
#+end_src
#+name: error-handling-exit
#+begin_src bash :exports code :var err_num=1 :results output :noweb no-export :cache no :shebang #!/bin/bash
  cat <<EOF
    error stop ${err_num}
  EOF
#+end_src
** assertion
#+name: assert-fortran
#+begin_src fortran :exports code :noweb yes
  if (${cond}) then
     <<error-handling-filename>>
     write(error_unit, '(a)') " Assertion '${cond_origin}' must be ${true_false}."
     if (len_trim("${message}") /= 0) then
        write(error_unit, '(a)') "Extra message: '${message}'"
     end if
     error stop ${code}
  end if
#+end_src
#+name: assert-eq-fortran
#+begin_src fortran :exports code :noweb yes
  if (${cond}) then
     <<error-handling-filename>>
     write(error_unit, '(a)') " Assertion '${cond_origin}' must be ${true_false}."
     write(error_unit, '(a)', advance = "no") "${eq1}: "
     write(error_unit, *) ${eq1}
     write(error_unit, '(a)', advance = "no") "${eq2}: "
     write(error_unit, *) ${eq2}
     if (len_trim("${message}") /= 0) then
        write(error_unit, '(a)') "Extra message: '${message}'"
     end if
     error stop ${code}
  end if
#+end_src
~${cond}~ が ~.false.~ ならエラー.
#+name: assert
#+begin_src bash :exports code :var cond=".true." code="127" message="" :results output :noweb no-export
  true_false=false
  cond_origin="${cond}"
  cond=".not. (${cond})"
  code=${code}
  message="${message}"
  cat << EOF
  <<assert-fortran>>
  EOF
#+end_src
~${cond}~ が ~.true.~ ならエラー.
#+name: assert-false
#+begin_src bash :exports code :var cond=".false." code="127" message="" :results output :noweb no-export
  true_false=false
  cond_origin="${cond}"
  cond="${cond}"
  code=${code}
  message="${message}"
  cat << EOF
  <<assert-fortran>>
  EOF
#+end_src
#+name: assert-eq
#+begin_src bash :exports code :var eq1="1" eq2="1" code="127" message="" :results output :noweb no-export
  true_false=false
  cond_origin="${eq1} == ${eq2}"
  cond=".not. (${cond_origin})"
  code=${code}
  message="${message}"
  cat << EOF
  <<assert-eq-fortran>>
  EOF
#+end_src
#+name: assert-test
#+begin_src fortran :exports code :noweb yes
  program hi
    use, intrinsic :: iso_fortran_env
    implicit none
    integer(int32) :: a = 1, b = 2
    <<assert-false(cond="2<1", code=1, message="in main")>>
    <<assert(cond="a < b", code=2, message="")>>
  end program hi
#+end_src

#+RESULTS: assert-test

* data structure
** COMMENT Comparable
*** whole module of comparable class
The children of =comparable= implement relational operators(=<=, =>=, =<==, =>==, ====, =/==).
The user of the child class must implement two operators (=<== and ===), (=<==, and =/==).
#+name: comparable-module
#+begin_src fortran :exports code :tangle "src/comparable_m.f90" :comments link :noweb no-export
  module comparable_m
    use, intrinsic :: iso_fortran_env
    implicit none
    private
    <<declaration-comparable>>
  contains
    <<procedures-comparable>>
  end module comparable_m
#+end_src
**** declaration of the comparable class
#+name: declaration-comparable
#+begin_src fortran :exports code
    public :: comparable
    type :: comparable
     contains
       procedure, pass :: less    => less_comparable
       procedure, pass :: less_equal    => less_equal_comparable
       procedure, pass :: greater => greater_comparable
       procedure, pass :: greater_equal => greater_equal_comparable
       procedure, pass :: equal => equal_comparable
       procedure, pass :: not_equal => not_equal_comparable
       generic :: operator(<) => less
       generic :: operator(<=) => less_equal
       generic :: operator(>) => greater
       generic :: operator(>=) => greater_equal
       generic :: operator(==) => equal
       generic :: operator(/=) => not_equal
    end type comparable
#+end_src
**** procedures of the comparable class
:PROPERTIES:
:header-args: :noweb-ref procedures-comparable
:END:
***** definition of <

The definition of =<= is given by =<== and =/==.
#+name: definition-less
#+begin_src fortran :exports code
  logical function less_comparable(lhs, rhs)
    class(comparable), intent(in) :: lhs
    class(comparable), intent(in) :: rhs
    less_comparable = (lhs <= rhs) .and. (lhs /= rhs)
  end function less_comparable
#+end_src
***** definition of <=

The definition of =<== must be overridden.
#+name: definition-less-equal
#+begin_src fortran :exports code
  logical function less_equal_comparable(lhs, rhs)
    class(comparable), intent(in) :: lhs
    class(comparable), intent(in) :: rhs
    error stop "You must implement less_equal in the child class of comparable."
  end function less_equal_comparable
#+end_src
***** definition of >

The definition of =>= is given by =<==.
#+name: definition-greater
#+begin_src fortran :exports code
  logical function greater_comparable(lhs, rhs)
    class(comparable), intent(in) :: lhs
    class(comparable), intent(in) :: rhs
    greater_comparable = .not. (lhs <= rhs)
  end function greater_comparable
#+end_src
***** definition of >=

The definition of =>== is given by ==== and =<==.
#+name: definition-greater-equal
#+begin_src fortran :exports code
  logical function greater_equal_comparable(lhs, rhs)
    class(comparable), intent(in) :: lhs
    class(comparable), intent(in) :: rhs
    greater_equal_comparable = (lhs == rhs) .or. (.not. (lhs <= rhs))
  end function greater_equal_comparable
#+end_src
***** definition of ==

The definition of ==== is given by =/==.
The definition of either ==== or =/== must be overridden.
#+name: definition-equal
#+begin_src fortran :exports code
  logical function equal_comparable(lhs, rhs)
    class(comparable), intent(in) :: lhs
    class(comparable), intent(in) :: rhs
    equal_comparable = .not. (lhs /= rhs)
  end function equal_comparable
#+end_src
***** definition of =/==

The definition of =/== is given by ====.
The definition of either ==== or =/== must be overridden.
#+name: definition-not-equal
#+begin_src fortran :exports code
  logical function not_equal_comparable(lhs, rhs)
    class(comparable), intent(in) :: lhs
    class(comparable), intent(in) :: rhs
    not_equal_comparable = .not. (lhs == rhs)
  end function not_equal_comparable
#+end_src
*** test
**** test module
#+name: comparable-test-module
#+begin_src fortran :exports code :tangle "test/test_comparable_m.F90" :comments link :noweb no-export
  module comparable_test_m
    use, intrinsic :: iso_fortran_env
    use comparable_m
    implicit none
    private
    public :: comp_int
    type, extends(comparable) :: comp_int
       integer(int32) :: val_
     contains
       procedure, pass :: val => val_comp_int
       procedure, pass :: less_equal => less_equal_comp_int
       procedure, pass :: equal => equal_comp_int
    end type comp_int
  contains
    pure integer(int32) function val_comp_int(this)
      class(comp_int), intent(in) :: this
      val_comp_int = this%val_
    end function val_comp_int
    logical function less_equal_comp_int(lhs, rhs)
      class(comp_int), intent(in) :: lhs
      class(comparable), intent(in) :: rhs
      <<assert(cond="same_type_as(lhs, rhs)", code=1, message="in comparable_test_m:less_equal_comp_int: Do not compare different types.")>>
      select type (rhs)
      type is (comp_int)
         less_equal_comp_int = lhs%val() <= rhs%val()
      end select
    end function less_equal_comp_int
    logical function equal_comp_int(lhs, rhs)
      class(comp_int), intent(in) :: lhs
      class(comparable), intent(in) :: rhs
      <<assert(cond="same_type_as(lhs, rhs)", code=2, message="in comparable_test_m:less_equal_comp_int: Do not compare different types.")>>
      select type (rhs)
      type is (comp_int)
         equal_comp_int = lhs%val() == rhs%val()
      end select
    end function equal_comp_int
  end module comparable_test_m
#+end_src
**** main
#+name: comparable-test
#+begin_src fortran :exports code :tangle "test/test_comparable.F90" :comments link :noweb no-export
  program test_comparable
    use, intrinsic :: iso_fortran_env
    use comparable_m
    use comparable_test_m
    implicit none
    type(comp_int) :: a
    class(comparable), pointer :: b
    a = comp_int(39)
    allocate(b, source = comp_int(42))
    <<assert(cond="a < b", code=1, message="in main")>>
    <<assert(cond="a <= b", code=2, message="in main")>>
    <<assert-false(cond="a >= b", code=3, message="in main")>>
    <<assert-false(cond="a > b", code=4, message="in main")>>
    <<assert(cond="a < b", code=5, message="in main")>>
    <<assert(cond="a <= a", code=6, message="in main")>>
    <<assert(cond="a == a", code=7, message="in main")>>
    <<assert-false(cond="a /= a", code=8, message="in main")>>
    <<assert-false(cond="b < a", code=9, message="in main")>>
    <<assert-false(cond="b <= a", code=10, message="in main")>>
    <<assert(cond="b >= a", code=11, message="in main")>>
    <<assert(cond="b > a", code=12, message="in main")>>
  end program test_comparable
#+end_src
**** whole test
#+begin_src fortran :flags -fbacktrace -g :exports code :results output :cache yes :noweb no-export
    <<comparable-module>>
    <<comparable-test-module>>
    <<comparable-test>>
#+end_src

#+RESULTS[4e7776f0a64b041373bc095de23aa0f5f3557984]:

** 参照カウントString(ref_string)
*** ref_string
**** ref_string
#+name: ref_string-module
#+begin_src fortran :exports code :tangle "src/ref_string_m.F90" :comment link :noweb no-export
  module ref_string_m
    use, intrinsic :: iso_fortran_env
    implicit none
    private string_row
    type :: string_row
       integer(int32) :: ref_cnt_ = 0_int32
       integer(int32) :: size_ = 0_int32
       character(len=:), allocatable :: str_
     contains
       ! `ref_string` has the responsibility for deallocating `string_row`.
       ! final :: destroy_string_row
    end type string_row
    private to_string_row
    type :: ref_string
       private
       type(string_row), pointer :: ptr_ => null()
     contains
       procedure, pass :: to_chars => ref_string_to_chars
       procedure, pass :: assign_ref_string, assign_string_row, assign_chars
       generic :: assignment(=) => assign_string_row, assign_chars
       procedure, pass :: rc => rc_ref_string
       procedure, pass :: write_ref_string
       generic :: write(formatted) => write_ref_string
       procedure, pass :: read_ref_string
       generic :: read(formatted) => read_ref_string
       final :: destroy_ref_string
    end type ref_string
    private init_ref_string_empty
    interface ref_string
       module procedure :: init_ref_string_empty
    end interface ref_string
    interface assignment(=)
       module procedure :: assign_ref_string_to_ref_string, assign_ref_string_to_chars, &
            assign_ref_string_to_ref_string_array, assign_chars_to_ref_string_array, &
            assign_ref_string_to_array_ref_string_array, assign_chars_array_to_ref_string_array
    end interface assignment(=)
    private equal_ref_string, not_equal_ref_string
    private less_ref_string, less_equal_ref_string, greater_ref_string, greater_equal_ref_string
    interface len
       module procedure :: len_ref_string
    end interface len
    interface operator(==)
       module procedure :: equal_ref_string
    end interface operator(==)
    interface operator(/=)
       module procedure :: not_equal_ref_string
    end interface operator(/=)
    interface operator(<)
       module procedure :: less_ref_string
    end interface operator(<)
    interface operator(<=)
       module procedure :: less_equal_ref_string
    end interface operator(<=)
    interface operator(>)
       module procedure :: greater_ref_string
    end interface operator(>)
    interface operator(>=)
       module procedure :: greater_equal_ref_string
    end interface operator(>=)
  contains
    !> to_string_row: convert `character(len=*)` to `string_row` and increment `ref_cnts_`.
    function to_string_row(chars) result(res)
      character(len=*), intent(in) :: chars
      type(string_row), pointer :: res
      allocate(res)
      allocate(res%str_, source = chars)
      res%size_ = len(chars)
      res%ref_cnt_ = 1_int32
    end function to_string_row
    !> ref_string_to_chars: convert `ref_string` to `character(len=*)`.
    function ref_string_to_chars(ref_str) result(res)
      class(ref_string), intent(in) :: ref_str
      character(len=:), allocatable :: res
      allocate(res, source = ref_str%ptr_%str_)
    end function ref_string_to_chars
    function init_ref_string_empty() result(res)
      type(ref_string) :: res
      nullify(res%ptr_)
    end function init_ref_string_empty

    elemental subroutine destroy_string_row(str_row)
      type(string_row), intent(inout) :: str_row
      ! write(error_unit, *) "ですとろーい `string_row`: ", str_row%ref_cnt_, str_row%str_
      str_row%ref_cnt_ = str_row%ref_cnt_ - 1
      if (str_row%ref_cnt_ == 0) then
         ! write(error_unit, *) "ですとろーいど `string_row: `", str_row%str_, loc(str_row%str_)
         deallocate(str_row%str_)
      end if
    end subroutine destroy_string_row
    elemental subroutine destroy_ref_string(ref_str)
      type(ref_string), intent(inout) :: ref_str
      if (.not. associated(ref_str%ptr_)) return
      ! write(error_unit, *) "ですとろーい `ref_string`: ", ref_str%rc(), ref_str
      call destroy_string_row(ref_str%ptr_)
      if (ref_str%rc() == 0) then
         ! write(error_unit, *) "ですとろーいど `ref_string`: ", loc(ref_str%ptr_), associated(ref_str%ptr_)
         deallocate(ref_str%ptr_)
      end if
      nullify(ref_str%ptr_)
    end subroutine destroy_ref_string

    integer(int32) function len_ref_string(ref_str) result(res)
      type(ref_string), intent(in) :: ref_str
      if (associated(ref_str%ptr_)) then
         res = 0_int32
      else
         res = ref_str%ptr_%size_
      end if
    end function len_ref_string
    subroutine assign_ref_string_to_ref_string(ref_str1, ref_str2)
      type(ref_string), intent(inout) :: ref_str1
      type(ref_string), intent(in) :: ref_str2
      call ref_str1%assign_ref_string(ref_str2)
    end subroutine assign_ref_string_to_ref_string
    subroutine assign_ref_string_to_ref_string_array(ref_str_arr, ref_str)
      type(ref_string), intent(inout) :: ref_str_arr(:)
      type(ref_string), intent(in) :: ref_str
      integer(int32) :: i
      do i = 1, size(ref_str_arr)
         call ref_str_arr(i)%assign_ref_string(ref_str)
      end do
    end subroutine assign_ref_string_to_ref_string_array
    subroutine assign_ref_string_to_array_ref_string_array(ref_str_arr1, ref_str_arr2)
      type(ref_string), intent(inout) :: ref_str_arr1(:)
      type(ref_string), intent(in) :: ref_str_arr2(:)
      integer(int32) :: i
      do i = 1, size(ref_str_arr1)
         call ref_str_arr1(i)%assign_ref_string(ref_str_arr2(i))
      end do
    end subroutine assign_ref_string_to_array_ref_string_array
    subroutine assign_chars_to_ref_string_array(ref_str, chars)
      type(ref_string), intent(inout) :: ref_str(:)
      character(len=*), intent(in) :: chars
      type(ref_string) :: s
      s = chars
      ref_str(:) = s
    end subroutine assign_chars_to_ref_string_array
    subroutine assign_chars_array_to_ref_string_array(ref_str_arr, chars_arr)
      type(ref_string), intent(inout) :: ref_str_arr(:)
      character(len=*), intent(in) :: chars_arr(:)
      integer(int32) :: i
      do i = 1, size(ref_str_arr)
         ref_str_arr(i) = chars_arr(i)
      end do
    end subroutine assign_chars_array_to_ref_string_array
    subroutine assign_ref_string(this, ref_str)
      class(ref_string), intent(inout) :: this
      type(ref_string), intent(in) :: ref_str
      type(string_row), pointer :: tmp
      tmp => this%ptr_
      if (associated(ref_str%ptr_)) then
         this%ptr_ => ref_str%ptr_
         this%ptr_%ref_cnt_ = this%ptr_%ref_cnt_ + 1
      else
         nullify(this%ptr_)
      end if
      if (associated(tmp)) &
           call destroy_string_row(tmp)
    end subroutine assign_ref_string
    subroutine assign_string_row(this, str_row)
      class(ref_string), intent(inout) :: this
      type(string_row), pointer, intent(in) :: str_row
      type(string_row), pointer :: tmp
      tmp => this%ptr_
      this%ptr_ => str_row
      if (associated(tmp)) &
           call destroy_string_row(tmp)
    end subroutine assign_string_row
    subroutine assign_chars(this, chars)
      class(ref_string), intent(inout) :: this
      character(len=*), intent(in) :: chars
      this = to_string_row(chars)
    end subroutine assign_chars
    subroutine assign_ref_string_to_chars(chars, ref_str)
      character(len=*), intent(inout) :: chars
      type(ref_string), intent(in) :: ref_str
      if (.not. associated(ref_str%ptr_)) &
           return
      if (len(chars) < len(ref_str)) then
         chars(1:len(chars)) = ref_str%ptr_%str_(1:len(chars))
      else
         chars(1:len(ref_str)) = ref_str%ptr_%str_
      end if
    end subroutine assign_ref_string_to_chars
    pure integer(int32) function rc_ref_string(this) result(res)
      class(ref_string), intent(in) :: this
      if (associated(this%ptr_)) then
         res = this%ptr_%ref_cnt_
      else
         res = -1_int32
      end if
    end function rc_ref_string

    pure elemental logical function equal_ref_string(lhs, rhs) result(res)
      type(ref_string), intent(in) :: lhs, rhs
      res = lhs%ptr_%str_ == rhs%ptr_%str_
    end function equal_ref_string
    pure elemental logical function not_equal_ref_string(lhs, rhs) result(res)
      type(ref_string), intent(in) :: lhs, rhs
      res = .not. (lhs == rhs)
    end function not_equal_ref_string
    pure elemental logical function less_ref_string(lhs, rhs) result(res)
      type(ref_string), intent(in) :: lhs, rhs
      res = lhs%ptr_%str_ < rhs%ptr_%str_
    end function less_ref_string
    pure elemental logical function less_equal_ref_string(lhs, rhs) result(res)
      type(ref_string), intent(in) :: lhs, rhs
      res = lhs%ptr_%str_ <= rhs%ptr_%str_
    end function less_equal_ref_string
    pure elemental logical function greater_ref_string(lhs, rhs) result(res)
      type(ref_string), intent(in) :: lhs, rhs
      res = .not. (lhs <= rhs)
    end function greater_ref_string
    pure elemental logical function greater_equal_ref_string(lhs, rhs) result(res)
      type(ref_string), intent(in) :: lhs, rhs
      res = .not. (lhs < rhs)
    end function greater_equal_ref_string

    subroutine write_ref_string(this, unit, iotype, vlist, iostat, iomsg)
      class(ref_string), intent(in) :: this
      integer(int32), intent(in) :: unit
      character(len=*), intent(in) :: iotype
      integer(int32), intent(in) :: vlist(:)
      integer(int32), intent(out) :: iostat
      character(len=*), intent(inout) :: iomsg
      if (associated(this%ptr_)) then
         if (iotype == "LISTDIRECTED" .or. size(vlist) == 0) then
            write(unit, *, iostat = iostat, iomsg = iomsg) this%ptr_%str_
         else if (iotype(3:) == "ref_string" .or. iotype(3:) == "a") then
            block
              character(len=10) :: width
              character(len=:), allocatable :: fmt
              if (size(vlist) == 0) then
                 allocate(fmt, source = '(a)')
              else
                 write(width, '(i0)') vlist(1)
                 allocate(fmt, source = '(a'//trim(width)//')')
              end if
              write(unit, fmt, iostat = iostat, iomsg = iomsg) this%ptr_%str_
            end block
         else
            ! iostat = -1
            ! iomsg = "The type `"//iotype//"` is not supported in ref_string."
            write(error_unit, '(a)') "The type `"//iotype//"` is not supported in ref_string."
            error stop 2
         end if
      else
         write(unit, *, iostat = iostat, iomsg = iomsg)
      end if
    end subroutine write_ref_string

    subroutine read_ref_string(this, unit, iotype, vlist, iostat, iomsg)
      class(ref_string), intent(inout) :: this
      integer(int32), intent(in) :: unit
      character(len=*), intent(in) :: iotype
      integer(int32), intent(in) :: vlist(:)
      integer(int32), intent(out) :: iostat
      character(len=*), intent(inout) :: iomsg
      type(string_row), pointer :: tmp
      tmp => this%ptr_
      if (associated(this%ptr_)) then
         if (iotype == "LISTDIRECTED" .or. size(vlist) == 0) then
            write(unit, *, iostat = iostat, iomsg = iomsg) this%ptr_%str_
         else if (iotype(3:) == "ref_string" .or. iotype(3:) == "a") then
            block
              character(len=10) :: width
              character(len=:), allocatable :: fmt
              if (size(vlist) == 0) then
                 allocate(fmt, source = '(a)')
              else
                 write(width, '(i0)') vlist(1)
                 allocate(fmt, source = '(a'//trim(width)//')')
              end if
              write(unit, fmt, iostat = iostat, iomsg = iomsg) this%ptr_%str_
            end block
         else
            ! iostat = -1
            ! iomsg = "The type `"//iotype//"` is not supported in ref_string."
            write(error_unit, '(a)') "The type `"//iotype//"` is not supported in ref_string."
            error stop 2
         end if
      else
         write(unit, *, iostat = iostat, iomsg = iomsg)
      end if
      if (associated(tmp)) &
           call destroy_string_row(tmp)
    end subroutine read_ref_string
  end module ref_string_m
#+end_src
**** test
***** testコードブロック
#+name: test-ref_string
#+begin_src fortran :flags "-cpp -g -fbacktrace -fcheck=bounds" :exports code :results output :noweb no-export :cache yes
<<ref_string-module>>
<<ref_string-test>>
#+end_src

#+RESULTS[cd098fb629022bc4dcf70659d6e4af3d4368abb9]: test-ref_string

***** test本体
#+name: ref_string-test
#+begin_src fortran :exports code :tangle "test/test_ref_string.F90" :noweb no-export
  program test_ref_string
    use, intrinsic :: iso_fortran_env
    use ref_string_m
    implicit none
    integer(int32), parameter :: n = 100
    call compare_same_length()
    call compare_different_length()
    call test_array(n)
    call test_array_assignment(n)
    call test_array_elemental_compare(n)
  contains
    <<test-ref_string-compare-same-length>>
    <<test-ref_string-compare-different-length>>
    <<test-ref_string-array>>
    <<test-ref_string-array-assignment>>
    <<test-ref_string-array-elemental-compare>>
  end program test_ref_string
#+end_src
****** 同じ文字数での比較
#+name:test-ref_string-compare-same-length
#+begin_src fortran :exports code :noweb no-export
  subroutine compare_same_length()
    type(ref_string) :: s1, s2
    s1 = "hi"
    <<assert(cond="s1 == s1",       code=10, message="`==` for ref_string is illegal.")>>
    <<assert-false(cond="s1 /= s1", code=11, message="`/=` for ref_string is illegal.")>>
    <<assert-false(cond="s1 < s1",  code=12, message="`<` for ref_string is illegal.")>>
    <<assert(cond="s1 >= s1",       code=13, message="`>=` for ref_string is illegal.")>>
    <<assert-false(cond="s1 > s1",  code=14, message="`>` for ref_string is illegal.")>>
    <<assert(cond="s1 <= s1",       code=15, message="`<=` for ref_string is illegal.")>>
    s2 = "hz"
    <<assert-false(cond="s1 == s2", code=20, message="`==` for ref_string is illegal.")>>
    <<assert(cond="s1 /= s2",       code=21, message="`/=` for ref_string is illegal.")>>
    <<assert(cond="s1 < s2",        code=22, message="`<` for ref_string is illegal.")>>
    <<assert-false(cond="s1 >= s2", code=23, message="`>=` for ref_string is illegal.")>>
    <<assert-false(cond="s1 > s2",  code=24, message="`>` for ref_string is illegal.")>>
    <<assert(cond="s1 <= s2",       code=25, message="`<=` for ref_string is illegal.")>>
    s2 = "zi"
    <<assert-false(cond="s1 == s2", code=30, message="`==` for ref_string is illegal.")>>
    <<assert(cond="s1 /= s2",       code=31, message="`/=` for ref_string is illegal.")>>
    <<assert(cond="s1 < s2",        code=32, message="`<` for ref_string is illegal.")>>
    <<assert-false(cond="s1 >= s2", code=33, message="`>=` for ref_string is illegal.")>>
    <<assert-false(cond="s1 > s2",  code=34, message="`>` for ref_string is illegal.")>>
    <<assert(cond="s1 <= s2",       code=35, message="`<=` for ref_string is illegal.")>>
    s2 = "ha"
    <<assert-false(cond="s1 == s2", code=40, message="`==` for ref_string is illegal.")>>
    <<assert(cond="s1 /= s2",       code=41, message="`/=` for ref_string is illegal.")>>
    <<assert-false(cond="s1 < s2",  code=42, message="`<` for ref_string is illegal.")>>
    <<assert(cond="s1 >= s2",       code=43, message="`>=` for ref_string is illegal.")>>
    <<assert(cond="s1 > s2",        code=44, message="`>` for ref_string is illegal.")>>
    <<assert-false(cond="s1 <= s2", code=45, message="`<=` for ref_string is illegal.")>>
  end subroutine compare_same_length
#+end_src
****** 異なる文字数での比較
#+name:test-ref_string-compare-different-length
#+begin_src fortran :exports code :noweb no-export
  subroutine compare_different_length()
    type(ref_string) :: s1, s2
    s1 = "special"
    s2 = "specialize"
    <<assert-false(cond="s1 == s2", code=20, message="`==` for ref_string is illegal.")>>
    <<assert(cond="s1 /= s2",       code=21, message="`/=` for ref_string is illegal.")>>
    <<assert(cond="s1 < s2",        code=22, message="`<` for ref_string is illegal.")>>
    <<assert-false(cond="s1 >= s2", code=23, message="`>=` for ref_string is illegal.")>>
    <<assert-false(cond="s1 > s2",  code=24, message="`>` for ref_string is illegal.")>>
    <<assert(cond="s1 <= s2",       code=25, message="`<=` for ref_string is illegal.")>>
    s2 = "z"
    <<assert-false(cond="s1 == s2", code=30, message="`==` for ref_string is illegal.")>>
    <<assert(cond="s1 /= s2",       code=31, message="`/=` for ref_string is illegal.")>>
    <<assert(cond="s1 < s2",        code=32, message="`<` for ref_string is illegal.")>>
    <<assert-false(cond="s1 >= s2", code=33, message="`>=` for ref_string is illegal.")>>
    <<assert-false(cond="s1 > s2",  code=34, message="`>` for ref_string is illegal.")>>
    <<assert(cond="s1 <= s2",       code=35, message="`<=` for ref_string is illegal.")>>
    s2 = "spec"
    <<assert-false(cond="s1 == s2", code=40, message="`==` for ref_string is illegal.")>>
    <<assert(cond="s1 /= s2",       code=41, message="`/=` for ref_string is illegal.")>>
    <<assert-false(cond="s1 < s2",  code=42, message="`<` for ref_string is illegal.")>>
    <<assert(cond="s1 >= s2",       code=43, message="`>=` for ref_string is illegal.")>>
    <<assert(cond="s1 > s2",        code=44, message="`>` for ref_string is illegal.")>>
    <<assert-false(cond="s1 <= s2", code=45, message="`<=` for ref_string is illegal.")>>
  end subroutine compare_different_length
#+end_src
****** ref_stringの配列
#+name:test-ref_string-array
#+begin_src fortran :exports code :noweb no-export
  !> gfortran-12.2.0ではコンパイラのバグ?でエラー, gfortran-13.2.0ではコンパイルできる.
  subroutine test_array(n)
    integer(int32), intent(in) :: n
    type(ref_string) :: ref_str_array(n)
    ! ref_str_array(:) = "Hi"
  end subroutine test_array
#+end_src
****** ref_stringの配列への代入
#+name:test-ref_string-array-assignment
#+begin_src fortran :exports code :noweb no-export
  subroutine test_array_assignment(n)
    integer(int32), intent(in) :: n
    type(ref_string), allocatable :: s1(:)
    integer(int32) :: i
    block
      type(ref_string) :: s
      s = "hi"
      allocate(s1(n))
      do i = 1, n
         s1(i) = s
      end do
      <<assert-eq(eq1="s1(1)%rc()", eq2="n+1", code=70, message="Assignment of array of ref_string has something wrong.")>>
    end block
    <<assert-eq(eq1="s1(1)%rc()", eq2="n", code=71, message="Destructor of ref_string has something wrong.")>>
    block
      type(ref_string) :: s
      s = "hoi"
      s1(:) = s
      <<assert-eq(eq1="s1(1)%rc()", eq2="n+1", code=72, message="Assignment of array of ref_string has something wrong.")>>
    end block
    <<assert-eq(eq1="s1(1)%rc()", eq2="n", code=73, message="Destructor of ref_string has something wrong.")>>
    block
      character(len=100) :: s
      s = "Hello, World!"
      s1(:) = trim(s)
      <<assert-eq(eq1="s1(1)%rc()", eq2="n", code=74, message="Assignment of array of ref_string has something wrong.")>>
    end block
    <<assert-eq(eq1="s1(1)%rc()", eq2="n", code=75, message="Destructor of ref_string has something wrong.")>>
    block
      integer(int32), parameter :: max_len = 5
      character(len=5), parameter :: chars_arr(max_len) = ["a    ", "aa   ", "a    ", "bcdef", " hi  "]
      type(ref_string) :: ref_str_arr(max_len)
      integer(int32) :: i
      ref_str_arr(:) = chars_arr(:)
      do i = 1, size(ref_str_arr)
         <<assert-eq(eq1="ref_str_arr(i)%rc()", eq2="1", code=76, message="Assignment of character array to ref_string array has something wrong.")>>
      end do
    end block
  end subroutine test_array_assignment
#+end_src
****** ref_stringの配列同士の比較
#+name:test-ref_string-array-elemental-compare
#+begin_src fortran :exports code :noweb no-export
  subroutine test_array_elemental_compare(n)
    integer(int32), intent(in) :: n
    type(ref_string), allocatable :: s1(:)
    integer(int32) :: i
    block
      type(ref_string) :: s
      s = "hi"
      allocate(s1(n))
      do i = 1, n
         s1(i) = s
      end do
      <<assert(cond="all(s1(:) == s1(:))", code=80, message="Comparison of array of ref_string has something wrong.")>>
    end block
    block
      type(ref_string), allocatable :: s2(:)
      allocate(s2(n))
      s1(n/2) = "spec"
      s2(:) = s1(:)
    end block
    block
      type(ref_string), allocatable :: s2(:)
      allocate(s2(n))
      s2(:) = s1(:)
      s2(n/2) = "special"
      <<assert-false(cond="all(s1(:) == s2(:))", code=81, message="Comparison of array of ref_string has something wrong.")>>
      <<assert-eq(eq1="s1(1)%rc()", eq2="2*n-2", code=82, message="Assignment of array of ref_string has something wrong.")>>
      <<assert-eq(eq1="s1(n/2)%rc()", eq2="1", code=83, message="Assignment of array of ref_string has something wrong.")>>
    end block
    <<assert-eq(eq1="s1(1)%rc()", eq2="n-1", code=84, message="Destructor of array of ref_string has something wrong.")>>
  end subroutine test_array_elemental_compare
#+end_src
*** ref_stringのmerge_sort
#+name: ref_string-merge-sort-module
#+begin_src fortran :exports code :noweb yes :tangle "src/ref_string_merge_sort_m.f90"
  module ref_string_merge_sort_m
    use, intrinsic :: iso_fortran_env
    use ref_string_m
    implicit none
    private
    public :: merge_sort, merge_sort_descending
    <<declaration-merge_sort-var(type_base="type", type_kind="ref_string")>>
  contains
    <<procedures-merge_sort-var(type_base="type", type_kind="ref_string")>>
  end module ref_string_merge_sort_m
#+end_src
**** test
***** testコードブロック
#+name: test-ref_string-merge-sort
#+begin_src fortran :exports code :results output :cache yes :noweb yes
  <<ref_string-module>>
  <<ref_string-merge-sort-module>>
  <<ref_string-merge-sort-test>>
#+end_src

#+RESULTS[65a4576aa867029b4fb0f9f9c3562fa9e4bc8543]: test-ref_string-merge-sort
: a      ab     abc    ba     bb     z      zabcd
: zabcd  z      bb     ba     abc    ab     a

***** test本体
#+name: ref_string-merge-sort-test
#+begin_src fortran :exports code :tangle "test/test_ref_string_merge_sort.f90" :noweb yes
  program test_ref_string_merge_sort
    use, intrinsic :: iso_fortran_env
    use ref_string_m
    use ref_string_merge_sort_m
    implicit none
    integer(int32), parameter :: n = 7
    type(ref_string), allocatable :: arr(:), sorted(:)
    character(len=5), parameter :: chars_sorted(n) = &
         ["a    ", "ab   ", "abc  ", "ba   ", "bb   ", "z    ", "zabcd"]
    integer(int32), allocatable :: indices(:)
    integer(int32) :: i
    allocate(arr(n))
    arr(:) = chars_sorted([3, 1, 5, 7, 2, 4, 6])
    allocate(sorted(n))
    sorted(:) = chars_sorted(:)
    indices = [(i, i = 1, n)]
    call merge_sort(arr, indices)
    <<assert(cond="all(arr(:) == sorted(:))", code=11, message="merge_sort with key is illegal.")>>
    <<assert(cond="all(indices(:) == [2, 5, 1, 6, 3, 7, 4])", code=12, message="merge_sort with key is illegal.")>>
    do i = 1, n
       <<assert(eq1="arr(i)%rc()", eq2="2", code=13, message="merge_sort with key of ref_string has something wrong.")>>
    end do
    call merge_sort_descending(arr)
    <<assert(cond="all(arr(:) == sorted(n:1:-1))", code=21, message="merge_sort_descending is illegal.")>>
    write(output_unit, *) arr(n:1:-1)
    write(output_unit, *) arr(:)
  end program test_ref_string_merge_sort
#+end_src
*** ref_stringのunwrapped_vector
#+name: ref_string-unwrapped-module
#+begin_src fortran :exports code :tangle "src/ref_string_unwrapped_vector_m.F90" :comment link :noweb no-export
  module ref_string_unwrapped_vector_m
    use, intrinsic :: iso_fortran_env
    use ref_string_m
    implicit none
    <<declaration-unwrapped_vector-var(type="type", type_kind="ref_string")>>
  contains
    <<procedures-unwrapped_vector-var(type="type", type_kind="ref_string")>>
  end module ref_string_unwrapped_vector_m
#+end_src
*** ref_stringのB木
#+name: ref_string-btree-module
#+begin_src fortran :exports code :tangle "src/ref_string_btree_m.F90" :comment link :noweb no-export
  module ref_string_btree_m
    use, intrinsic :: iso_fortran_env
    use ref_string_m
    implicit none
    private
    !> `t-1` must be the least number of elements in `btree_node` without root (minimum degree).
    integer(int32), parameter :: t = 6
    !> the number of internal node in `btree_node`.
    integer(int32), parameter :: inode = 2*t-1
    integer(int32), parameter :: iter_max_depth = 30
    <<declaration-btree-var(key_base="type", key_kind="ref_string", val_base="integer", val_kind="int32")>>
    <<declaration-btree-var(key_base="type", key_kind="ref_string", val_base="integer", val_kind="int64")>>
    <<declaration-btree-var(key_base="type", key_kind="ref_string", val_base="type", val_kind="ref_string")>>
  contains
    <<procedures-btree-var(key_base="type", key_kind="ref_string", val_base="integer", val_kind="int32")>>
    <<procedures-btree-var(key_base="type", key_kind="ref_string", val_base="integer", val_kind="int64")>>
    <<procedures-btree-var(key_base="type", key_kind="ref_string", val_base="type", val_kind="ref_string")>>
  end module ref_string_btree_m
#+end_src
**** test
***** testコードブロック
#+name: test-ref_string-btree
#+begin_src fortran :exports code :results output :cache yes :noweb yes
  <<ref_string-module>>
  <<ref_string-btree-module>>
  <<ref_string-btree-test>>
#+end_src

#+RESULTS[88b254bd9688ac19ffba7d29a89fbee2480b4237]: test-ref_string-btree
: 7

***** test本体
#+name: ref_string-btree-test
#+begin_src fortran :exports code :tangle "test/test_ref_string_btree_m.F90" :comment link :noweb no-export
  program test_ref_string_btree
    use, intrinsic :: iso_fortran_env
    use ref_string_m
    use ref_string_btree_m
    implicit none
    integer(int32), parameter :: n = 7
    type(ref_string) :: rs
    type(ref_string), allocatable :: arr(:), sorted(:)
    type(btree_ref_string_to_int32) :: bt
    character(len=5), parameter :: chars_sorted(n) = &
         ["a    ", "ab   ", "abc  ", "ba   ", "bb   ", "z    ", "zabcd"]
    integer(int32), allocatable :: indices(:)
    integer(int32) :: i
    call bt%init()
    do i = 1, n
       rs = trim(chars_sorted(i))
       call bt%insert(rs, i)
    end do
    write(output_unit, *) bt%get(rs)
    <<assert-eq(eq1="bt%size()", eq2="n", code=21, message="merge_sort_descending is illegal.")>>
  end program test_ref_string_btree
#+end_src

** Tuple
*** Tuple2
**** Tuple2モジュール全体
#+name: tuple2-module
#+begin_src fortran :exports code :tangle "src/tuple2_m.F90" :comment link :noweb no-export
  module tuple2_m
    use, intrinsic :: iso_fortran_env
    implicit none
    <<declaration-tuple2-var(type1="integer", type1_kind="int32", type2="integer", type2_kind="int32")>>
    <<declaration-tuple2-var(type1="integer", type1_kind="int64", type2="integer", type2_kind="int64")>>
    <<declaration-tuple2-var(type1="real", type1_kind="real32", type2="integer", type2_kind="int32")>>
    <<declaration-tuple2-var(type1="real", type1_kind="real64", type2="integer", type2_kind="int64")>>
  contains
    <<procedures-tuple2-var(type1="integer", type1_kind="int32", type2="integer", type2_kind="int32")>>
    <<procedures-tuple2-var(type1="integer", type1_kind="int64", type2="integer", type2_kind="int64")>>
    <<procedures-tuple2-var(type1="real", type1_kind="real32", type2="integer", type2_kind="int32")>>
    <<procedures-tuple2-var(type1="real", type1_kind="real64", type2="integer", type2_kind="int64")>>
  end module tuple2_m
#+end_src
**** Tuple2の宣言
まず, 型 ~${tuple2}~ の宣言を行う.
~${tuple2}~ は2つの要素を持つ.
2つの要素の型は異なる型でも構わない.
単純でよく知られている型なのでカプセル化を行うメリットはない.

変数 ~${variable}~ は =bash= で展開される.
- ~${tuple2}~ は Tuple2型.
- ~${type1}~ は Tuple2型の一番目の型.
- ~${type2}~ は Tuple2型の二番目の型.
#+name: declaration-tuple2
#+begin_src fortran :exports code
  public :: ${tuple2}
  type :: ${tuple2}
     ${type1} :: v1_
     ${type2} :: v2_
  end type ${tuple2}
  private :: construct_${tuple2}
  interface ${tuple2}
     module procedure :: construct_${tuple2}
  end interface ${tuple2}
  interface operator(<)
     module procedure :: less_${tuple2}
  end interface operator(<)
  interface operator(<=)
     module procedure :: less_equal_${tuple2}
  end interface operator(<=)
  interface operator(>)
     module procedure :: greater_${tuple2}
  end interface operator(>)
  interface operator(>=)
     module procedure :: greater_equal_${tuple2}
  end interface operator(>=)
  interface operator(==)
     module procedure :: equal_${tuple2}
  end interface operator(==)
  interface operator(/=)
     module procedure :: not_equal_${tuple2}
  end interface operator(/=)
#+end_src
**** Tuple2の関数とか
:PROPERTIES:
:header-args: :noweb-ref procedures-tuple2
:END:
***** constructor
=function construct= は Tuple2型を生成する.
#+name: construct-tuple2
#+begin_src fortran :exports code
  !> construct_${tuple2}_by_size: Construct ${tuple2}.
  impure function construct_${tuple2}(val1, val2) result(res)
    type(${tuple2}) :: res
    ${type1}, intent(in) :: val1
    ${type2}, intent(in) :: val2
    res%v1_ = val1
    res%v2_ = val2
  end function construct_${tuple2}
#+end_src
***** compare_operator
比較演算子たち.
#+name: compare-tuple2
#+begin_src fortran :exports code :noweb no-export
  !> less_${tuple2}: Compare the first elements.
  !> Compare the second elements if the first elements are same.
  pure logical function less_${tuple2}(lhs, rhs) result(res)
    type(${tuple2}), intent(in) :: lhs, rhs
    res = lhs%v1_ < rhs%v1_
    if (lhs%v1_ == rhs%v1_) then
       res = lhs%v2_ < rhs%v2_
    end if
  end function less_${tuple2}
  pure logical function less_equal_${tuple2}(lhs, rhs) result(res)
    type(${tuple2}), intent(in) :: lhs, rhs
    res = lhs%v1_ < rhs%v1_
    if (lhs%v1_ == rhs%v1_) then
       res = lhs%v2_ <= rhs%v2_
    end if
  end function less_equal_${tuple2}
  pure logical function greater_${tuple2}(lhs, rhs) result(res)
    type(${tuple2}), intent(in) :: lhs, rhs
    res = lhs%v1_ > rhs%v1_
    if (lhs%v1_ == rhs%v1_) then
       res = lhs%v2_ > rhs%v2_
    end if
  end function greater_${tuple2}
  pure logical function greater_equal_${tuple2}(lhs, rhs) result(res)
    type(${tuple2}), intent(in) :: lhs, rhs
    res = lhs%v1_ > rhs%v1_
    if (lhs%v1_ == rhs%v1_) then
       res = lhs%v2_ >= rhs%v2_
    end if
  end function greater_equal_${tuple2}
  pure logical function equal_${tuple2}(lhs, rhs) result(res)
    type(${tuple2}), intent(in) :: lhs, rhs
    res = lhs%v1_ == rhs%v1_ .and. lhs%v2_ == rhs%v2_
  end function equal_${tuple2}
  pure logical function not_equal_${tuple2}(lhs, rhs) result(res)
    type(${tuple2}), intent(in) :: lhs, rhs
    res = lhs%v1_ /= rhs%v1_ .or. lhs%v2_ /= rhs%v2_
  end function not_equal_${tuple2}
#+end_src
**** Tuple2の展開
#+name: tuple2-var
#+begin_src bash :exports code :cache no :shebang #!/bin/bash
  suffix=""
  case "${type1}" in
      "character")
          type1="character"
          suffix="${suffix}_character"
          ;;
      "type")
          type1="type(${type1_kind})"
          suffix="${suffix}_${type1_kind}"
          ;;
      ,*)
          type1="${type1}(${type1_kind})"
          suffix="${suffix}_${type1_kind}"
          ;;
  esac
  case "${type2}" in
      "character")
          type2="character"
          suffix="${suffix}_character"
          ;;
      "type")
          type2="type(${type2_kind})"
          suffix="${suffix}_${type2_kind}"
          ;;
      ,*)
          type2="${type2}(${type2_kind})"
          suffix="${suffix}_${type2_kind}"
          ;;
  esac
  tuple2="tuple2${suffix}"
#+end_src
#+name: declaration-tuple2-var
#+begin_src bash :exports code :var type1="integer" type1_kind="int32" type2="integer" type2_kind="int32" :results output :noweb no-export :cache no :shebang #!/bin/bash
  <<tuple2-var>>
  cat <<EOF
  <<declaration-tuple2>>
  EOF
#+end_src
#+name: procedures-tuple2-var
#+begin_src bash :exports code :var type1="integer" type1_kind="int32" type2="integer" type2_kind="int32" :results output :noweb no-export :cache no :shebang #!/bin/bash
  <<tuple2-var>>
  cat <<EOF
  <<procedures-tuple2>>
  EOF
#+end_src
**** test
***** testコードブロック
#+name: test-tuple2
#+begin_src fortran :flags "-cpp -g -fbacktrace -fcheck=bounds" :exports code :results output :noweb no-export :cache yes
<<tuple2-module>>
<<tuple2-test>>
#+end_src

#+RESULTS[22d5d6b4b7ba0276b12c4c5762a4a15386809f5e]: test-tuple2

***** test本体
#+name: tuple2-test
#+begin_src fortran :exports code :tangle "test/test_tuple2.F90" :noweb no-export
  program test_tuple2
    use, intrinsic :: iso_fortran_env
    use tuple2_m, only: tup2 => tuple2_int32_int32, &
         operator(==), operator(/=), operator(<), operator(<=), operator(>), operator(>=)
    implicit none
    type(tup2) :: t1, t2
    t1 = tup2(1, 1)
    <<assert(cond="t1 == t1",       code=10, message="`==` for Tuple2 is illegal.")>>
    <<assert-false(cond="t1 /= t1", code=11, message="`/=` for Tuple2 is illegal.")>>
    <<assert-false(cond="t1 < t1",  code=12, message="`<` for Tuple2 is illegal.")>>
    <<assert(cond="t1 >= t1",       code=13, message="`>=` for Tuple2 is illegal.")>>
    <<assert-false(cond="t1 > t1",  code=14, message="`>` for Tuple2 is illegal.")>>
    <<assert(cond="t1 <= t1",       code=15, message="`<=` for Tuple2 is illegal.")>>
    t2 = tup2(1, 2)
    <<assert-false(cond="t1 == t2", code=20, message="`==` for Tuple2 is illegal.")>>
    <<assert(cond="t1 /= t2",       code=21, message="`/=` for Tuple2 is illegal.")>>
    <<assert(cond="t1 < t2",        code=22, message="`<` for Tuple2 is illegal.")>>
    <<assert-false(cond="t1 >= t2", code=23, message="`>=` for Tuple2 is illegal.")>>
    <<assert-false(cond="t1 > t2",  code=24, message="`>` for Tuple2 is illegal.")>>
    <<assert(cond="t1 <= t2",       code=25, message="`<=` for Tuple2 is illegal.")>>
    t2 = tup2(100, 2)
    <<assert-false(cond="t1 == t2", code=30, message="`==` for Tuple2 is illegal.")>>
    <<assert(cond="t1 /= t2",       code=31, message="`/=` for Tuple2 is illegal.")>>
    <<assert(cond="t1 < t2",        code=32, message="`<` for Tuple2 is illegal.")>>
    <<assert-false(cond="t1 >= t2", code=33, message="`>=` for Tuple2 is illegal.")>>
    <<assert-false(cond="t1 > t2",  code=34, message="`>` for Tuple2 is illegal.")>>
    <<assert(cond="t1 <= t2",       code=35, message="`<=` for Tuple2 is illegal.")>>
    t2 = tup2(1, -100)
    <<assert-false(cond="t1 == t2", code=40, message="`==` for Tuple2 is illegal.")>>
    <<assert(cond="t1 /= t2",       code=41, message="`/=` for Tuple2 is illegal.")>>
    <<assert-false(cond="t1 < t2",  code=42, message="`<` for Tuple2 is illegal.")>>
    <<assert(cond="t1 >= t2",       code=43, message="`>=` for Tuple2 is illegal.")>>
    <<assert(cond="t1 > t2",        code=44, message="`>` for Tuple2 is illegal.")>>
    <<assert-false(cond="t1 <= t2", code=45, message="`<=` for Tuple2 is illegal.")>>
  end program test_tuple2
#+end_src
**** Tuple2のunwrapped_vector
#+name: tuple2-unwrapped-module
#+begin_src fortran :exports code :tangle "src/tuple2_unwrapped_vector_m.F90" :comment link :noweb no-export
  module tuple2_unwrapped_vector_m
    use, intrinsic :: iso_fortran_env
    use tuple2_m
    implicit none
    <<declaration-unwrapped_vector-var(type="type", type_kind="tuple2_int32_int32")>>
    <<declaration-unwrapped_vector-var(type="type", type_kind="tuple2_int64_int64")>>
  contains
    <<procedures-unwrapped_vector-var(type="type", type_kind="tuple2_int32_int32")>>
    <<procedures-unwrapped_vector-var(type="type", type_kind="tuple2_int64_int64")>>
  end module tuple2_unwrapped_vector_m
#+end_src
**** Tuple2のB木
#+name: tuple2-btree-module
#+begin_src fortran :exports code :tangle "src/tuple2_btree_m.F90" :comment link :noweb no-export
  module tuple2_btree_m
    use, intrinsic :: iso_fortran_env
    use tuple2_m, only: &
         t2_i32_i32 => tuple2_int32_int32, &
         t2_i64_i64 => tuple2_int64_int64, &
         operator(==), operator(<), operator(<=), operator(>), operator(>=)
    implicit none
    private
    !> `t-1` must be the least number of elements in `btree_node` without root (minimum degree).
    integer(int32), parameter :: t = 6
    !> the number of internal node in `btree_node`.
    integer(int32), parameter :: inode = 2*t-1
    integer(int32), parameter :: iter_max_depth = 30
    <<declaration-btree-var(key_base="type", key_kind="t2_i32_i32", val_base="integer", val_kind="int32")>>
    <<declaration-btree-var(key_base="type", key_kind="t2_i64_i64", val_base="integer", val_kind="int64")>>
  contains
    <<procedures-btree-var(key_base="type", key_kind="t2_i32_i32", val_base="integer", val_kind="int32")>>
    <<procedures-btree-var(key_base="type", key_kind="t2_i64_i64", val_base="integer", val_kind="int64")>>
  end module tuple2_btree_m
#+end_src
***** test
#+name: test-tuple2-btree
#+begin_src fortran :flags "-cpp -g -fbacktrace -fcheck=bounds" :exports code :results output file :file "t2_btree.log" :noweb no-export :cache yes
    <<tuple2-module>>
    <<tuple2-btree-module>>
    <<tuple2-btree-test>>
#+end_src

#+RESULTS[64152e545a438a641ba6d7a09548f6bf1189cb33]: test-tuple2-btree
[[file:t2_btree.log]]

#+name: tuple2-btree-test
#+begin_src fortran :exports code :tangle "test/test_tuple2_btree_m.F90" :comment link :noweb no-export
  program test_tuple2_btree_m
    use, intrinsic :: iso_fortran_env
    use tuple2_m!, only: t2 => tuple2_int32_int32
    use tuple2_btree_m, only: bt_t2_to_int32 => btree_t2_i32_i32_to_int32, &
         bt_iter_t2_to_int32 => btree_node_iter_t2_i32_i32_to_int32
    implicit none
    integer(int32), parameter :: n = 1000
    call tuple2_btree_test_insertion_ascending(n)
  contains
    <<tuple2_btree-test-check_insertion_ascending>>
  end program test_tuple2_btree_m
#+end_src
****** 昇順に挿入.
#+name: tuple2_btree-test-check_insertion_ascending
#+begin_src fortran :exports code :noweb no-export
  subroutine tuple2_btree_test_insertion_ascending(n)
    integer(int32), intent(in) :: n
    type(bt_t2_to_int32) :: m
    type(bt_iter_t2_to_int32) :: iter
    type(tuple2_int32_int32) :: t
    integer(int32) :: i, j
    call m%init()
    do i = 1, n
       do j = 1, n
          call m%insert(tuple2_int32_int32(i, j), i+j)
       end do
    end do
    <<assert-eq(eq1="m%size()", eq2="int(n, int64)*n", code=11, message="Btree method `insert` are something wrong.")>>
    call m%check_invariant()
    do i = 1, n
       do j = 1, n
          call m%remove(tuple2_int32_int32(i, j))
       end do
    end do
    <<assert-eq(eq1="m%size()", eq2="0", code=12, message="Btree method `remove` are something wrong.")>>
    do i = 1, n
       do j = 1, n
          call m%insert(tuple2_int32_int32(i, j), i+j)
       end do
    end do
    iter = m%minimum_iter()
    do while (iter%is_not_end())
       t = iter%key()
       ! write(output_unit, '(*(i0, 1x))') t%fst(), t%snd()
       <<assert-eq(eq1="t%fst()+t%snd()", eq2="iter%val()", code=12, message="Btree iter is something wrong.")>>
       call iter%next()
    end do
    call m%check_invariant()
    <<assert-eq(eq1="m%size()", eq2="int(n, int64)*n", code=13, message="Btree method `insert` are something wrong.")>>
    do i = n, 1, -1
       do j = n, 1, -1
          call m%remove(tuple2_int32_int32(i, j))
       end do
    end do
    <<assert-eq(eq1="m%size()", eq2="0", code=14, message="Btree method `remove` are something wrong.")>>
  end subroutine tuple2_btree_test_insertion_ascending
#+end_src

**** Tuple2のpriority_queue
#+name: tuple2-priority_queue-module
#+begin_src fortran :exports code :tangle "src/tuple2_priority_queue_m.F90" :comment link :noweb no-export
  module tuple2_priority_queue_m
    use, intrinsic :: iso_fortran_env
    use tuple2_m
    implicit none
    <<declaration-priority_queue-var(type_base="type", type_kind="tuple2_int32_int32")>>
    <<declaration-priority_queue-var(type_base="type", type_kind="tuple2_int64_int64")>>
    <<declaration-priority_queue-var(type_base="type", type_kind="tuple2_real32_int32")>>
    <<declaration-priority_queue-var(type_base="type", type_kind="tuple2_real64_int64")>>
  contains
    <<procedures-priority_queue-var(type_base="type", type_kind="tuple2_int32_int32")>>
    <<procedures-priority_queue-var(type_base="type", type_kind="tuple2_int64_int64")>>
    <<procedures-priority_queue-var(type_base="type", type_kind="tuple2_real32_int32")>>
    <<procedures-priority_queue-var(type_base="type", type_kind="tuple2_real64_int64")>>
  end module tuple2_priority_queue_m
#+end_src
*** Tuple3
**** Tuple3モジュール全体
#+name: tuple3-module
#+begin_src fortran :exports code :tangle "src/tuple3_m.F90" :comment link :noweb no-export
  module tuple3_m
    use, intrinsic :: iso_fortran_env
    implicit none
    <<declaration-tuple3-var(type1="integer", type1_kind="int32", type2="integer", type2_kind="int32", type3="integer", type3_kind="int32")>>
    <<declaration-tuple3-var(type1="integer", type1_kind="int64", type2="integer", type2_kind="int64", type3="integer", type3_kind="int64")>>
  contains
    <<procedures-tuple3-var(type1="integer", type1_kind="int32", type2="integer", type2_kind="int32", type3="integer", type3_kind="int32")>>
    <<procedures-tuple3-var(type1="integer", type1_kind="int64", type2="integer", type2_kind="int64", type3="integer", type3_kind="int64")>>
  end module tuple3_m
#+end_src
**** Tuple3の宣言
まず, 型 ~${tuple3}~ の宣言を行う.
~${tuple3}~ は3つの要素を持つ.
3つの要素の型は異なる型でも構わない.
単純でよく知られている型なのでカプセル化を行うメリットはない.

変数 ~${variable}~ は =bash= で展開される.
- ~${tuple3}~ は Tuple3型.
- ~${type1}~ は Tuple3型の一番目の型.
- ~${type2}~ は Tuple3型の二番目の型.
- ~${type3}~ は Tuple3型の三番目の型.
#+name: declaration-tuple3
#+begin_src fortran :exports code
  public :: ${tuple3}
  type :: ${tuple3}
     private
     ${type1} :: v1_
     ${type2} :: v2_
     ${type3} :: v3_
  end type ${tuple3}
  public :: construct_${tuple3}
  interface ${tuple3}
     module procedure :: construct_${tuple3}
  end interface ${tuple3}
  interface operator(<)
     module procedure :: less_${tuple3}
  end interface operator(<)
  interface operator(<=)
     module procedure :: less_equal_${tuple3}
  end interface operator(<=)
  interface operator(>)
     module procedure :: greater_${tuple3}
  end interface operator(>)
  interface operator(>=)
     module procedure :: greater_equal_${tuple3}
  end interface operator(>=)
  interface operator(==)
     module procedure :: equal_${tuple3}
  end interface operator(==)
  interface operator(/=)
     module procedure :: not_equal_${tuple3}
  end interface operator(/=)
#+end_src
**** Tuple3の関数とか
:PROPERTIES:
:header-args: :noweb-ref procedures-tuple3
:END:
***** constructor
=function construct= は Tuple3型を生成する.
#+name: construct-tuple3
#+begin_src fortran :exports code
  !> construct_${tuple3}_by_size: Construct ${tuple3}.
  impure function construct_${tuple3}(val1, val2, val3) result(res)
    type(${tuple3}) :: res
    ${type1}, intent(in) :: val1
    ${type2}, intent(in) :: val2
    ${type3}, intent(in) :: val3
    res%v1_ = val1
    res%v2_ = val2
    res%v3_ = val3
  end function construct_${tuple3}
#+end_src
***** compare_operator
比較演算子たち.
#+name: compare-tuple3
#+begin_src fortran :exports code :noweb no-export
  !> less_${tuple3}: Compare the first elements.
  !> Compare the second elements if the first elements are same.
  logical function less_${tuple3}(lhs, rhs) result(res)
    type(${tuple3}), intent(in) :: lhs, rhs
    res = lhs%v1_ < rhs%v1_
    if (lhs%v1_ == rhs%v1_) then
       res = lhs%v2_ < rhs%v2_
       if (lhs%v2_ == rhs%v2_) then
          res = lhs%v3_ < rhs%v3_
       end if
    end if
  end function less_${tuple3}
  logical function less_equal_${tuple3}(lhs, rhs) result(res)
    type(${tuple3}), intent(in) :: lhs, rhs
    res = lhs%v1_ < rhs%v1_
    if (lhs%v1_ == rhs%v1_) then
       res = lhs%v2_ < rhs%v2_
       if (lhs%v2_ == rhs%v2_) then
          res = lhs%v3_ <= rhs%v3_
       end if
    end if
  end function less_equal_${tuple3}
  logical function greater_${tuple3}(lhs, rhs) result(res)
    type(${tuple3}), intent(in) :: lhs, rhs
    res = lhs%v1_ > rhs%v1_
    if (lhs%v1_ == rhs%v1_) then
       res = lhs%v2_ > rhs%v2_
       if (lhs%v2_ == rhs%v2_) then
          res = lhs%v3_ > rhs%v3_
       end if
    end if
  end function greater_${tuple3}
  logical function greater_equal_${tuple3}(lhs, rhs) result(res)
    type(${tuple3}), intent(in) :: lhs, rhs
    res = lhs%v1_ > rhs%v1_
    if (lhs%v1_ == rhs%v1_) then
       res = lhs%v2_ > rhs%v2_
       if (lhs%v2_ == rhs%v2_) then
          res = lhs%v3_ >= rhs%v3_
       end if
    end if
  end function greater_equal_${tuple3}
  logical function equal_${tuple3}(lhs, rhs) result(res)
    type(${tuple3}), intent(in) :: lhs, rhs
    res = lhs%v1_ == rhs%v1_ .and. lhs%v2_ == rhs%v2_ .and. lhs%v3_ == rhs%v3_
  end function equal_${tuple3}
  logical function not_equal_${tuple3}(lhs, rhs) result(res)
    type(${tuple3}), intent(in) :: lhs, rhs
    res = lhs%v1_ /= rhs%v1_ .or. lhs%v2_ /= rhs%v2_ .or. lhs%v3_ /= rhs%v3_
  end function not_equal_${tuple3}
#+end_src
**** Tuple3の展開
#+name: tuple3-var
#+begin_src bash :exports code :cache no :shebang #!/bin/bash
  suffix=""
  case "${type1}" in
      "character")
          type1="character"
          suffix="${suffix}_character"
          ;;
      "type")
          type1="type(${type1_kind})"
          suffix="${suffix}_${type1_kind}"
          ;;
      ,*)
          type1="${type1}(${type1_kind})"
          suffix="${suffix}_${type1_kind}"
          ;;
  esac
  case "${type2}" in
      "character")
          type2="character"
          suffix="${suffix}_character"
          ;;
      "type")
          type2="type(${type2_kind})"
          suffix="${suffix}_${type2_kind}"
          ;;
      ,*)
          type2="${type2}(${type2_kind})"
          suffix="${suffix}_${type2_kind}"
          ;;
  esac
  case "${type3}" in
      "character")
          type3="character"
          suffix="${suffix}_character"
          ;;
      "type")
          type3="type(${type3_kind})"
          suffix="${suffix}_${type3_kind}"
          ;;
      ,*)
          type3="${type3}(${type3_kind})"
          suffix="${suffix}_${type3_kind}"
          ;;
  esac
  tuple3="tuple3${suffix}"
#+end_src
#+name: declaration-tuple3-var
#+begin_src bash :exports code :var type1="integer" type_kind1="int32" type2="integer" type2_kind="int32" type3="integer" type3_kind="int32" :results output :noweb no-export :cache no :shebang #!/bin/bash
  <<tuple3-var>>
  cat <<EOF
  <<declaration-tuple3>>
  EOF
#+end_src
#+name: procedures-tuple3-var
#+begin_src bash :exports code :var type1="integer" type_kind1="int32" type2="integer" type2_kind="int32" type3="integer" type3_kind="int32" :results output :noweb no-export :cache no :shebang #!/bin/bash
  <<tuple3-var>>
  cat <<EOF
  <<procedures-tuple3>>
  EOF
#+end_src
**** test
***** testコードブロック
#+name: test-tuple3
#+begin_src fortran :flags "-cpp -g -fbacktrace -fcheck=bounds" :exports code :results output :noweb no-export :cache yes
<<tuple3-module>>
<<tuple3-test>>
#+end_src

#+RESULTS[690f7a0f9736907e7cf523601876408b5f436663]: test-tuple3

***** test本体
#+name: tuple3-test
#+begin_src fortran :exports code :tangle "test/test_tuple3.F90" :noweb no-export
  program test_tuple3
    use, intrinsic :: iso_fortran_env
    use tuple3_m
    implicit none
    type(tuple3_int32_int32_int32) :: t1, t2
    t1 = tuple3_int32_int32_int32(1, 1, 1)
    <<assert(cond="t1 == t1",       code=10, message="`==` for Tuple3 is illegal.")>>
    <<assert-false(cond="t1 /= t1", code=11, message="`/=` for Tuple3 is illegal.")>>
    <<assert-false(cond="t1 < t1",  code=12, message="`<` for Tuple3 is illegal.")>>
    <<assert(cond="t1 >= t1",       code=13, message="`>=` for Tuple3 is illegal.")>>
    <<assert-false(cond="t1 > t1",  code=14, message="`>` for Tuple3 is illegal.")>>
    <<assert(cond="t1 <= t1",       code=15, message="`<=` for Tuple3 is illegal.")>>
    t2 = tuple3_int32_int32_int32(1, 1, 2)
    <<assert-false(cond="t1 == t2", code=20, message="`==` for Tuple3 is illegal.")>>
    <<assert(cond="t1 /= t2",       code=21, message="`/=` for Tuple3 is illegal.")>>
    <<assert(cond="t1 < t2",        code=22, message="`<` for Tuple3 is illegal.")>>
    <<assert-false(cond="t1 >= t2", code=23, message="`>=` for Tuple3 is illegal.")>>
    <<assert-false(cond="t1 > t2",  code=24, message="`>` for Tuple3 is illegal.")>>
    <<assert(cond="t1 <= t2",       code=25, message="`<=` for Tuple3 is illegal.")>>
    t2 = tuple3_int32_int32_int32(1, 2, 2)
    <<assert-false(cond="t1 == t2", code=30, message="`==` for Tuple3 is illegal.")>>
    <<assert(cond="t1 /= t2",       code=31, message="`/=` for Tuple3 is illegal.")>>
    <<assert(cond="t1 < t2",        code=32, message="`<` for Tuple3 is illegal.")>>
    <<assert-false(cond="t1 >= t2", code=33, message="`>=` for Tuple3 is illegal.")>>
    <<assert-false(cond="t1 > t2",  code=34, message="`>` for Tuple3 is illegal.")>>
    <<assert(cond="t1 <= t2",       code=35, message="`<=` for Tuple3 is illegal.")>>
    t2 = tuple3_int32_int32_int32(100, 1, 2)
    <<assert-false(cond="t1 == t2", code=40, message="`==` for Tuple3 is illegal.")>>
    <<assert(cond="t1 /= t2",       code=41, message="`/=` for Tuple3 is illegal.")>>
    <<assert(cond="t1 < t2",        code=42, message="`<` for Tuple3 is illegal.")>>
    <<assert-false(cond="t1 >= t2", code=43, message="`>=` for Tuple3 is illegal.")>>
    <<assert-false(cond="t1 > t2",  code=44, message="`>` for Tuple3 is illegal.")>>
    <<assert(cond="t1 <= t2",       code=45, message="`<=` for Tuple3 is illegal.")>>
    t2 = tuple3_int32_int32_int32(0, 1, 2)
    <<assert-false(cond="t1 == t2", code=50, message="`==` for Tuple3 is illegal.")>>
    <<assert(cond="t1 /= t2",       code=51, message="`/=` for Tuple3 is illegal.")>>
    <<assert-false(cond="t1 < t2",        code=52, message="`<` for Tuple3 is illegal.")>>
    <<assert(cond="t1 >= t2", code=53, message="`>=` for Tuple3 is illegal.")>>
    <<assert(cond="t1 > t2",  code=54, message="`>` for Tuple3 is illegal.")>>
    <<assert-false(cond="t1 <= t2",       code=55, message="`<=` for Tuple3 is illegal.")>>
    t2 = tuple3_int32_int32_int32(1, 1, -100)
    <<assert-false(cond="t1 == t2", code=50, message="`==` for Tuple3 is illegal.")>>
    <<assert(cond="t1 /= t2",       code=51, message="`/=` for Tuple3 is illegal.")>>
    <<assert-false(cond="t1 < t2",        code=52, message="`<` for Tuple3 is illegal.")>>
    <<assert(cond="t1 >= t2", code=53, message="`>=` for Tuple3 is illegal.")>>
    <<assert(cond="t1 > t2",  code=54, message="`>` for Tuple3 is illegal.")>>
    <<assert-false(cond="t1 <= t2",       code=55, message="`<=` for Tuple3 is illegal.")>>
  end program test_tuple3
#+end_src
**** Tuple3のunwrapped_vector
#+name: tuple3-unwrapped_vector-module
#+begin_src fortran :exports code :tangle "src/tuple3_unwrapped_vector_m.F90" :comment link :noweb no-export
  module tuple3_unwrapped_vector_m
    use, intrinsic :: iso_fortran_env
    use tuple3_m
    implicit none
    <<declaration-unwrapped_vector-var(type="type", type_kind="tuple3_int32_int32_int32")>>
    <<declaration-unwrapped_vector-var(type="type", type_kind="tuple3_int64_int64_int64")>>
  contains
    <<procedures-unwrapped_vector-var(type="type", type_kind="tuple3_int32_int32_int32")>>
    <<procedures-unwrapped_vector-var(type="type", type_kind="tuple3_int64_int64_int64")>>
  end module tuple3_unwrapped_vector_m
#+end_src
**** Tuple3のpriority_queue
#+name: tuple3-priority_queue-module
#+begin_src fortran :exports code :tangle "src/tuple3_priority_queue_m.F90" :comment link :noweb no-export
  module tuple3_priority_queue_m
    use, intrinsic :: iso_fortran_env
    use tuple3_m
    implicit none
    <<declaration-priority_queue-var(type_base="type", type_kind="tuple3_int32_int32_int32")>>
    <<declaration-priority_queue-var(type_base="type", type_kind="tuple3_int64_int64_int64")>>
  contains
    <<procedures-priority_queue-var(type_base="type", type_kind="tuple3_int32_int32_int32")>>
    <<procedures-priority_queue-var(type_base="type", type_kind="tuple3_int64_int64_int64")>>
  end module tuple3_priority_queue_m
#+end_src
** linked list
*** by pointer
**** whole module of linked list
#+name: linked_list-module
#+begin_src fortran :exports code :tangle "src/linked_list_m.f90" :comment link :noweb no-export
  module linked_list_m
    use, intrinsic :: iso_fortran_env
    implicit none
    <<declaration-linked_list-var(type="integer", type_kind="int32")>>
    <<declaration-linked_list-var(type="integer", type_kind="int64")>>
    <<declaration-linked_list-var(type="real", type_kind="real32")>>
    <<declaration-linked_list-var(type="real", type_kind="real64")>>
  contains
    <<procedures-linked_list-var(type="integer", type_kind="int32")>>
    <<procedures-linked_list-var(type="integer", type_kind="int64")>>
    <<procedures-linked_list-var(type="real", type_kind="real32")>>
    <<procedures-linked_list-var(type="real", type_kind="real64")>>
  end module linked_list_m
#+end_src
**** declaration of linked list
First, We define type of linked list.
This linked list is implemented by a head of list and some lists (0 or more than).
The list can add new values, delete, and search some elements.

Variables like ${variable} are expanded by bash.
- ${type} is type of elements in the list.
#+name: declaration-linked_list
#+begin_src fortran :exports code
  private :: linked_list_${suffix}
  type :: linked_list_${suffix}
     private
     ${type} :: val_
     type(linked_list_${suffix}), pointer :: next_ => null()
  end type linked_list_${suffix}

  public :: linked_list_${suffix}_head
  type :: linked_list_${suffix}_head
     private
     type(linked_list_${suffix}), pointer :: head_ => null()
   contains
     procedure, pass :: add    => add_linked_list_${suffix}_head
     procedure, pass :: delete => delete_linked_list_${suffix}_head
     procedure, pass :: search => search_linked_list_${suffix}_head
  end type linked_list_${suffix}_head

  interface linked_list_${suffix}
     module procedure :: init_linked_list_${suffix}
  end interface linked_list_${suffix}
  interface linked_list_${suffix}_head
     module procedure :: init_linked_list_${suffix}_head
     module procedure :: init_linked_list_${suffix}_head_by_array
  end interface linked_list_${suffix}_head
#+end_src
**** procedures of linked list
:PROPERTIES:
:header-args: :noweb-ref procedures-linked_list
:END:
There are four procedures for the linked list.
***** init
=function init= initialize linked_list and linked_list
#+name: init-linked_list
#+begin_src fortran :exports code
  !> init_linked_list_${suffix}: Initialize the linked_list_${suffix} by val.
  impure function init_linked_list_${suffix}(val) result(lst)
    type(linked_list_${suffix}), pointer :: lst
    ${type} :: val
    allocate(lst)
    lst%val_ = val
    return
  end function init_linked_list_${suffix}
#+end_src
#+name: init-linked_list_head
#+begin_src fortran :exports code
  !> init_linked_list_${suffix}_head: Initialize the empty linked_list_${suffix}_head.
  impure function init_linked_list_${suffix}_head() result(lst_head)
    type(linked_list_${suffix}_head) :: lst_head
    lst_head%head_ => null()
    return
  end function init_linked_list_${suffix}_head
  !> init_linked_list_${suffix}_head_by_array: Initialize the empty linked_list_${suffix}_head by array.
  impure function init_linked_list_${suffix}_head_by_array(arr) result(lst_head)
    type(linked_list_${suffix}_head) :: lst_head
    ${type} :: arr(:)
    integer(int32) :: s, i
    s = size(arr)
    do i = s, 1, -1
       call lst_head%add(arr(i))
    end do
    return
  end function init_linked_list_${suffix}_head_by_array
#+end_src
***** add
=Subroutine add= adds value into the linked list.
#+name: add-linked_list_head
#+begin_src fortran :exports code
  !> add_linked_list_${suffix}: Add val into head of linked list.
  subroutine add_linked_list_${suffix}_head(lst_head, val)
    class(linked_list_${suffix}_head), intent(inout) :: lst_head
    ${type}, intent(in) :: val
    type(linked_list_${suffix}), pointer :: lst_elem
    lst_elem => linked_list_${suffix}(val)
    lst_elem%next_ => lst_head%head_
    lst_head%head_ => lst_elem
  end subroutine add_linked_list_${suffix}_head
#+end_src
***** delete
=Subroutine delete= delete elements in linked list.
#+name: delete-linked_list_head
#+begin_src fortran :exports code
  !> delete_linked_list_${suffix}: Delete val from element of linked list.
  !> Do nothing if lst does not elem val.
  subroutine delete_linked_list_${suffix}_head(lst_head, val)
    class(linked_list_${suffix}_head), intent(inout) :: lst_head
    ${type}, intent(in) :: val
    type(linked_list_${suffix}), pointer :: lst_elem, lst_del
    if (.not. associated(lst_head%head_)) return
    lst_elem => lst_head%head_
    if (lst_elem%val_ == val) then
       lst_head%head_ => lst_elem%next_
       deallocate(lst_elem)
       return
    end if
    do
       if (.not. associated(lst_elem%next_)) return
       if (lst_elem%next_%val_ == val) then
          lst_del => lst_elem%next_
          lst_elem%next_ => lst_elem%next_%next_
          deallocate(lst_del)
          return
       end if
    end do
  end subroutine delete_linked_list_${suffix}_head
#+end_src
***** search
=Subroutine search= search value from linked list and return =.true.= if success.
#+name: search-linked_list_head
#+begin_src fortran :exports code
  !> search_linked_list_${suffix}: Search val from element of linked list.
  !> Return .true. if success.
  logical function search_linked_list_${suffix}_head(lst_head, val) result(find)
    class(linked_list_${suffix}_head), intent(in) :: lst_head
    ${type}, intent(in) :: val
    type(linked_list_${suffix}), pointer :: lst_elem
    if (.not. associated(lst_head%head_)) return
    lst_elem => lst_head%head_
    find = .false.
    do
       if (.not. associated(lst_elem)) return
       if (lst_elem%val_ == val) then
          find = .true.
          return
       end if
       lst_elem => lst_elem%next_
    end do
  end function search_linked_list_${suffix}_head
#+end_src
**** process definition and procedures of linked list
#+name: declaration-linked_list-var
#+begin_src bash :exports code :var type="integer" type_kind="int32" :results output :noweb no-export :cache no :shebang #!/bin/bash
  case "${type}" in
      "character")
          type="character(len=:), allocatable"
          suffix="character"
          ;;
      ,*)
          type="${type}(${type_kind})"
          suffix="${type_kind}"
          ;;
  esac
  cat <<EOF
  <<declaration-linked_list>>
  EOF
#+end_src
#+name: procedures-linked_list-var
#+begin_src bash :exports code :var type="integer" type_kind="int32" :results output :noweb no-export :cache no :shebang #!/bin/bash
  case "${type}" in
      "character")
          type="character(len=:), allocatable"
          suffix="character"
          ;;
      ,*)
          type="${type}(${type_kind})"
          suffix="${type_kind}"
          ;;
  esac
  cat <<EOF
  <<procedures-linked_list>>
  EOF
#+end_src
**** test
#+name: linked_list-test
#+begin_src fortran :exports code :tangle "test/test_linked_list.f90"
  program test_linked_list
    use, intrinsic :: iso_fortran_env
    use linked_list_m
    implicit none
    integer(int32) :: i
    type(linked_list_int32_head) :: lst_i32
    do i = 1, 10
       call lst_i32%add(i)
    end do
    print*, lst_i32%search(3)
    print*, lst_i32%search(-1)
  end program test_linked_list
#+end_src
#+name: test-linked_list
#+begin_src fortran :exports code :results output :noweb no-export :cache yes
<<linked_list-module>>
<<linked_list-test>>
#+end_src

#+RESULTS[94846b1ec8b475a77907acdcedad9a0da205232b]: test-linked_list
: T
: F

** Vector (Variable array)
*** Unwrapped Vector
**** whole module of the unwrapped_vector
#+name: unwrapped_vector-module
#+begin_src fortran :exports code :tangle "src/unwrapped_vector_m.F90" :comment link :noweb no-export
  module unwrapped_vector_m
    use, intrinsic :: iso_fortran_env
    implicit none
    private
    <<declaration-unwrapped_vector-var(type="integer", type_kind="int32")>>
    <<declaration-unwrapped_vector-var(type="integer", type_kind="int64")>>
    <<declaration-unwrapped_vector-var(type="real", type_kind="real32")>>
    <<declaration-unwrapped_vector-var(type="real", type_kind="real64")>>
    <<declaration-unwrapped_vector-var(type="character")>>
  contains
    <<procedures-unwrapped_vector-var(type="integer", type_kind="int32")>>
    <<procedures-unwrapped_vector-var(type="integer", type_kind="int64")>>
    <<procedures-unwrapped_vector-var(type="real", type_kind="real32")>>
    <<procedures-unwrapped_vector-var(type="real", type_kind="real64")>>
    <<procedures-unwrapped_vector-var(type="character")>>
  end module unwrapped_vector_m
#+end_src
**** declaration of the unwrapped_vector
First, We define the type of the unwrapped_vector.
These unwrapped_vectors are implemented by the array that shrink and expand.
The list can add new values, delete, and search some elements.
We can access the member ~arr_(:)~ directory, so we should take care of the consistency of data.

Variables like ${variable} are expanded by bash.
- ${uwvec} is the name of the type for the unwrapped vector .
- ${type} is the type of the
#+name: declaration-unwrapped_vector
#+begin_src fortran :exports code
  public :: ${uwvec}
  type :: ${uwvec}
     private
     ${type}, allocatable, public :: arr_(:)
     integer(int32) :: size_ = 0, capa_ = 0
   contains
     procedure, pass :: init      => init_${uwvec}
     procedure, pass :: push_back_${uwvec}, &
          push_back_array_${uwvec}
     generic         :: push_back => push_back_${uwvec}, &
          push_back_array_${uwvec}
     procedure, pass :: pop_back  => pop_back_${uwvec}
     procedure, pass :: back      => back_${uwvec}
     procedure, pass :: size      => size_${uwvec}
     procedure, pass :: resize    => resize_${uwvec}
     procedure, pass :: lower_bound => lower_bound_${uwvec}
  end type ${uwvec}
  interface ${uwvec}
     module procedure :: construct_${uwvec}_by_size, &
          construct_${uwvec}_by_arr, &
          construct_${uwvec}_by_init_val
  end interface ${uwvec}
#+end_src
**** procedures of the unwrapped vector
:PROPERTIES:
:header-args: :noweb-ref procedures-unwrapped_vector
:END:
***** constructor
=function construct= constructs unwrapped_vector by size or value.
#+name: construct-unwrapped_vector
#+begin_src fortran :exports code
  !> construct_${uwvec}_by_size: Construct ${uwvec} by the size, the initial values is unknown.
  impure function construct_${uwvec}_by_size(size) result(res)
    type(${uwvec}) :: res
    integer(int32), intent(in) :: size
    call res%init(size)
  end function construct_${uwvec}_by_size
  !> construct_${uwvec}_by_arr: Construct ${uwvec} by the array of ${type}.
  impure function construct_${uwvec}_by_arr(arr) result(res)
    type(${uwvec}) :: res
    ${type}, intent(in) :: arr(:)
    integer(int32) :: n
    n = size(arr)
    call res%init(n)
    res%arr_(1:n) = arr(1:n)
  end function construct_${uwvec}_by_arr
  !> construct_${uwvec}_by_init_val: Construct ${uwvec} by size and the initial values.
  impure function construct_${uwvec}_by_init_val(size, val) result(res)
    type(${uwvec}) :: res
    integer(int32), intent(in) :: size
    ${type}, intent(in) :: val
    call res%init(size)
    res%arr_(1:size) = val
  end function construct_${uwvec}_by_init_val
#+end_src
***** init
=subroutine init= initialize unwrapped_vector by size.
#+name: init-unwrapped_vector
#+begin_src fortran :exports code :noweb no-export
  !> init_${uwvec}: Initialize the ${uwvec} by size.
  subroutine init_${uwvec}(this, n)
    class(${uwvec}), intent(inout) :: this
    integer(int32), intent(in) :: n
    if (.not. allocated(this%arr_)) then
       allocate(this%arr_(n))
       this%size_ = n
       this%capa_ = n
    end if
  end subroutine init_${uwvec}
#+end_src
***** push_back
=subroutine push_back= insert value to the tail of elements of the unwrapped vector.
#+name: push_back-unwrapped_vector
#+begin_src fortran :exports code
  !> push_back_${uwvec}: Insert value to the tail of elements of the ${uwvec}.
  subroutine push_back_${uwvec}(this, val)
    class(${uwvec}), intent(inout) :: this
    ${type}, intent(in) :: val
    if (.not. allocated(this%arr_)) call this%resize(0)
    if (this%size_ == this%capa_) then
       call this%resize(2*this%capa_)
    end if
    this%size_ = this%size_ + 1
    this%arr_(this%size_) = val
  end subroutine push_back_${uwvec}
  !> push_back_array_${uwvec}: Insert elemeents of array to the tail of elements of the ${uwvec}.
  subroutine push_back_array_${uwvec}(this, arr)
    class(${uwvec}), intent(inout) :: this
    ${type}, intent(in) :: arr(:)
    integer(int32) :: s
    s = size(arr)
    if (.not. allocated(this%arr_)) call this%init(s)
    if (this%size_ + s > this%capa_) then
       call this%resize(this%size_ + s)
    end if
    this%arr_(this%size_+1:this%size_+s) = arr(:)
    this%size_ = this%size_ + s
  end subroutine push_back_array_${uwvec}
#+end_src
***** pop_back
=function pop_back= deletes the value in the end of arr_(:) of the unwrapped vector and returns it.
#+name: pop_back-unwrapped_vector
#+begin_src fortran :exports code :noweb no-export
  !> pop_back_${uwvec}: Delete the value in the end of arr_(:) of the ${uwvec} and return it.
  ${type} function pop_back_${uwvec}(this)
    class(${uwvec}), intent(inout) :: this
    pop_back_${uwvec} = this%arr_(this%size_)
    this%size_ = this%size_ - 1
  end function pop_back_${uwvec}
#+end_src
***** back
=function back= returns the value in the end of arr_(:) of the unwrapped vector.
#+name: back-unwrapped_vector
#+begin_src fortran :exports code :noweb no-export
  !> back_${uwvec}: Delete the value in the end of arr_(:) of the ${uwvec} and return it.
  ${type} function back_${uwvec}(this)
    class(${uwvec}), intent(inout) :: this
    back_${uwvec} = this%arr_(this%size_)
  end function back_${uwvec}
#+end_src
***** size
=function size= return current size of the unwrapped vector.
#+name: size-unwrapped_vector
#+begin_src fortran :exports code
  !> size_vector_${suffix}: Return current size of the ${uwvec}.
  pure integer(int32) function size_${uwvec}(this)
    class(${uwvec}), intent(in) :: this
    size_${uwvec} = this%size_
  end function size_${uwvec}
#+end_src
***** resize
=subroutine resize= shrinks or expands arr_(:) of the unwrapped vector.
#+name: resize-unwrapped_vector
#+begin_src fortran :exports code :noweb no-export
  !> resize_${uwvec}: Shrink or expand arr_(:) of the ${uwvec}.
  subroutine resize_${uwvec}(this, resize)
    class(${uwvec}), intent(inout) :: this
    integer(int32), intent(in) :: resize
    ${type}, allocatable :: tmp(:)
    if (resize < 1) then
       this%size_ = 0
       allocate(tmp(1))
       call move_alloc(from = tmp, to = this%arr_)
       this%capa_ = 1
    else
       if (this%capa_ == resize) return
       allocate(tmp(resize))
       this%size_ = min(this%size_, resize)
       tmp(1:this%size_) = this%arr_(1:this%size_)
       call move_alloc(from = tmp, to = this%arr_)
       this%capa_ = resize
    end if
  end subroutine resize_${uwvec}
#+end_src
***** lower_bound
=function lower_bound= returns the minimum index that is higher than or equal to `val`.
#+name: lower_bonud-unwrapped_vector
#+begin_src fortran :exports code :noweb no-export
  !> lower_bound_vector_${suffix}: Return the minimum index that is higher than or equal to `val`.
  integer(int32) function lower_bound_${uwvec}(this, val)
    class(${uwvec}), intent(in) :: this
    ${type}, intent(in) :: val
    integer(int32) :: p, q, r
    p = 1
    r = this%size_
    if (this%arr_(r) < val) then
       lower_bound_${uwvec} = r + 1
       return
    end if
    do
       q = (p+r)/2
       if (p + 1 > r) exit
       if (this%arr_(q) >= val) then
          r = q
       else
          p = q+1
       end if
    end do
    lower_bound_${uwvec} = q
  end function lower_bound_${uwvec}
#+end_src
**** process definition and procedures of the vector
#+name: unwrapped_vector-var
#+begin_src bash :exports code :cache no :shebang #!/bin/bash
  case "${type}" in
      "character")
          type="character"
          suffix="character"
          ;;
      "type")
          type="type(${type_kind})"
          suffix="${type_kind}"
          ;;
      ,*)
          type="${type}(${type_kind})"
          suffix="${type_kind}"
          ;;
  esac
  uwvec="unwrapped_vector_${suffix}"
#+end_src
#+name: declaration-unwrapped_vector-var
#+begin_src bash :exports code :var type="integer" type_kind="int32" :results output :noweb no-export :cache no :shebang #!/bin/bash
  <<unwrapped_vector-var>>
  cat <<EOF
  <<declaration-unwrapped_vector>>
  EOF
#+end_src
#+name: procedures-unwrapped_vector-var
#+begin_src bash :exports code :var type="integer" type_kind="int32" :results output :noweb no-export :cache no :shebang #!/bin/bash
  <<unwrapped_vector-var>>
  cat <<EOF
  <<procedures-unwrapped_vector>>
  EOF
#+end_src
**** test
#+name: unwrapped_vector-test
#+begin_src fortran :exports code :tangle "test/test_unwrapped_vector.F90" :noweb no-export
  program test_unwrapped_vector
    use, intrinsic :: iso_fortran_env
    use unwrapped_vector_m
    implicit none
    integer(int32) :: i, j
    integer(int32) :: ierr
    integer(int32), parameter :: n = 10, low = 5, high = low+n-1
    type(unwrapped_vector_int32) :: v, v2
    store:do i = 1, n
       call v%push_back(i)
       <<assert(cond="v%arr_(i) == i", code=10, message="Stored value in `v%arr_(i)` is illegal in loop.")>>
    end do store
    test_lower_bound:do i = 0, v%size()+1
       j = v%lower_bound(i)
       <<assert(cond="j == max(1, i)", code=11, message="Return value of `lower_bound` is illegal in loop.")>>
    end do test_lower_bound
    do i = 1, n
       j = v%pop_back()
    end do

    v2 = unwrapped_vector_int32(5)
    v2%arr_(:) = 1
    do i = 1, 5
       <<assert(cond="v2%arr_(i) == 1", code=20, message="Initialization by size of `v2` is illegal.")>>
    end do
    v2 = unwrapped_vector_int32([(i, i = 1,5)])
    do i = 1, 5
       <<assert(cond="v2%arr_(i) == i", code=21, message="Initialization by array of `v2` is illegal.")>>
    end do
    v2 = unwrapped_vector_int32(size = 5, val = 2)
    do i = 1, 5
       <<assert(cond="v2%arr_(i) == 2", code=22, message="Initialization by init_val of `v2` is illegal.")>>
    end do

    call v2%resize(0)
    do i = 1, 5
       call v2%push_back(i)
       <<assert(cond="v2%back() == i", code=23, message="Resize or back for `v2` is illegal.")>>
    end do
  end program test_unwrapped_vector
#+end_src
#+name: test-unwrapped_vector
#+begin_src fortran :flags "-cpp -g -fbacktrace -fcheck=bounds" :exports code :results output :noweb no-export :cache yes
<<unwrapped_vector-module>>
<<unwrapped_vector-test>>
#+end_src

#+RESULTS[f4d58e4595aecbf77553fdd0fd7c8ef6c1f77d67]: test-unwrapped_vector

*** COMMENT wrapped Vector
**** whole module of the vector
#+name: vector-module
#+begin_src fortran :exports code :tangle "src/vector_m.F90" :comment link :noweb no-export
  module vector_m
    use, intrinsic :: iso_fortran_env
    use unwrapped_vector_m
    implicit none
    private
  <<declaration-vector-var(type="integer", type_kind="int32")>>
  <<declaration-vector-var(type="integer", type_kind="int64")>>
  <<declaration-vector-var(type="real", type_kind="real32")>>
  <<declaration-vector-var(type="real", type_kind="real64")>>
  <<declaration-vector-var(type="character")>>
  contains
  <<procedures-vector-var(type="integer", type_kind="int32")>>
  <<procedures-vector-var(type="integer", type_kind="int64")>>
  <<procedures-vector-var(type="real", type_kind="real32")>>
  <<procedures-vector-var(type="real", type_kind="real64")>>
  <<procedures-vector-var(type="character")>>
  end module vector_m
#+end_src
**** declaration of the vector
First, We define type of the vector.
These vectors are implemented by the array that shrink and expand.
The list can add new values, delete, and search some elements.

Variables like ${variable} are expanded by bash.
- ${type} is type of elements in the list.
#+name: declaration-vector
#+begin_src fortran :exports code
  public :: ${vec}
  type :: ${vec}
     private
     ${uwvec} :: uwvec_
   contains
     procedure, pass :: init_vector_${suffix}, init_vector_range_${suffix}
     generic         :: init      => init_vector_${suffix}, init_vector_range_${suffix}
     procedure, pass :: push_back_vector_${suffix}, push_back_array_vector_${suffix}
     generic         :: push_back => push_back_vector_${suffix}, push_back_array_vector_${suffix}
     procedure, pass :: pop_back  => pop_back_vector_${suffix}
     procedure, pass :: size      => size_vector_${suffix}
     procedure, pass :: lbound    => lbound_vector_${suffix}
     procedure, pass :: ubound    => ubound_vector_${suffix}
     procedure, pass :: resize_vector_${suffix}, resize_vector_range_${suffix}
     generic         :: resize    => resize_vector_${suffix}, resize_vector_range_${suffix}
     procedure, pass :: at        => at_vector_${suffix}
     procedure, pass :: replace   => replace_vector_${suffix}
     procedure, pass :: lower_bound => lower_bound_vector_${suffix}
     ! procedure, pass :: make_iter => make_iter_vector_${suffix}
  end type vector_${suffix}

  ! public :: iterator_vector_${suffix}
  ! type :: iterator_vector_${suffix}
  !    private
  !    type(vector_${suffix}), pointer :: vec_ptr
  !    integer(int32) :: iter_
  !  contains
  !    procedure, pass :: next  => next_iterator_vector_${suffix}
  !    procedure, pass :: prev  => prev_iterator_vector_${suffix}
  !    procedure, pass :: begin => begin_iterator_vector_${suffix}
  !    procedure, pass :: end   => end_iterator_vector_${suffix}
  !    procedure, pass :: val   => val_iterator_vector_${suffix}
  ! end type vector_${suffix}
#+end_src
**** procedures of the vector
:PROPERTIES:
:header-args: :noweb-ref procedures-vector
:END:
***** init
=subroutine init= initialize vector by size.
#+name: init-vector
#+begin_src fortran :exports code :noweb no-export
  !> init_vector_${suffix}: Initialize the vector_${suffix} by size.
  subroutine init_vector_${suffix}(this, n)
    class(vector_${suffix}), intent(inout) :: this
    integer(int32), intent(in) :: n
    if (.not. allocated(this%arr_)) then
       allocate(this%arr_(n))
       this%size_ = 0 !n
       this%capa_ = n
       this%lb_   = 1
  #ifdef DEBUG
    else
       <<error-handling-filename>>
       <<error-handling-error_message-exit(err_num=1,string="Vector is already allocated...")>>
  #endif
    end if
  end subroutine init_vector_${suffix}

  ! !> init_vector_range_${suffix}: Initialize the vector_${suffix} by size.
  ! subroutine init_vector_range_${suffix}(this, lb, ub, ierr)
  !   class(vector_${suffix}), intent(inout) :: this
  !   integer(int32), intent(in) :: lb, ub
  !   integer(int32), intent(out), optional :: ierr
  !   if (lb > ub) then
  !      <<error-handling-return-ierr(ierr=1)>>
  !      <<error-handling-filename>>
  !      <<error-handling-error_message-exit(err_num=2,string="init_vector_range_${suffix}: `ub` must be larger than or equal to `lb`")>>
  !   end if
  !   call this%init(ub-lb+1)
  !   this%lb_ = lb
  !   if (present(ierr)) ierr = 0
  ! end subroutine init_vector_range_${suffix}
#+end_src
***** push_back
=subroutine push_back= insert value to the tail of elements of the vector.
#+name: push_back-vector
#+begin_src fortran :exports code
  !> push_back_vector_${suffix}: Insert value to the tail of elements of the vector.
  subroutine push_back_vector_${suffix}(this, val)
    class(vector_${suffix}), intent(inout) :: this
    ${type}, intent(in) :: val
    if (.not. allocated(this%arr_)) call this%init(1)
    if (this%size_ == this%capa_) then
       call this%resize(2*this%capa_)
    end if
    this%size_ = this%size_ + 1
    this%arr_(this%size_) = val
  end subroutine push_back_vector_${suffix}
  !> push_back_array_vector_${suffix}: Insert elemeents of array to the tail of elements of the vector.
  subroutine push_back_array_vector_${suffix}(this, arr)
    class(vector_${suffix}), intent(inout) :: this
    ${type}, intent(in) :: arr(:)
    integer(int32) :: s
    s = size(arr)
    if (.not. allocated(this%arr_)) call this%init(s)
    if (this%size_ + s > this%capa_) then
       call this%resize(this%size_ + s)
    end if
    this%arr_(this%size_+1:this%size_+s) = arr(:)
    this%size_ = this%size_ + s
  end subroutine push_back_array_vector_${suffix}
#+end_src
***** pop_back
=function pop_back= deletes the value in the end of arr_(:) of the vector and returns it.
#+name: pop_back-vector
#+begin_src fortran :exports code :noweb no-export
  !> push_back_vector_${suffix}: Delete the value in the end of arr_(:) of the vector and return it.
  ${type} function pop_back_vector_${suffix}(this, ierr)
    class(vector_${suffix}), intent(inout) :: this
    integer(int32), intent(out), optional :: ierr
    if (this%size_ == 0) then
       <<error-handling-return-ierr(ierr=1)>>
       <<error-handling-filename>>
       <<error-handling-error_message-exit(err_num=3,string="There are no elements that can pop_back.">>
    end if
    pop_back_vector_${suffix} = this%arr_(this%size_)
    this%size_ = this%size_ - 1
    if (present(ierr)) ierr = 0
  end function pop_back_vector_${suffix}
#+end_src
***** size
=function size= return current size of the vector.
#+name: size-vector
#+begin_src fortran :exports code
  !> size_vector_${suffix}: Return current size of the vector.
  pure integer(int32) function size_vector_${suffix}(this)
    class(vector_${suffix}), intent(in) :: this
    size_vector_${suffix} = this%size_
  end function size_vector_${suffix}
#+end_src
***** lbound
=function size= return current lbound of the vector.
#+name: lbound-vector
#+begin_src fortran :exports code
  !> size_vector_${suffix}: Return current lbound of the vector.
  pure integer(int32) function lbound_vector_${suffix}(this)
    class(vector_${suffix}), intent(in) :: this
    lbound_vector_${suffix} = this%lb_
  end function lbound_vector_${suffix}
#+end_src
***** ubound
=function size= return current ubound of the vector.
#+name: ubound-vector
#+begin_src fortran :exports code
  !> size_vector_${suffix}: Return current ubonud of the vector.
  pure integer(int32) function ubound_vector_${suffix}(this)
    class(vector_${suffix}), intent(in) :: this
    ubound_vector_${suffix} = this%lb_ + this%size_ - 1
  end function ubound_vector_${suffix}
#+end_src
***** resize
=subroutine resize= shrinks or expands arr_(:) of the vector.
#+name: resize-vector
#+begin_src fortran :exports code :noweb no-export
  !> resize_vector_${suffix}: Shrink or expand arr_(:) of the vector.
  subroutine resize_vector_${suffix}(this, resize)
    class(vector_${suffix}), intent(inout) :: this
    integer(int32), intent(in) :: resize
    ${type}, allocatable :: tmp(:)
    if (this%capa_ == resize) return
    allocate(tmp(resize))
    this%size_ = min(this%size_, resize)
    tmp(1:this%size_) = this%arr_(1:this%size_)
    call move_alloc(from = tmp, to = this%arr_)
    this%capa_ = resize
  end subroutine resize_vector_${suffix}

  !> resize_range_vector_${suffix}: Shrink or expand arr_(:) of the vector by lb and ub.
  subroutine resize_vector_range_${suffix}(this, lb, ub, ierr)
    class(vector_${suffix}), intent(inout) :: this
    integer(int32), intent(in) :: lb, ub
    integer(int32), intent(out), optional :: ierr
    if (ub > lb) then
       <<error-handling-return-ierr(ierr=1)>>
         <<error-handling-filename>>
         <<error-handling-error_message-exit(err_num=2,string="resize_range_vector_range_${suffix}: `ub` must be larger than or equal tox `lb`")>>
    end if
    call this%resize(ub-lb+1)
    this%lb_ = lb
    if (present(ierr)) ierr = 0
  end subroutine resize_vector_range_${suffix}
#+end_src
***** at
=function at= return the element that locate at `i` of the vector.
#+name: at-vector
#+begin_src fortran :exports code :noweb no-export
  !> at_vector_${suffix}: Return the element that locate at `i` of the vector.
  ${type} function at_vector_${suffix}(this, i, ierr)
    class(vector_${suffix}), intent(in) :: this
    integer(int32), intent(in) :: i
    integer(int32), intent(out), optional :: ierr
  <<error-handling-vector-bounds-out>>
    at_vector_${suffix} = this%arr_(i - this%lb_ + 1)
    if (present(ierr)) ierr = 0
  end function at_vector_${suffix}
#+end_src
***** replace
=subroutine replace= replace the element of arr_(i).
#+name: replace-vector
#+begin_src fortran :exports code :noweb no-export
  !> replace_vector_${suffix}: Shrink or expand arr_(:) of the vector.
  subroutine replace_vector_${suffix}(this, i, val, ierr)
    class(vector_${suffix}), intent(inout) :: this
    integer(int32), intent(in) :: i
    integer(int32), intent(out), optional :: ierr
    ${type}, intent(in) :: val
  <<error-handling-vector-bounds-out>>
    this%arr_(i - this%lb_ + 1) = val
    if (present(ierr)) ierr = 0
  end subroutine replace_vector_${suffix}
#+end_src
***** lower_bound
=function lower_bound= returns the minimum index that is higher than or equal to `val`.
#+name: lower_bonud-vector
#+begin_src fortran :exports code :noweb no-export
  !> lower_bound_vector_${suffix}: Return the minimum index that is higher than or equal to `val`.
  integer(int32) function lower_bound_vector_${suffix}(this, val)
    class(vector_${suffix}), intent(in) :: this
    ${type}, intent(in) :: val
    integer(int32) :: p, q, r
    p = 1
    r = this%size_
    if (this%arr_(r) < val) then
       lower_bound_vector_${suffix} = r + 1 + (this%lb_ - 1)
       return
    end if
    do
       q = (p+r)/2
       if (p + 1 > r) exit
       if (this%arr_(q) >= val) then
          r = q
       else
          p = q+1
       end if
    end do
    lower_bound_vector_${suffix} = q + (this%lb_ - 1)
  end function lower_bound_vector_${suffix}
#+end_src
**** error-handling
This handles the error about out-bounded index.
#+name: error-handling-vector-bounds-out
#+begin_src fortran :exports code :noweb no-export
  if (i < this%lbound() .or. i > this%ubound()) then
     <<error-handling-return-ierr(ierr="i - this%lbound()")>>
  #ifdef DEBUG
     <<error-handling-filename>>
     write(error_unit, '(a, *(i0, a))')&
          "Index ", i, " Out of bounds(", this%lbound(), ", ", this%ubound(), ")"
     <<error-handling-exit(err_num=1)>>
  #endif
  end if
#+end_src
**** process definition and procedures of the vector
#+name: wrapped_vector-var
#+begin_src bash :exports code :cache no :shebang #!/bin/bash
  case "${type}" in
      "character")
          type="character"
          suffix="character"
          ;;
      ,*)
          type="${type}(${type_kind})"
          suffix="${type_kind}"
          ;;
  esac
  wvec="wrapped_vector_${suffix}"
#+end_src
#+name: declaration-vector-var
#+begin_src bash :exports code :var type="integer" type_kind="int32" :results output :noweb no-export :cache no :shebang #!/bin/bash
  case "${type}" in
      "character")
          type="character"
          suffix="character"
          ;;
      ,*)
          type="${type}(${type_kind})"
          suffix="${type_kind}"
          ;;
  esac
  cat <<EOF
  <<declaration-vector>>
  EOF
#+end_src
#+name: procedures-vector-var
#+begin_src bash :exports code :var type="integer" type_kind="int32" :results output :noweb no-export :cache no :shebang #!/bin/bash
  case "${type}" in
      "character")
          type="character"
          suffix="character"
          ;;
      ,*)
          type="${type}(${type_kind})"
          suffix="${type_kind}"
          ;;
  esac
  cat <<EOF
  <<procedures-vector>>
  EOF
#+end_src
**** test
#+name: vector-test
#+begin_src fortran :exports code :tangle "test/test_vector.F90" :noweb no-export
  program test_vector
    use, intrinsic :: iso_fortran_env
    use vector_m
    implicit none
    integer(int32) :: i, j
    integer(int32) :: ierr
    integer(int32), parameter :: n = 10, low = 5, high = low+n-1
    type(vector_int32) :: v, v2
    do i = 1, n
       call v%push_back(i)
    end do
    do i = 0, v%size()+1
       j = v%lower_bound(i)
       <<assert(cond="j == max(1, i)", code=11, message="Return value of `lower_bound` is illegal in loop.")>>
    end do
    do i = 1, n
       <<assert(cond="v%at(i) == i" ,code=12)>>
       call v%replace(i, -i)
       <<assert(cond="v%at(i) == -i" ,code=13)>>
    end do
    j = v%at(n+1, ierr)
    <<assert-false(cond="ierr == 0", code=14, message="Return value of `at` is illegal.")>>
    do i = 1, n
       j = v%pop_back()
    end do
    j = v%pop_back(ierr)
    <<assert-false(cond="ierr == 0", code=15, message="Return value of `pop_back` is illegal.")>>

    call v2%init(low, high)
    do i = low, high
       call v2%push_back(i)
    end do
    do i = low-1, high+1
       j = v2%lower_bound(i)
       <<assert(cond="j == max(low, i)", code=21, message="Return value of `lower_bound` is illegal in loop.")>>
    end do
    do i = low, high
       <<assert(cond="v2%at(i) == i" ,code=22)>>
       call v2%replace(i, -i)
       <<assert(cond="v2%at(i) == -i" ,code=23)>>
    end do
    j = v2%at(high+1, ierr)
    <<assert-false(cond="ierr == 0", code=24, message="Return value of `at` is illegal.")>>
    do i = 1, n
       j = v2%pop_back()
    end do
    j = v2%pop_back(ierr)
    <<assert-false(cond="ierr == 0", code=25, message="Return value of `pop_back` is illegal.")>>
  end program test_vector
#+end_src
#+name: test-vector
#+begin_src fortran :flags "-cpp -g -fbacktrace" :exports code :results output :noweb no-export :cache yes
<<vector-module>>
<<vector-test>>
#+end_src

#+RESULTS[40d25dd65db7fe9ba7c78c1b3a9f083b98eb52cd]: test-vector
** queue(未完成)
*** imp
#+begin_src fortran :exports code
module queue_m
  use, intrinsic :: iso_fortran_env
  use unwrapped_vector_m
  implicit none
  private
  public :: queue
  type :: queue
     private
     integer(int32) :: head_, tail_
     type(unwrapped_vector_int32) :: q_
   contains
     procedure, pass :: init => init_queue
     procedure, pass :: push_back => push_back_queue
     procedure, pass :: pop_front => pop_front_queue
     procedure, pass :: size => size_front_queue
     procedure, pass :: empty => empty_front_queue
  end type queue
contains
  subroutine init_queue(this)
    class(queue), intent(inout) :: this
    this%head_ = 1
    this%tail_ = 0
  end subroutine init_queue
  subroutine push_back_queue(this, val)
    class(queue), intent(inout) :: this
    integer(int32), intent(in) :: val
    integer(int32) :: s
    if (this%head_ == this%q_%size()) then
       s = this%tail_ - (this%head_-1)
       this%q_%arr_(1:s) = eoshift(this%q_%arr_(:), shift = this%head_-1)
       this%tail_ = s
       this%head_ = 1
       call this%q_%resize(this%size())
    end if
    this%tail_ = this%tail_ + 1
    call this%q_%push_back(val)
  end subroutine push_back_queue
  integer(int32) function pop_front_queue(this) result(res)
    class(queue), intent(inout) :: this
    res = this%q_%arr_(this%head_)
    this%head_ = this%head_ + 1
  end function pop_front_queue
  pure integer(int32) function size_front_queue(this)
    class(queue), intent(in) :: this
    size_front_queue = this%tail_ - this%head_ + 1
  end function size_front_queue
  pure logical function empty_front_queue(this)
    class(queue), intent(in) :: this
    empty_front_queue = this%tail_ == this%head_ -1
  end function empty_front_queue
end module queue_m
#+end_src
** priority queue
*** whole module of the priority queue
priority queue モジュール全体は以下のとおり.
型毎にnowebマクロを展開する.
#+name: priority_queue-module
#+begin_src fortran :exports code :tangle "src/priority_queue_m.F90" :comment link :noweb no-export
  module priority_queue_m
    use, intrinsic :: iso_fortran_env
    implicit none
    private
    <<declaration-priority_queue-var(type_base="integer", type_kind="int32")>>
    <<declaration-priority_queue-var(type_base="integer", type_kind="int64")>>
    <<declaration-priority_queue-var(type_base="real", type_kind="real32")>>
    <<declaration-priority_queue-var(type_base="real", type_kind="real64")>>
    <<declaration-priority_queue-var(type_base="character")>>
  contains
    <<procedures-priority_queue-var(type_base="integer", type_kind="int32")>>
    <<procedures-priority_queue-var(type_base="integer", type_kind="int64")>>
    <<procedures-priority_queue-var(type_base="real", type_kind="real32")>>
    <<procedures-priority_queue-var(type_base="real", type_kind="real64")>>
    <<procedures-priority_queue-var(type_base="character")>>
  end module priority_queue_m
#+end_src
*** declaration of the priority queue
まず, ~priority_queue~ 型を宣言する.
配列を伸長させて優先度付きキューを実装する.
挿入と削除操作は =O(log n)= で, 先頭の参照は =O(1)= で可能.

~bash~ を用いて ~${variable}~ を展開する.
- ~${pq}~ は優先度付きキューの型の名前である.
- ~${type}~ は優先度付きキューの要素の型の名前である.
- ~${op}~ は `<` か `>`.
#+name: declaration-priority_queue
#+begin_src fortran :exports code
  public :: ${pq}
  type :: ${pq}
     private
     integer(int32) :: size_ = 0_int32, capa_ = 0_int32
     ${type}, allocatable :: arr_(:)
   contains
     procedure, pass :: push  => push_${pq}
     procedure, pass :: pop   => pop_${pq}
     procedure, pass :: front => front_${pq}
     procedure, pass :: size => size_${pq}
     procedure, pass :: empty     => empty_${pq}
     procedure, pass :: not_empty => not_empty_${pq}
     ! procedure, pass :: dump => dump_${pq}
  end type ${pq}
#+end_src
*** procedures of the priority queue
:PROPERTIES:
:header-args: :noweb-ref procedures-priority_queue
:END:
**** push
~push~ はヒープへ要素を追加し, ヒープを再構成する.
#+name: push_priority_queue
#+begin_src fortran :exports code
  !> push_${pq}: adds an element to the heap and reconstructs the heap by ${op} order.
  subroutine push_${pq}(this, val)
    class(${pq}), intent(inout) :: this
    ${type}, intent(in) :: val
    ${type} :: tmp
    integer(int32) :: i
    if (this%size_ == this%capa_) then
       if (this%capa_ == 0) then
          this%capa_ = 1
          allocate(this%arr_(1))
       else
          this%capa_ = 2*this%capa_
          block
            ${type}, allocatable :: tmp_arr(:)
            allocate(tmp_arr(this%capa_))
            tmp_arr(1:this%size_) = this%arr_(1:this%size_)
            call move_alloc(from = tmp_arr, to = this%arr_)
          end block
       end if
    end if
    this%size_ = this%size_ + 1
    ! add `val` to heap.
    this%arr_(this%size_) = val
    i = this%size_
    tmp = val
    upheap:do ! reconstruct the heap by ${op}.
       if (i == 1) then ! top of the heap
          this%arr_(1) = tmp
          exit
       else if (tmp ${op} this%arr_(i/2)) then ! move the element up in the heap
          this%arr_(i) = this%arr_(i/2)
       else ! move the element up in the heap
          this%arr_(i) = tmp
          tmp = this%arr_(i/2)
       end if
       i = i / 2
    end do upheap
  end subroutine push_${pq}
#+end_src
**** pop
~pop~ はヒープへ要素を追加し, ヒープを再構成する.
#+name: pop_priority_queue
#+begin_src fortran :exports code
  !> pop_${pq}: extracts the ${op} element from the heap.
  ${type} function pop_${pq}(this) result(res)
    class(${pq}), intent(inout) :: this
    integer(int32) :: n, prev, next
    ! add `val` to heap.
    ! swap `arr(1)` and `arr(n)` and delete ${op} element, `arr(1)`.
    res = this%arr_(1)
    this%arr_(1) = this%arr_(this%size_)
    this%size_ = this%size_ - 1
    n = this%size_
    ! reconstruct the heap by moving the element `arr(n)` downwards.
    next = 1
    downheap:do ! reconstruct the heap by ${op}.
       prev = next
       if (2*prev > n) exit
       if (this%arr_(2*prev)      ${op} this%arr_(next)) &
            next = 2*prev
       if (2*prev+1 <= n) then
          if (this%arr_(2*prev+1) ${op} this%arr_(next)) &
               next = 2*prev+1
       end if
       if (prev == next) exit ! arr(next) < arr(2*prev) .and. arr(next) < arr(2*prev+1)
       call swap(this%arr_(prev), this%arr_(next))
    end do downheap
  contains
    subroutine swap(x, y)
      ${type}, intent(inout) :: x, y
      ${type} :: tmp
      tmp = x
      x   = y
      y   = tmp
    end subroutine swap
  end function pop_${pq}
#+end_src
**** front
~front~ は ヒープの一番上(minimum or maximum)の要素を返す.
#+name: front_priority_queue
#+begin_src fortran :exports code
  !> front_${pq}: returns the top of the element of the heap, which has either the minimum or maximum value depending on the type of heap.
  pure ${type} function front_${pq}(this) result(res)
    class(${pq}), intent(in) :: this
    res = this%arr_(1)
  end function front_${pq}
#+end_src
**** size
~size~ はヒープの要素数を返す.
#+name: size_priority_queue
#+begin_src fortran :exports code
  !> size_${pq}: returns the size of the heap.
  pure integer(int32) function size_${pq}(this) result(res)
    class(${pq}), intent(in) :: this
    res = this%size_
  end function size_${pq}
#+end_src
**** empty
~empty~ はヒープが空の場合は.true.を返す.
#+name: empty_priority_queue
#+begin_src fortran :exports code
  !> empty_${pq}: returns if heap is empty or not.
  pure logical function empty_${pq}(this) result(res)
    class(${pq}), intent(in) :: this
    res = this%size_ == 0
  end function empty_${pq}
#+end_src
**** not_empty
~not_empty~ はヒープが空の場合は.true.を返す.
#+name: not_empty_priority_queue
#+begin_src fortran :exports code
  !> not_empty_${pq}: returns if heap is not empty or empty.
  pure logical function not_empty_${pq}(this) result(res)
    class(${pq}), intent(in) :: this
    res = .not. this%empty()
  end function not_empty_${pq}
#+end_src
**** dump
~dump~
#+name: dump_priority_queue
#+begin_src fortran :exports code
  ! !> dump_${pq}: output the heap.
  ! subroutine dump_${pq}(this)
  !   class(${pq}), intent(in) :: this
  !   write(error_unit, '(*(g0, 1x))') this%arr_(1:this%size_)
  ! end subroutine dump_${pq}
#+end_src
*** process definition and procedures of the priority queue
#+name: priority_queue-var
#+begin_src bash :exports code :cache no :shebang #!/bin/bash
  case "${type_base}" in
      "character")
          type="${type_base}"
          suffix="${type_base}"
          ;;
      "type")
          type="type(${type_kind})"
          suffix="${type_kind}"
          ;;
      ,*)
          type="${type_base}(${type_kind})"
          suffix="${type_kind}"
          ;;
  esac
  pq="priority_queue"
  case "${op}" in
      "<")
          pq="${pq}_min_${suffix}"
      ;;
      ">")
          pq="${pq}_max_${suffix}"
      ;;
  esac
#+end_src
#+name: declaration-priority_queue-var
#+begin_src bash :exports code :var type_base="integer" type_kind="int32" :results output :noweb no-export :cache no :shebang #!/bin/bash
  for op in "<" ">"
  do
  <<priority_queue-var>>
  cat <<EOF
  <<declaration-priority_queue>>
  EOF
  done
#+end_src
#+name: procedures-priority_queue-var
#+begin_src bash :exports code :var type_base="integer" type_kind="int32" :results output :noweb no-export :cache no :shebang #!/bin/bash
  for op in "<" ">"
  do
  <<priority_queue-var>>
  cat <<EOF
  <<procedures-priority_queue>>
  EOF
  done
#+end_src
*** test
**** test本体
#+name: test-priority_queue
#+begin_src fortran :flags "-cpp -g -fbacktrace -fcheck=bounds" :exports code :results output :noweb no-export :cache yes
<<priority_queue-module>>
<<priority_queue-test>>
#+end_src

#+RESULTS[40adba9cd1b63a4b844c758c105e0cc6643b255d]: test-priority_queue

**** testプログラム
#+name: priority_queue-test
#+begin_src fortran :exports code :tangle "test/test_priority_queue.F90" :noweb no-export
  program test_priority_queue
    use, intrinsic :: iso_fortran_env
    use priority_queue_m
    implicit none
    integer(int32), parameter :: n = 20, arr(n) = [10, 1, 11, 2, 12, 3, 13, 4, 14, 5, 15, 6, 16, 7, 17, 8, 18, 9, 19, 20]
    integer(int32) :: i
    type(priority_queue_min_int32) :: pq_min
    type(priority_queue_max_int32) :: pq_max
    <<assert(cond="pq_min%empty()", code=1, message="pq_min must be empty.")>>
    <<assert(cond="pq_max%empty()", code=2, message="pq_max must be empty.")>>
    do i = 1, n
       call pq_min%push(arr(i))
       call pq_max%push(arr(i))
    end do
    <<assert(cond="pq_min%not_empty()", code=3, message="pq_min must be not empty.")>>
    <<assert(cond="pq_max%not_empty()", code=4, message="pq_max must be not empty.")>>
    <<assert-eq(eq1="n", eq2="pq_min%size()", code=10, message="The size of pq_min is illegal.")>>
    <<assert-eq(eq1="n", eq2="pq_max%size()", code=11, message="The size of pq_max is illegal.")>>
    do i = 1, n
       block
         integer(int32) :: val
         val = pq_min%pop()
         <<assert-eq(eq1="i", eq2="val", code=12, message="The value of pq_min%pop() is illegal.")>>
         val = pq_max%pop()
         <<assert-eq(eq1="n-i+1", eq2="val", code=13, message="The value of pq_max%pop() is illegal.")>>
       end block
    end do
  end program test_priority_queue
#+end_src

** double ended queue
#+begin_src fortran :exports code
  module vec_deque_m
    use, intrinsic :: iso_fortran_env
    implicit none
    integer(int32), parameter :: init_size = 4
    type :: vec_deque
       private
       integer(int32) :: size_ = 0, capa_ = 0
       integer(int32) :: head_, tail_
       integer(int32), allocatable :: arr_(:)
     contains
       procedure, pass :: init => init_vec_deque
       procedure, pass :: resize => resize_vec_deque
       procedure, pass :: push_front => push_front_vec_deque
       procedure, pass :: push_back  => push_back_vec_deque
       procedure, pass :: pop_front  => pop_front_vec_deque
       procedure, pass :: pop_back   => pop_back_vec_deque
       procedure, pass :: to_array => to_array_vec_deque
       procedure, pass :: debug_print => debug_print_vec_deque
    end type vec_deque
  contains
    subroutine init_vec_deque(this)
      class(vec_deque), intent(inout) :: this
      if (allocated(this%arr_)) return
      allocate(this%arr_(init_size))
      this%size_ = 0
      this%capa_ = init_size
      this%head_ = this%capa_
      this%tail_ = 1
    end subroutine init_vec_deque
    subroutine resize_vec_deque(this, capa)
      class(vec_deque), intent(inout) :: this
      integer(int32), intent(in) :: capa
      integer(int32) :: s
      integer(int32), allocatable :: tmp(:)
      if (capa <= this%size_) return
      allocate(tmp(capa))
      if (this%head_ < this%tail_) then
         !> (1???h...t???c), ...が意味のあるデータ, ???が意味のないデータ.
         tmp(this%head_+1:this%tail_-1) = this%arr_(this%head_+1:this%tail_-1)
         call move_alloc(from = tmp, to = this%arr_)
      else !> this%head_ >= this%tail_
         !> (1...t????h...c).
         tmp(1:this%tail_-1) = this%arr_(1:this%tail_-1)
         s = this%capa_ - (this%head_ + 1)
         tmp(capa-s:capa) = this%arr_(this%capa_-s:this%capa_)
         this%head_ = capa - s - 1
         call move_alloc(from = tmp, to = this%arr_)
      end if
      this%capa_ = capa
    end subroutine resize_vec_deque
    subroutine push_front_vec_deque(this, v)
      class(vec_deque), intent(inout) :: this
      integer(int32), intent(in) :: v
      if (this%head_ == this%tail_) then
         call this%resize(this%capa_*2)
      end if
      this%arr_(this%head_) = v
      this%head_ = this%head_ - 1
      if (this%head_ < 1) this%head_ = this%capa_
      this%size_ = this%size_ + 1
    end subroutine push_front_vec_deque
    subroutine push_back_vec_deque(this, v)
      class(vec_deque), intent(inout) :: this
      integer(int32), intent(in) :: v
      if (this%head_ == this%tail_) then
         call this%resize(this%capa_*2)
      end if
      this%arr_(this%tail_) = v
      this%tail_ = this%tail_ + 1
      if (this%tail_ > this%capa_) this%tail_ = 1
      this%size_ = this%size_ + 1
    end subroutine push_back_vec_deque
    integer(int32) function pop_front_vec_deque(this) result(res)
      class(vec_deque), intent(inout) :: this
      if (this%size_ == 0) then
         write(error_unit, '(a)') "Error in pop_front: vec_deque is empty."
         error stop 1
      end if
      this%size_ = this%size_ - 1
      this%head_ = this%head_ + 1
      if (this%head_ > this%capa_) this%head_ = 1
      res = this%arr_(this%head_)
    end function pop_front_vec_deque
    integer(int32) function pop_back_vec_deque(this) result(res)
      class(vec_deque), intent(inout) :: this
      if (this%size_ == 0) then
         write(error_unit, '(a)') "Error in pop_back: vec_deque is empty."
         error stop 1
      end if
      this%size_ = this%size_ - 1
      this%tail_ = this%tail_ - 1
      if (this%tail_ < 1) this%tail_ = this%capa_
      res = this%arr_(this%tail_)
    end function pop_back_vec_deque
    pure function to_array_vec_deque(this) result(res)
      class(vec_deque), intent(in) :: this
      integer(int32), allocatable :: res(:)
      allocate(res(this%size_))
      if (this%head_ < this%tail_) then
         !> (1???h...t???c), ...が意味のあるデータ, ???が意味のないデータ.
         res(:) = this%arr_(this%head_+1:this%tail_-1)
      else !> this%head_ <= this%tail_
         !> (1...t????h...c).
         res(1:this%capa_-this%head_) = this%arr_(this%head_+1:this%capa_)
         res(this%capa_-this%head_+1:this%size_) = this%arr_(1:this%tail_-1)
      end if
    end function to_array_vec_deque
    subroutine debug_print_vec_deque(this, unit)
      class(vec_deque), intent(in) :: this
      integer(int32), intent(in) :: unit
      write(error_unit, '(2(i0, 1x), a, *(i0, 1x))') this%head_, this%tail_, ": ", this%arr_(:)
      write(unit, '(*(i0, 1x))') this%to_array()
    end subroutine debug_print_vec_deque
  end module vec_deque_m
#+end_src
** Hash table
*** open addressing hash by double hash
We implement open addressing hash table that use double hash by ~Fortran~.
The size of hash table is \(m\).
We cannot store the number of elements that is over \(m\).
**** The whole module of the hash table
This is the whole module.
The element of hash table is below.
#+name: hash_table-module
#+begin_src fortran :exports code :tangle "src/hash_table_m.F90" :comment link :noweb no-export
  module hash_table_m
    use, intrinsic :: iso_fortran_env
    implicit none
    private
    integer, parameter :: max_elem = 701, small_m = 700, cardinal = 128
    public :: size

    type :: variable_char
       character(len=:), allocatable :: s
    end type variable_char
    <<expand-declaration-hash_table(type="integer", type_kind="int32")>>
    <<expand-declaration-hash_table(type="integer", type_kind="int64")>>
    <<expand-declaration-hash_table(type="real", type_kind="real32")>>
    <<expand-declaration-hash_table(type="real", type_kind="real64")>>
  contains

    pure integer(int32) function hash1(key)
      character(len=*), intent(in) :: key
      integer(int32) :: h, i
      h = 0_int32
      do i = len(key), 1, -1
         h = mod(h * cardinal + ichar(key(i:i)), max_elem)
      end do
      hash1 = h
    end function hash1
    pure integer(int32) function hash2(key)
      character(len=*), intent(in) :: key
      integer(int32) :: h, i
      h = 0_int32
      do i = len(key), 1, -1
         h = mod(h * cardinal + ichar(key(i:i)), small_m)
      end do
      hash2 = h + 1
    end function hash2

    <<expand-procedures-hash_table(type="integer", type_kind="int32")>>
    <<expand-procedures-hash_table(type="integer", type_kind="int64")>>
    <<expand-procedures-hash_table(type="real", type_kind="real32")>>
    <<expand-procedures-hash_table(type="real", type_kind="real64")>>
  end module hash_table_m
#+end_src
**** The type declaration of the hash table
#+name: declaration-hash_table
#+begin_src fortran :exports code
  public :: ${hash_table}
  type :: ${hash_table}
     private
     integer(int32) :: num_elems_
     type(variable_char), allocatable :: keys_(:)
     ${type_elements}, allocatable :: elems_(:)
     logical, allocatable :: vacancy_(:)
     logical, allocatable :: deleted_(:)
   contains
     procedure, pass :: insert => insert_${hash_table}
     procedure, pass :: delete => delete_${hash_table}
     procedure, pass :: search => search_${hash_table}
     procedure, pass :: write_${hash_table}
     generic :: write(formatted) => write_${hash_table}
  end type ${hash_table}

  interface ${hash_table}
     module procedure :: init_${hash_table}
  end interface ${hash_table}
  interface size
     module procedure :: size_${hash_table}
  end interface
#+end_src
**** The procedures of the hash table
#+name: procedures-hash_table
#+begin_src fortran :exports code :noweb no-export
    <<init-hash_table>>
    <<size-hash_table>>
    <<insert-hash_table>>
    <<delete-hash_table>>
    <<search-hash_table>>
    <<write-hash_table>>
#+end_src
***** initialize
#+name: init-hash_table
#+begin_src fortran :exports code
  impure type(${hash_table}) function init_${hash_table}() result(res)
    res%num_elems_ = 0
    allocate(res%elems_(0:max_elem-1))
    allocate(res%keys_(0:max_elem-1))
    allocate(res%vacancy_(0:max_elem-1), source = .true.)
    allocate(res%deleted_(0:max_elem-1), source = .false.)
  end function init_${hash_table}
#+end_src
***** size
#+name: size-hash_table
#+begin_src fortran :exports code
  pure integer(int32) function size_${hash_table}(ht) result(res)
    type(${hash_table}), intent(in) :: ht
    res = ht%num_elems_
  end function size_${hash_table}
#+end_src
***** insert-hash_table
Insert =val= into hash table.
If =key= is already in the hash table, change to new =val= corresponding to =key=.
#+name: insert-hash_table
#+begin_src fortran :exports code :noweb no-export
  subroutine insert_${hash_table} (this, key, val, ierr)
    class(${hash_table}), intent(inout) :: this
    character(len=*), intent(in) :: key
    ${type_elements}, intent(in) :: val
    integer(int32), optional, intent(out) :: ierr
    integer(int32) :: h1, h2, pos, i
    <<error-handing-initialize-ierr-hash_table>>
    h1 = hash1(key)
    h2 = hash2(key)
    pos = h1
    do i = 1, max_elem
       if (this%vacancy_(pos)) then
          this%keys_(pos)%s = key
          this%elems_(pos) = val
          this%vacancy_(pos) = .false.
          this%num_elems_ = this%num_elems_ + 1
          return
       else if (this%keys_(pos)%s == key) then
          this%elems_(pos) = val
          return
       end if
       pos = mod(pos + h2, max_elem)
    end do
    <<error-handing-capacity-over-hash_table>>
  end subroutine insert_${hash_table}
#+end_src
#+name: error-handing-initialize-ierr-hash_table
#+begin_src fortran :exports code
    if (present(ierr)) ierr = 0
#+end_src
#+name: error-handing-capacity-over-hash_table
#+begin_src fortran :exports code
    write(error_unit, '(a)') "Size limit: Hash table is too large."
    write(error_unit, '(a, i0)') __FILE__//": ", __LINE__
    if (present(ierr)) then
       ierr = 1
    else
       error stop 1
    end if
#+end_src
***** delete-hash_table
#+name: delete-hash_table
#+begin_src fortran :exports code
  subroutine delete_${hash_table} (this, key, found)
    class(${hash_table}), intent(inout) :: this
    character(len=*), intent(in) :: key
    logical, optional, intent(out) :: found
    integer(int32) :: h1, h2, pos, i
    h1 = hash1(key)
    h2 = hash2(key)
    pos = h1
    do i = 1, max_elem
       if (this%vacancy_(pos) .and. (.not. this%deleted_(pos))) exit
       if (this%keys_(pos)%s == key) then
          this%vacancy_(pos) = .true.
          this%deleted_(pos) = .true.
          this%num_elems_ = this%num_elems_ - 1
          if (present(found)) found = .true.
          return
       end if
       pos = mod(pos + h2, max_elem)
    end do
    if (present(found)) found = .false.
  end subroutine delete_${hash_table}
#+end_src
***** search-hash_table
#+name: search-hash_table
#+begin_src fortran :exports code
  ${type_elements} function search_${hash_table} (this, key, found) result(res)
    class(${hash_table}), intent(in) :: this
    character(len=*), intent(in) :: key
    logical, optional, intent(out) :: found
    integer(int32) :: h1, h2, pos, i
    res = -1
    h1 = hash1(key)
    h2 = hash2(key)
    pos = h1
    do i = 1, max_elem
       if (this%vacancy_(pos) .and. (.not. this%deleted_(pos))) exit
       if (this%keys_(pos)%s == key) then
          res = this%elems_(pos)
          if (present(found)) found = .true.
          return
       end if
       pos = mod(pos + h2, max_elem)
    end do
    if (present(found)) found = .false.
  end function search_${hash_table}
#+end_src
***** write-hash_table
#+name: write-hash_table
#+begin_src fortran :exports code
  subroutine write_${hash_table}(this, unit, iotype, v_list, iostat, iomsg)
    class(${hash_table}), intent(in) :: this
    integer             , intent(in)    :: unit
    character(len=*)    , intent(in)    :: iotype
    integer             , intent(in)    :: v_list(:)
    integer             , intent(out)   :: iostat
    character(len=*)    , intent(inout) :: iomsg
    integer(int32) :: i
    do i = 0, max_elem-1
       if (.not. this%vacancy_(i)) then
          write(unit, fmt='(a, i0, a, g18.10)', advance = "No", iostat=iostat, iomsg=iomsg) &
               "|", i, ": ht["//this%keys_(i)%s//"] => ", this%elems_(i)
       end if
    end do
  end subroutine write_${hash_table}
#+end_src
**** process definition and procedures of hash table
#+name: expand-hash_table
#+begin_src bash :exports code :shebang #!/bin/bash
   case "${type}" in
      "character")
          type_elements="type(variable_char)"
          type_val="character(len=:), allocatable"
          hash_table="hash_table_character"
          ;;
      ,*)
          type_elements="${type}(${type_kind})"
          type_val="${type_elements}"
          hash_table="hash_table_${type_kind}"
          ;;
  esac
#+end_src
#+name: expand-declaration-hash_table
#+begin_src bash :exports code :var type="integer" type_kind="int32" :results output :noweb no-export :cache no :shebang #!/bin/bash
  <<expand-hash_table>>
  cat <<EOF
  <<declaration-hash_table>>
  EOF
#+end_src
#+name: expand-procedures-hash_table
#+begin_src bash :exports code :var type="integer" type_kind="int32" :results output :noweb no-export :cache no :shebang #!/bin/bash
  <<expand-hash_table>>
  cat <<EOF
  <<procedures-hash_table>>
  EOF
#+end_src
**** test
#+name: hash_table-test
#+begin_src fortran :exports code :tangle "test/test_hash_table.f90" :comments link
  program test_hash_table
    use, intrinsic :: iso_fortran_env
    use hash_table_m
    implicit none
    integer(int32) :: v, i, j, k, ierr
    logical :: found
    character(len=:), allocatable :: s
    type(hash_table_int32) :: ht_i32, ht_i32_2
    ht_i32 = hash_table_int32()
    !> check empty character.
    call ht_i32%insert("", 0, ierr=ierr)
    v = ht_i32%search("", found=found)
    if (.not. found) then
       write(error_unit, *) "Empty string '' not found or not inserted..."
       error stop 2
    end if
    if (v /= 0) then
       write(error_unit, *) "Value of arr[''] must be 0"
       error stop 3
    end if
    !> check size
    !> insert 701 elements
    !> first, insert 10*10*7 elements
    do i = ichar("a"), ichar("a")+10-1
       do j = ichar("A"), ichar("A")+10-1
          do k = ichar(" "), ichar(" ")+7-1
             s = achar(i)//achar(j)//achar(k)
             call ht_i32%insert(s, 128**2*i+128*j+k, ierr)
          end do
       end do
    end do
    call ht_i32%insert("abcde", 0, ierr) ! size of hash table is maximum
    if (ierr == 0) then
       write(error_unit, *) "Insert in fully hash table must fail...", size(ht_i32)
       error stop 4
    end if
    call ht_i32%delete("aB$", found) ! delete elements in hash table.
    if (.not. found) then
       write(error_unit, *) "Delete failed...", size(ht_i32)
       error stop 5
    end if
    call ht_i32%insert("abcdef", 0, ierr) ! be able to insert
    if (ierr /= 0) then
       write(error_unit, *) "Delete or insert failed..."
       error stop 6
    end if
    !> insert 700 elements
    !> delete 700 elements
    !> first, insert 10*10*7 elements
    ht_i32_2 = hash_table_int32()
    do i = ichar("a"), ichar("a")+10-1
       do j = ichar("A"), ichar("A")+10-1
          do k = ichar(" "), ichar(" ")+7-1
             s = achar(i)//achar(j)//achar(k)
             call ht_i32_2%insert(s, 0, ierr)
             call ht_i32_2%delete(s, found=found)
             if (ierr /= 0) then
                write(error_unit, *) "Insert failed...", size(ht_i32_2)
                error stop 7
             end if
             if (.not. found) then
                write(error_unit, *) "Insert and Delete failed...", size(ht_i32_2)
                error stop 8
             end if
          end do
       end do
    end do
    if (size(ht_i32_2) /= 0) then
       write(error_unit, *) "Insert and delete failed...", size(ht_i32_2)
       error stop 9
    end if
    !> insert 700 elements
    !> delete 700 elements
    !> insert 700 elements
    !> first, insert 10*10*7 elements
    ht_i32_2 = hash_table_int32()
    do i = ichar("a"), ichar("a")+10-1
       do j = ichar("A"), ichar("A")+10-1
          do k = ichar(" "), ichar(" ")+7-1
             s = achar(i)//achar(j)//achar(k)
             call ht_i32_2%insert(s, 0)
             call ht_i32_2%delete(s, found=found)
             call ht_i32_2%insert(s, 0, ierr)
             if (ierr /= 0) then
                write(error_unit, *) "Insert failed...", size(ht_i32_2)
                error stop 10
             end if
             if (.not. found) then
                write(error_unit, *) "Delete failed...", size(ht_i32_2)
                error stop 11
             end if
          end do
       end do
    end do
    if (size(ht_i32_2) /= 700) then
       write(error_unit, *) "Insert and delete and insert failed...", size(ht_i32_2)
       error stop 12
    end if
  end program test_hash_table
#+end_src
#+name: test-hash_table
#+begin_src fortran :flags -g -fbacktrace -fcheck=all :exports code :results output :noweb no-export :cache yes
<<hash_table-module>>
<<hash_table-test>>
#+end_src

#+RESULTS[7012e9003deba0e9eb25cf053fa62c3a4d23f793]: test-hash_table

** COMMENT tree
*** binary_tree
We implement a binary tree that consists of the root, the pointers to its children, and some keys by ~Fortran~.
The keys of the binary tree are not duplicated.
**** The whole module of binary tree
This is the whole module of the binary tree.
The declaration [[cref:expand-declaration-binary_tree]] and procedures [[cref:expand-declaration-binary_tree]] are below.
#+name: binary-tree-module
#+begin_src fortran :exports code :tangle "src/binary_tree_m.f90" :comment link :noweb no-export
  module binary_tree_m
    use, intrinsic :: iso_fortran_env
    use comparable_m
    implicit none
    private
    public :: size
    public :: depth
    <<expand-declaration-binary-tree(type="integer", type_kind="int32")>>
    <<expand-declaration-binary-tree(type="integer", type_kind="int64")>>
    <<expand-declaration-binary-tree(type="comparable", type_kind="class")>>
  contains
    <<expand-procedures-binary-tree(type="integer", type_kind="int32")>>
    <<expand-procedures-binary-tree(type="integer", type_kind="int64")>>
    <<expand-procedures-binary-tree(type="comparable", type_kind="class")>>
  end module binary_tree_m
#+end_src
**** The type declaration of the binary tree
${type_key} is the type of key that is comparable.
${type_element} is the type of elements.
#+name: declaration-binary-tree
#+begin_src fortran :exports code
  public :: ${binary_tree}
  type :: ${binary_tree}
     private
     integer(int32) :: num_elems_ = 0
     type(${binary_tree_node}), pointer :: root_ => null()
   contains
     procedure, pass :: insert => insert_${binary_tree}
     procedure, pass :: delete => delete_${binary_tree}
     ! procedure, pass :: search => search_${binary_tree}
     procedure, pass :: minimum => minimum_${binary_tree}
     procedure, pass :: maximum => maximum_${binary_tree}
     procedure, pass :: begin => begin_${binary_tree}
     procedure, pass :: end   => end_${binary_tree}
     procedure, pass :: to_array         => to_array_${binary_tree}
     procedure, pass :: to_array_reverse => to_array_reverse_${binary_tree}
     procedure, pass :: write_${binary_tree}
     generic :: write(formatted) => write_${binary_tree}
  end type ${binary_tree}
  public :: ${binary_tree_iterator}
  type :: ${binary_tree_iterator}
     private
     type(${binary_tree_node}), pointer :: ptr_ => null()
   contains
     procedure, pass :: val => val_${binary_tree_iterator}
     procedure, pass :: next => next_${binary_tree_iterator}
     procedure, pass :: pred => pred_${binary_tree_iterator}
     procedure, pass :: is_null => is_null_${binary_tree_iterator}
     procedure, pass :: to => to_${binary_tree_iterator}
  end type ${binary_tree_iterator}
  type :: ${binary_tree_node}
     private
     ${type_element} :: elem_
     type(${binary_tree_node}), pointer :: p_     => null()
     type(${binary_tree_node}), pointer :: left_  => null()
     type(${binary_tree_node}), pointer :: right_ => null()
   contains
     procedure, pass :: minimum   => minimum_${binary_tree_node}
     procedure, pass :: maximum   => maximum_${binary_tree_node}
     procedure, pass :: successor   => successor_${binary_tree_node}
     procedure, pass :: predecessor => predecessor_${binary_tree_node}
  end type ${binary_tree_node}

  interface ${binary_tree}
     module procedure :: init_${binary_tree}, init_${binary_tree}_by_arr
  end interface ${binary_tree}
  interface ${binary_tree_node}
     module procedure :: init_${binary_tree_node}
  end interface ${binary_tree_node}
  interface size
     module procedure :: size_${binary_tree}
  end interface size
  interface depth
     module procedure :: depth_${binary_tree}
  end interface depth
#+end_src
**** The procedures of the binary tree
:PROPERTIES:
:header-args: :noweb-ref procedures-binary-tree
:END:
***** initialize the binary tree
There are two procedures for initializing.
The first procedure initializes the values to zero or null.
#+begin_src fortran :exports code
  impure type(${binary_tree}) function init_${binary_tree}() result(res)
    res%num_elems_ = 0
    res%root_ => null()
  end function init_${binary_tree}
#+end_src
The second procedure initializes the values by elements of an array.
#+begin_src fortran :exports code
  impure type(${binary_tree}) function init_${binary_tree}_by_arr(arr) result(res)
    ${type_element}, intent(in) :: arr(:)
    integer(int32) :: i, n
    res%num_elems_ = 0
    n = size(arr)
    do i = 1, n
       call res%insert(arr(i))
    end do
  end function init_${binary_tree}_by_arr
#+end_src
#+begin_src fortran :exports code
  impure function init_${binary_tree_node}(val) result(node)
    type(${binary_tree_node}), pointer :: node
    ${type_element}, intent(in) :: val
    allocate(node)
    node%elem_  = val
    node%p_     => null()
    node%left_  => null()
    node%right_ => null()
    return
  end function init_${binary_tree_node}
#+end_src
***** insert an element in the binary tree
The subroutine that inserts an element into the binary tree.
If the root of tree is null, we create the new node in the root of tree.
#+begin_src fortran :exports code
  subroutine insert_${binary_tree}(tree, val)
    class(${binary_tree}), intent(inout) :: tree
    ${type_element}, intent(in) :: val
    type(${binary_tree_node}), pointer :: node, new_node, parent
    new_node => ${binary_tree_node}(val)
    parent => null()
    node => tree%root_
    if (.not. associated(node)) then
       tree%root_  => new_node
       new_node%p_ => null()
       tree%num_elems_ = 1
       return
    end if
    do
       if (val == node%elem_) then
          return
       else if (val < node%elem_) then
          parent => node
          node   => node%left_
          if (.not. associated(node)) then
             parent%left_ => new_node
             new_node%p_  => parent
             tree%num_elems_ = tree%num_elems_ + 1
             return
          end if
       else
          parent => node
          node   => node%right_
          if (.not. associated(node)) then
             parent%right_ => new_node
             new_node%p_   => parent
             tree%num_elems_ = tree%num_elems_ + 1
             return
          end if
       end if
    end do
  end subroutine insert_${binary_tree}
#+end_src
***** delete an element in the binary tree
#+begin_src fortran :exports code
  subroutine delete_${binary_tree}(tree, val)
    class(${binary_tree}), intent(inout) :: tree
    ${type_element}, intent(in) :: val
    type(${binary_tree_node}), pointer :: child, left, right
    if (.not. associated(tree%root_)) then
       return
    end if
    child => tree%root_
    do
       !> undefined...
    end do
  end subroutine delete_${binary_tree}
#+end_src
***** the minimum value in the binary tree
#+begin_src fortran :exports code
  ${type_element} function minimum_${binary_tree}(tree) result(mini)
    class(${binary_tree}), intent(in) :: tree
    type(${binary_tree_node}), pointer :: node, min_node
    if (.not. associated(tree%root_)) then
       write(error_unit, *) "Manipulation to empty tree is not allowed."
       return
    end if
    node => tree%root_
    min_node => node%minimum()
    mini = min_node%elem_
  end function minimum_${binary_tree}
#+end_src
***** the maximum value in the binary tree
#+begin_src fortran :exports code
  ${type_element} function maximum_${binary_tree}(tree) result(maxi)
    class(${binary_tree}), intent(in) :: tree
    type(${binary_tree_node}), pointer :: node, max_node
    if (.not. associated(tree%root_)) then
       write(error_unit, *) "Manipulation to empty tree is not allowed."
       return
    end if
    node => tree%root_
    max_node => node%maximum()
    maxi = max_node%elem_
  end function maximum_${binary_tree}
#+end_src
***** the begin node in the binary tree
#+begin_src fortran :exports code
  function begin_${binary_tree}(tree) result(begin)
    class(${binary_tree}), intent(in) :: tree
    type(${binary_tree_node}), pointer :: begin
    if (.not. associated(tree%root_)) then
       write(error_unit, *) "Manipulation to empty tree is not allowed."
       return
    end if
    begin => tree%root_%minimum()
  end function begin_${binary_tree}
#+end_src
***** the end node in the binary tree
#+begin_src fortran :exports code
  function end_${binary_tree}(tree) result(end)
    class(${binary_tree}), intent(in) :: tree
    type(${binary_tree_node}), pointer :: end
    if (.not. associated(tree%root_)) then
       write(error_unit, *) "Manipulation to empty tree is not allowed."
       return
    end if
    end => tree%root_%maximum()
  end function end_${binary_tree}
#+end_src
***** Convert the tree to sorted array
#+begin_src fortran :exports code
  subroutine to_array_${binary_tree}(tree, arr)
    class(${binary_tree}), intent(in) :: tree
    ${type_element}, intent(out) :: arr(:)
    type(${binary_tree_iterator}) :: iter
    type(${binary_tree_node}), pointer :: beg_ptr
    integer(int32) :: i
    beg_ptr => tree%begin()
    call iter%to(beg_ptr)
    do i = 1, size(tree)
       if (iter%is_null()) exit
       arr(i) = iter%val()
       call iter%next()
    end do
  end subroutine to_array_${binary_tree}
  subroutine to_array_reverse_${binary_tree}(tree, arr)
    class(${binary_tree}), intent(in) :: tree
    ${type_element}, intent(out) :: arr(:)
    type(${binary_tree_iterator}) :: iter
    type(${binary_tree_node}), pointer :: end_ptr
    integer(int32) :: i
    end_ptr => tree%end()
    call iter%to(end_ptr)
    do i = 1, size(tree)
       if (iter%is_null()) exit
       arr(i) = iter%val()
       call iter%pred()
    end do
  end subroutine to_array_reverse_${binary_tree}
#+end_src
***** COMMENT search an element in the binary tree
The search is not necessarily...?
#+begin_src fortran :exports code
  logical function search_${binary_tree}(tree, val) result(found)
    class(${binary_tree}), intent(in) :: tree
    ${type_element}, intent(in) :: val
    !> undefined...
  end function search_${binary_tree}
#+end_src
***** node
****** minimum
The function minimum returns a pointer to the minimum node under the tree node.
#+begin_src fortran :exports code
  function minimum_${binary_tree_node}(this) result(min_node)
    class(${binary_tree_node}), target, intent(in) :: this
    type(${binary_tree_node}) , pointer :: min_node
    min_node => this
    do
       if (.not. associated(min_node%left_)) return
       min_node => min_node%left_
    end do
  end function minimum_${binary_tree_node}
#+end_src
****** maximum
The function maximum returns a pointer to the maximum node under the tree node.
#+begin_src fortran :exports code
  function maximum_${binary_tree_node}(this) result(max_node)
    class(${binary_tree_node}), target, intent(in) :: this
    type(${binary_tree_node}) , pointer :: max_node
    max_node => this
    do
       if (.not. associated(max_node%right_)) return
       max_node => max_node%right_
    end do
  end function maximum_${binary_tree_node}
#+end_src
****** successor
The function successor returns a pointer to the node whose next larger value.
#+begin_src fortran :exports code
  function successor_${binary_tree_node}(this) result(succ)
    class(${binary_tree_node}), target, intent(in) :: this
    type(${binary_tree_node}) , pointer :: succ
    succ => this
    if (associated(succ%right_)) then ! succ has right.
       succ => succ%right_%minimum()
       return
    end if
    do
       if (.not. associated(succ%p_)) then
          succ => null()
          return
       else if (associated(succ, succ%p_%left_)) then
          succ => succ%p_
          return
       end if
       succ => succ%p_
    end do
  end function successor_${binary_tree_node}
#+end_src
****** predecessor
The function successor returns a pointer to the node whose next larger value.
#+begin_src fortran :exports code
  function predecessor_${binary_tree_node}(this) result(pred_node)
    class(${binary_tree_node}), target, intent(in) :: this
    type(${binary_tree_node}) , pointer :: node, pred_node
    node => this
    if (associated(node%left_)) then ! node has left.
       pred_node => node%left_%maximum()
       return
    end if
    do
       if (.not. associated(node%p_)) then
          pred_node => null()
          return
       else if (associated(node, node%p_%right_)) then
          pred_node => node%p_
          return
       end if
       node => node%p_
    end do
  end function predecessor_${binary_tree_node}
#+end_src
***** iterator
****** point to node
#+begin_src fortran :exports code
  subroutine to_${binary_tree_iterator}(iter, node_ptr)
    class(${binary_tree_iterator}), intent(out) :: iter
    type(${binary_tree_node}), pointer, intent(in) :: node_ptr
    iter%ptr_ => node_ptr
  end subroutine to_${binary_tree_iterator}
#+end_src
****** val
#+begin_src fortran :exports code
  ${type_element} function val_${binary_tree_iterator}(iter) result(res)
    class(${binary_tree_iterator}), intent(in) :: iter
    res = iter%ptr_%elem_
  end function val_${binary_tree_iterator}
#+end_src
****** next
#+begin_src fortran :exports code
  subroutine next_${binary_tree_iterator}(iter)
    class(${binary_tree_iterator}), intent(inout) :: iter
    if (associated(iter%ptr_)) iter%ptr_ => iter%ptr_%successor()
  end subroutine next_${binary_tree_iterator}
#+end_src
****** pred
#+begin_src fortran :exports code
  subroutine pred_${binary_tree_iterator}(iter)
    class(${binary_tree_iterator}), intent(inout) :: iter
    iter%ptr_ => iter%ptr_%predecessor()
  end subroutine pred_${binary_tree_iterator}
#+end_src
****** is_null
#+begin_src fortran :exports code
  logical function is_null_${binary_tree_iterator}(iter) result(is_null)
    class(${binary_tree_iterator}), intent(in) :: iter
    is_null = .not. associated(iter%ptr_)
  end function is_null_${binary_tree_iterator}
#+end_src
***** size
#+begin_src fortran :exports code
  pure integer(int32) function size_${binary_tree}(tree) result(res)
    type(${binary_tree}), intent(in) :: tree
    res = tree%num_elems_
  end function size_${binary_tree}
#+end_src
***** depth
#+begin_src fortran :exports code
  integer(int32) function depth_${binary_tree}(tree) result(res)
    type(${binary_tree}), intent(in) :: tree
    type(${binary_tree_node}), pointer :: child
    child => tree%root_
    if (.not. associated(child)) then
       res = 0
    end if
    res = depth_${binary_tree_node}(child)
  end function depth_${binary_tree}
  pure recursive integer(int32) function depth_${binary_tree_node}(node) result(res)
    type(${binary_tree_node}), intent(in) :: node
    logical :: exist_left, exist_right
    exist_left  = associated(node%left_)
    exist_right = associated(node%right_)
    if (exist_left .and. exist_right) then
       res = 1 + max(depth_${binary_tree_node}(node%left_)&
            , depth_${binary_tree_node}(node%right_))
    else if (exist_left) then
       res = 1 + depth_${binary_tree_node}(node%left_)
    else if (exist_right) then
       res = 1 + depth_${binary_tree_node}(node%right_)
    else
       res = 1
    end if
  end function depth_${binary_tree_node}
#+end_src
***** write the whole elements in the binary tree
#+begin_src fortran :exports code
  subroutine write_${binary_tree}(this, unit, iotype, v_list, iostat, iomsg)
    class(${binary_tree}), intent(in) :: this
    type(${binary_tree_iterator}) :: iter
    integer              , intent(in)    :: unit
    character(len=*)     , intent(in)    :: iotype
    integer              , intent(in)    :: v_list(:)
    integer              , intent(out)   :: iostat
    character(len=*)     , intent(inout) :: iomsg
    if (.not. associated(this%root_)) return
    write(unit, *, iostat=iostat, iomsg=iomsg) "| "
    call print_nodes_${binary_tree}(this%root_, unit=unit, iostat=iostat, iomsg=iomsg)
    write(unit, *, iostat=iostat, iomsg=iomsg) "| "
  end subroutine write_${binary_tree}

  recursive subroutine print_nodes_${binary_tree}(node, unit, iostat, iomsg)
    type(${binary_tree_node}), intent(in) :: node
    integer         , intent(in)    :: unit
    integer         , intent(out)   :: iostat
    character(len=*), intent(inout) :: iomsg
    if (associated(node%left_)) call print_nodes_${binary_tree}(node%left_, unit=unit, iostat=iostat, iomsg=iomsg)
    write(unit, *, iostat=iostat, iomsg=iomsg) node%elem_
    if (associated(node%right_)) call print_nodes_${binary_tree}(node%right_, unit=unit, iostat=iostat, iomsg=iomsg)
  end subroutine print_nodes_${binary_tree}
#+end_src
**** expand
#+name: expand-binary-tree
#+begin_src bash :exports code :shebang #!/bin/bash
  case "${type_kind}" in
      "type")
          suffix="type_${type}"
          type_element="type(${type})"
          ;;
      "class")
          suffix="class_${type}"
          type_element="class(${type}), allocatable"
          ;;
      ,*)
          suffix="${type_kind}"
          type_element="${type}(${type_kind})"
          ;;
  esac
  binary_tree="binary_tree_${suffix}"
  binary_tree_node="binary_tree_node_${suffix}"
  binary_tree_iterator="binary_tree_iterator_${suffix}"
#+end_src
#+name: expand-declaration-binary-tree
#+begin_src bash :exports code :var type="integer" type_kind="int32" :results output :noweb no-export :cache no :shebang #!/bin/bash
  <<expand-binary-tree>>
  cat <<EOF
  <<declaration-binary-tree>>
  EOF
#+end_src
#+name: expand-procedures-binary-tree
#+begin_src bash :exports code :var type="integer" type_kind="int32" :results output :noweb no-export :cache no :shebang #!/bin/bash
  <<expand-binary-tree>>
  cat <<EOF
  <<procedures-binary-tree>>
  EOF
#+end_src
**** test
#+name: binary-tree-test
#+begin_src fortran :exports code :tangle "test/test_binary_tree.f90" :comments link
  program test_binary_tree
    use, intrinsic :: iso_fortran_env
    use is_sorted_m
    use binary_tree_m
    implicit none
    integer(int32) :: i
    type(binary_tree_int32) :: bt_int32, bt2, bt_only_l, bt_only_r
    type(binary_tree_iterator_int32) :: bt_iter
    bt_int32 = binary_tree_int32()
    bt2 = binary_tree_int32([10, 5, 6, 7, 8, 9, 15, 3, 18, 2, 4, 19, 17, 1, 0, -1, -2, 11, 16, 14, 12, 13])
    bt_only_l = binary_tree_int32([(i, i = 10, 1, -1)])
    bt_only_r = binary_tree_int32([(i, i = 1, 10)])
    call bt_int32%insert(10)
    call bt_int32%insert(-11)
    call bt_int32%insert(1)
    call bt_int32%insert(20)
    call bt_int32%insert(17)
    if (size(bt_int32) /= 5) then
       write(error_unit, *) "size error: ", size(bt_int32)
       error stop 1
    end if
    block
      integer(int32) :: sorted_arr(size(bt_only_l)), sorted_arr2(size(bt_only_l))
      call bt_iter%to(bt_only_l%begin())
      do i = 1, size(bt_only_l)
         if (bt_iter%is_null()) exit
         sorted_arr(i) = bt_iter%val()
         call bt_iter%next()
      end do
      if (.not. is_sorted(sorted_arr)) then
         write(error_unit, *) sorted_arr(:)
         error stop 2
      end if
      call bt_only_l%to_array(sorted_arr2)
      if (any(sorted_arr2 /= sorted_arr)) then
         write(error_unit, *) sorted_arr
         write(error_unit, *) sorted_arr2
         error stop 3
      end if
    end block
    block
      integer(int32) :: sorted_arr(size(bt_only_l)), sorted_arr2(size(bt_only_l))
      call bt_iter%to(bt_only_l%end())
      do i = 1, size(bt_only_l)
         if (bt_iter%is_null()) exit
         sorted_arr(i) = bt_iter%val()
         call bt_iter%pred()
      end do
      if (.not. is_sorted_descending(sorted_arr)) then
         write(error_unit, *) sorted_arr(:)
         error stop 4
      end if
      call bt_only_l%to_array_reverse(sorted_arr2)
      if (any(sorted_arr2 /= sorted_arr)) then
         write(error_unit, *) sorted_arr
         write(error_unit, *) sorted_arr2
         error stop 5
      end if
    end block
    block
      integer(int32) :: sorted_arr(size(bt_only_r)), sorted_arr2(size(bt_only_r))
      call bt_iter%to(bt_only_r%end())
      do i = 1, size(bt_only_r)
         if (bt_iter%is_null()) exit
         sorted_arr(i) = bt_iter%val()
         call bt_iter%pred()
      end do
      if (.not. is_sorted_descending(sorted_arr)) then
         write(error_unit, *) sorted_arr(:)
         error stop 6
      end if
      call bt_only_r%to_array_reverse(sorted_arr2)
      if (any(sorted_arr2 /= sorted_arr)) then
         write(error_unit, *) sorted_arr
         write(error_unit, *) sorted_arr2
         error stop 7
      end if
    end block
    block
      integer(int32) :: sorted_arr(size(bt2)), sorted_arr2(size(bt2))
      call bt_iter%to(bt2%begin())
      do i = 1, size(bt2)
         if (bt_iter%is_null()) exit
         sorted_arr(i) = bt_iter%val()
         call bt_iter%next()
      end do
      if (.not. is_sorted(sorted_arr)) then
         write(error_unit, *) sorted_arr(:)
         error stop 8
      end if
      call bt2%to_array(sorted_arr2)
      if (any(sorted_arr2 /= sorted_arr)) then
         write(error_unit, *) sorted_arr
         write(error_unit, *) sorted_arr2
         error stop 9
      end if
    end block
  end program
#+end_src
#+name: test-binary-tree
#+begin_src fortran :flags -g -fbacktrace -fcheck=all :exports code :results output :noweb no-export :cache yes
<<is-sorted-module>>
<<binary-tree-module>>
<<binary-tree-test>>
#+end_src

#+RESULTS[64e568d1e9d4160a294eced8983afb6ee0a5d3d8]: test-binary-tree

*** integer tree
#+begin_src fortran :exports code :results output :cache yes
  module tree_int_m
    use, intrinsic :: iso_fortran_env
    implicit none
    private
    public :: tree_parent_int

    type :: tree_parent_int
       private
       type(tree_int), pointer :: parent
    end type tree_parent_int

    type :: tree_int
       private
       integer(int32)          :: val
       type(tree_int), pointer :: left, right
     contains
       procedure :: add => add_tree_int
    end type tree_int

    interface tree_int
       module procedure :: init_tree_int
    end interface tree_int

  contains

    subroutine add_tree_int(this, v)
      class(tree_int), intent(inout) :: this
      integer        , intent(in)    :: v

    end subroutine add_tree_int

  end module tree_int_m
#+end_src

** B-Tree
*** B木モジュールの全体
Rustに倣ってB木を実装する.
\(t = 6\) でノード内の内部ノードの数は \(2t-1 = 11\) とする.
=iter_max_depth= は30程度あればよい(というか過剰).
#+name: btree-module
#+begin_src fortran :exports code :tangle "src/btree_m.F90" :comment link :noweb no-export
  module btree_m
    use, intrinsic :: iso_fortran_env
    implicit none
    private
    !> `t-1` must be the least number of elements in `btree_node` without root (minimum degree).
    integer(int32), parameter :: t = 6
    !> the number of internal node in `btree_node`.
    integer(int32), parameter :: inode = 2*t-1
    integer(int32), parameter :: iter_max_depth = 30
    <<declaration-btree-var(key_base="integer", key_kind="int32", val_base="integer", val_kind="int32")>>
    <<declaration-btree-var(key_base="integer", key_kind="int64", val_base="integer", val_kind="int64")>>
    <<declaration-btree-var(key_base="character", key_kind="100", val_base="integer", val_kind="int32")>>
    <<declaration-btree-var(key_base="character", key_kind="100", val_base="integer", val_kind="int64")>>
  contains
    <<procedures-btree-var(key_base="integer", key_kind="int32", val_base="integer", val_kind="int32")>>
    <<procedures-btree-var(key_base="integer", key_kind="int64", val_base="integer", val_kind="int64")>>
    <<procedures-btree-var(key_base="character", key_kind="100", val_base="integer", val_kind="int32")>>
    <<procedures-btree-var(key_base="character", key_kind="100", val_base="integer", val_kind="int64")>>
  end module btree_m
#+end_src
*** B木の型宣言
#+name: declaration-btree
#+begin_src fortran :exports code
  !> pointer to ${btree_node}.
  type :: ${btree_node_ptr}
     type(${btree_node}), pointer :: p_ => null()
   contains
     procedure, pass :: size => size_${btree_node_ptr}
     procedure, pass :: is_leaf => is_leaf_${btree_node_ptr}
     procedure, pass :: get_iter => get_iter_${btree_node_ptr}
     procedure, pass :: split_child => split_child_${btree_node_ptr}
     procedure, pass :: insert => insert_${btree_node_ptr}
     procedure, pass :: remove     => remove_${btree_node_ptr}
     procedure, pass :: remove_key => remove_key_${btree_node_ptr}
     procedure, pass :: merge_children => merge_children_${btree_node_ptr}
     procedure, pass :: rotate_left  => rotate_left_${btree_node_ptr}
     procedure, pass :: rotate_right => rotate_right_${btree_node_ptr}
     procedure, pass :: shrink_left  => shrink_left_${btree_node_ptr}
     procedure, pass :: expand_right => expand_right_${btree_node_ptr}
     procedure, pass :: print => print_${btree_node_ptr}
     procedure, pass :: check_invariant => check_invariant_${btree_node_ptr}
  end type ${btree_node_ptr}
  !> node of B-Tree.
  type :: ${btree_node}
     integer(int32) :: nelem_ = 0
     ${key} :: key_(inode)
     ${val} :: val_(inode)
     type(${btree_node_ptr}) :: children_(inode+1)
     logical :: is_leaf_ = .true.
  end type ${btree_node}

  public :: ${btree}
  !> `${btree}` has pointer to root of B-Tree.
  type :: ${btree}
     private
     type(${btree_node_ptr}) :: root_
     integer(int32) :: size_   = 0
     integer(int32) :: height_ = 0
   contains
     procedure, pass :: size   => size_${btree}
     procedure, pass :: height => height_${btree}
     procedure, pass :: init   => init_${btree}
     procedure, pass :: get      => get_${btree}
     procedure, pass :: get_iter => get_iter_${btree}
     procedure, pass :: contains => contains_${btree}
     procedure, pass :: insert => insert_${btree}
     procedure, pass :: remove => remove_${btree}
     procedure, pass :: minimum => minimum_${btree}
     procedure, pass :: maximum => maximum_${btree}
     procedure, pass :: minimum_iter => minimum_iter_${btree}
     procedure, pass :: maximum_iter => maximum_iter_${btree}
     ! procedure, pass :: lower_bound => lower_bound_${btree}
     ! procedure, pass :: upper_bound => upper_bound_${btree}
     procedure, pass :: print => print_${btree}
     procedure, pass :: check_invariant => check_invariant_${btree}
  end type ${btree}
  public ${btree_node_iter}
  type :: ${btree_node_iter}
     private
     integer(int32) :: idx_ = -1 !> [1:iter%nptr_%size()], ノード内の節点を指す.
     type(${btree_node_ptr}) :: nptr_
     integer(int32) :: depth_ = 1
     integer(int32) :: indices_(iter_max_depth) !> [1:iter%nptr_%size()+1], 下ったポインタのインデックス.
     type(${btree_node_ptr}) :: parents_(iter_max_depth)
   contains
     procedure, pass :: key => key_${btree_node_iter}
     procedure, pass :: val => val_${btree_node_iter}
     procedure, pass :: mut_val => mut_val_${btree_node_iter}
     procedure, pass :: next => next_${btree_node_iter}
     procedure, pass :: prev => prev_${btree_node_iter}
     procedure, pass :: is_begin     => is_begin_${btree_node_iter}
     procedure, pass :: is_not_begin => is_not_begin_${btree_node_iter}
     procedure, pass :: is_end     => is_end_${btree_node_iter}
     procedure, pass :: is_not_end => is_not_end_${btree_node_iter}
     procedure, pass :: exist     => exist_${btree_node_iter}
     procedure, pass :: not_exist => not_exist_${btree_node_iter}
  end type ${btree_node_iter}
#+end_src
*** B木 の実装
:PROPERTIES:
:header-args: :noweb-ref procedures-btree
:END:
**** btree のメソッド
***** initialize
B木を初期化する.
#+name: initialize_btree
#+begin_src fortran :exports code
  subroutine init_${btree}(this)
    class(${btree}), intent(inout) :: this
    type(${btree_node}), pointer :: x
    allocate(x)
    x%is_leaf_ = .true.
    x%nelem_ = 0
    this%size_   = 0
    this%height_ = 0
    this%root_%p_ => x
  end subroutine init_${btree}
#+end_src
***** size
B木に含まれている要素数を返す.
#+name: size_btree
#+begin_src fortran :exports code
  pure integer(int32) function size_${btree}(this) result(res)
    class(${btree}), intent(in) :: this
    res = this%size_
  end function size_${btree}
#+end_src
***** height
B木の高さを返す.
#+name: height_btree
#+begin_src fortran :exports code
  pure integer(int32) function height_${btree}(this) result(res)
    class(${btree}), intent(in) :: this
    res = this%height_
  end function height_${btree}
#+end_src
***** get
`key` の位置の値を返す.
#+name: get_btree
#+begin_src fortran :exports code
  ${val} function get_${btree}(this, key) result(res)
    class(${btree}), intent(in) :: this
    ${key}, intent(in) :: key
    type(${btree_node_iter}) :: iter
    iter = this%root_%get_iter(key)
    if (iter%idx_ /= -1) then
       res = iter%nptr_%p_%val_(iter%idx_)
    else
    end if
  end function get_${btree}
#+end_src
***** get_iter
`key` を指す iterator を返す.
#+name: get_iter_btree
#+begin_src fortran :exports code
  type(${btree_node_iter}) function get_iter_${btree}(this, key) result(res)
    class(${btree}), intent(in) :: this
    ${key}, intent(in) :: key
    res = this%root_%get_iter(key)
  end function get_iter_${btree}
#+end_src
***** contains
`key` がB木の中に含まれているかを返す.
#+name: contains_btree
#+begin_src fortran :exports code
  logical function contains_${btree}(this, key) result(res)
    class(${btree}), intent(in) :: this
    ${key}, intent(in) :: key
    type(${btree_node_iter}) :: iter
    iter = this%root_%get_iter(key)
    res = iter%idx_ /= -1
  end function contains_${btree}
#+end_src
***** insert
`key` の位置に `val` を挿入する.
実装は `btree_node_ptr` 任せる.
#+name: insert_btree
#+begin_src fortran :exports code
  subroutine insert_${btree}(this, key, val)
    class(${btree}), intent(inout) :: this
    ${key}, intent(in) :: key
    ${val}, intent(in) :: val
    type(${btree_node_ptr}) :: r
    type(${btree_node_iter}) :: iter
    r%p_ => this%root_%p_
    if (r%p_%nelem_ == 2*t - 1) then
       block
         type(${btree_node_ptr}) :: s
         allocate(s%p_)
         this%root_%p_ => s%p_
         s%p_%is_leaf_ = .false.
         s%p_%nelem_ = 0
         s%p_%children_(1)%p_ => r%p_
         call s%split_child(1)
         this%height_ = this%height_ + 1
         iter = s%insert(key, val)
       end block
    else
       iter = r%insert(key, val)
    end if
    if (iter%idx_ > 0) &
         this%size_ = this%size_ + 1
  end subroutine insert_${btree}
#+end_src
***** remove
`key` をB木から削除する.
実装は `btree_node_ptr` に任せる.
#+name: remove_btree
#+begin_src fortran :exports code
  subroutine remove_${btree}(this, key)
    class(${btree}), intent(inout) :: this
    ${key}, intent(in) :: key
    type(${btree_node_ptr}) :: tmp
    call this%root_%remove(key)
    if (this%root_%p_%nelem_ == 0 .and. (.not. this%root_%is_leaf())) then
       tmp%p_ => this%root_%p_
       this%root_%p_ => this%root_%p_%children_(1)%p_
       deallocate(tmp%p_)
       nullify(tmp%p_)
       this%height_ = this%height_ - 1
    end if
    this%size_ = this%size_ - 1
  end subroutine remove_${btree}
#+end_src
***** minimum
#+name: minimum_btree
#+begin_src fortran :exports code
  !> minimum_${btree}: Return the minimum value.
  ${key} function minimum_${btree}(this) result(res)
    class(${btree}), intent(in) :: this
    type(${btree_node_iter}) :: iter
    iter = this%minimum_iter()
    res = iter%key()
  end function minimum_${btree}
#+end_src
***** minimum_iter
最小値の場所を指す ${btree_node_iter} を返す.
#+name: minimum_iter_${btree}
#+begin_src fortran :exports code
  !> minimum_iter_${btree}: Return the iterator to node that has minimum key.
  type(${btree_node_iter}) function minimum_iter_${btree}(this) result(res)
    class(${btree}), intent(in) :: this
    res%nptr_%p_ => this%root_%p_
    res%depth_ = 1
    res%idx_ = 0
    call res%next()
  end function minimum_iter_${btree}
#+end_src
***** maximum
#+name: maximum_btree
#+begin_src fortran :exports code
  !> maximum_${btree}: Return the maximum value.
  ${key} function maximum_${btree}(this) result(res)
    class(${btree}), intent(in) :: this
    type(${btree_node_iter}) :: iter
    iter = this%maximum_iter()
    res = iter%key()
  end function maximum_${btree}
#+end_src
***** maximum_iter
#+name: maximum_iter_btree
#+begin_src fortran :exports code
  !> maximum_iter_${btree}: Return the iterator to node that has maximum key.
  type(${btree_node_iter}) function maximum_iter_${btree}(this) result(res)
    class(${btree}), intent(in) :: this
    res%nptr_%p_ => this%root_%p_
    res%depth_ = 1
    res%idx_ = res%nptr_%size() + 1
    call res%prev()
  end function maximum_iter_${btree}
#+end_src
***** COMMENT lower_bound => lower_bound_${btree}
#+name: lower_bound_btree
#+begin_src fortran :exports code
#+end_src
***** COMMENT upper_bound => upper_bound_${btree}
#+name: upper_bound_btree
#+begin_src fortran :exports code
#+end_src
***** print
デバッグ用. 全ての要素をprintする.
#+name: print_btree
#+begin_src fortran :exports code
  !> print_btree: Print whole node in B-tree for debug.
  !> For debug.
  subroutine print_${btree}(this, unit)
    class(${btree}), intent(in) :: this
    integer(int32), intent(in) :: unit
    if (associated(this%root_%p_)) &
         call this%root_%print(unit, 0)
  end subroutine print_${btree}
#+end_src
***** check_invariant
デバッグ用.
B木の不変条件:
- `root` を除く `node` は最小でも `t-1` 個の `key` を持つ.
- 左側の `key` は右側の `key` よりも小さい.
を確かめる.
#+name: check_invariant_btree
#+begin_src fortran :exports code
  !> check_invariant_${btree}: Check invariant for debug.
  !> invariant condition: The number of keys of each node in B-tree excluded root node must have at least `t - 1` keys.
  !> The keys in left children is less than key of current node.
  !> The keys in right children is greater than key of current node.
  subroutine check_invariant_${btree}(this)
    class(${btree}), intent(in) :: this
    type(${btree_node_iter}) :: bt_iter
    ${key} :: k, k_bef
    integer(int32) :: i
    if (this%size() == 0) return
    bt_iter = this%minimum_iter()
    k_bef = bt_iter%key()
    call bt_iter%next()
    do while (bt_iter%is_not_end())
       k = bt_iter%key()
       ! write(error_unit, *) k_bef, k
       if (k_bef >= k) then
          write(error_unit, '(a)') "Error: B-tree is not ordered."
          write(error_unit, '(a)') "Something wrong occurred in 'minimum_iter' or 'next'."
          error stop 5
       end if
       k_bef = k
       call bt_iter%next()
    end do
    bt_iter = this%maximum_iter()
    k_bef = bt_iter%key()
    call bt_iter%prev()
    do while (bt_iter%is_not_begin())
       k = bt_iter%key()
       ! write(error_unit, *) k_bef, k
       if (k_bef <= k) then
          write(error_unit, '(a)') "Error: B-tree is not ordered."
          write(error_unit, '(a)') "Something wrong occurred in 'maximum_iter' or 'prev'."
          error stop 6
       end if
       k_bef = k
       call bt_iter%prev()
    end do
    if (this%root_%is_leaf()) return
    do i = 1, this%root_%size() + 1
       call this%root_%p_%children_(i)%check_invariant()
    end do
  end subroutine check_invariant_${btree}
#+end_src
**** btreee_node_ptr のメソッド
***** size
B木のノードに含まれている要素数を返す.
#+name: size_btree_node_ptr
#+begin_src fortran :exports code
  pure integer(int32) function size_${btree_node_ptr}(this) result(res)
    class(${btree_node_ptr}), intent(in) :: this
    res = this%p_%nelem_
  end function size_${btree_node_ptr}
#+end_src
***** is_leaf
ノードが葉か否かを返す.
#+name: is_leaf_btree_node_ptr
#+begin_src fortran :exports code
  pure logical function is_leaf_${btree_node_ptr}(this) result(res)
    class(${btree_node_ptr}), intent(in) :: this
    res = this%p_%is_leaf_
  end function is_leaf_${btree_node_ptr}
#+end_src
***** get_iter
`key` の位置を指す iterator を返す.
#+name: get_iter_btree_node_ptr
#+begin_src fortran :exports code :noweb no-export
  type(${btree_node_iter}) function get_iter_${btree_node_ptr}(this, key) result(res)
    class(${btree_node_ptr}), intent(in) :: this
    ${key}, intent(in) :: key
    integer(int32) :: pos
    res%nptr_%p_ => this%p_
    if (res%nptr_%size() == 0) then
       res%idx_ = -1
       return
    end if
    res%depth_ = 1
    do !> search `i+1`, which satisfied arr(pos) < key <= arr(pos+1), arr(0) == -infinity, arr(n+1) == +infinity
       pos = lower_bound(1, res%nptr_%size(), res%nptr_%p_%key_(1:res%nptr_%size()), key)
       ! write(error_unit, '(3(a, i0, 1x), *(i0, 1x))') "pos: ", pos, "key: ", key, "arr: ", res%nptr_%p_%key_(1:res%nptr_%size())
       !> key <= key_(pos)
       if (pos <= res%nptr_%size()) then
          if (res%nptr_%p_%key_(pos) == key) then !> key found.
             res%idx_ = pos
             return
          end if
       end if
       if (res%nptr_%is_leaf()) exit
       res%indices_(res%depth_) = pos
       res%parents_(res%depth_)%p_ => res%nptr_%p_
       res%nptr_%p_ => res%nptr_%p_%children_(pos)%p_
       res%depth_ = res%depth_ + 1
    end do
    !> not found.
    nullify(res%nptr_%p_)
    res%idx_ = -1
    return
  contains
    <<btree_sub_lower_bound>>
  end function get_iter_${btree_node_ptr}
#+end_src
***** split_child
`insert` するときに, 不変条件を保つために用いる.
要素数が上限に達した子ノードを分割する.
#+name: split_child_btree_node_ptr
#+begin_src fortran :exports code
  subroutine split_child_${btree_node_ptr}(this, idx)
    class(${btree_node_ptr}), intent(in) :: this
    integer(int32), intent(in) :: idx
    type(${btree_node_ptr}) :: y, z
    integer(int32) :: i
    allocate(z%p_)
    y%p_ => this%p_%children_(idx)%p_
    z%p_%is_leaf_ = y%p_%is_leaf_
    z%p_%nelem_ = t - 1
    do i = 1, t - 1
       z%p_%key_(i) = y%p_%key_(i+t)
       z%p_%val_(i) = y%p_%val_(i+t)
    end do
    if (.not. y%is_leaf()) then
       do i = 1, t
          z%p_%children_(i)%p_ => y%p_%children_(i+t)%p_
       end do
    end if
    y%p_%nelem_ = t - 1
    do i = this%size()+1, idx+1, -1
       this%p_%children_(i+1)%p_ => this%p_%children_(i)%p_
    end do
    this%p_%children_(idx+1)%p_ => z%p_
    do i = this%p_%nelem_, idx, -1
       this%p_%key_(i+1) = this%p_%key_(i)
       this%p_%val_(i+1) = this%p_%val_(i)
    end do
    this%p_%key_(idx) = y%p_%key_(t)
    this%p_%val_(idx) = y%p_%val_(t)
    this%p_%nelem_ = this%p_%nelem_ + 1
  end subroutine split_child_${btree_node_ptr}
#+end_src
***** insert
#+name: insert_btree_node_ptr
#+begin_src fortran :exports code :noweb no-export
  !> insert_${btree_node_ptr}: Insert (`key`, `val`) into B-tree.
  type(${btree_node_iter}) function insert_${btree_node_ptr}(this, key, val) result(res)
    class(${btree_node_ptr}), intent(in) :: this
    ${key}, intent(in) :: key
    ${val}, intent(in) :: val
    type(${btree_node_ptr}) :: x
    integer(int32) :: pos
    x%p_ => this%p_
    if (x%size() == 0) then
       x%p_%key_(1) = key
       x%p_%val_(1) = val
       x%p_%nelem_ = 1
       res%nptr_%p_ => x%p_
       res%idx_ = 1
       return
    end if
    ! write(error_unit, '(L)') x%p_%is_leaf_
    do while (.not. x%is_leaf())
       pos = lower_bound(1, x%size(), x%p_%key_(1:x%size()), key)
       if (x%p_%children_(pos)%size() == 2*t - 1) then
          call x%split_child(pos)
          if (key > x%p_%key_(pos)) pos = pos + 1
       end if
       if (pos <= x%size()) then
          if (key == x%p_%key_(pos)) then
             nullify(res%nptr_%p_)
             res%idx_ = -1
             return
          end if
       end if
       x%p_ => x%p_%children_(pos)%p_
    end do
    pos = lower_bound(1, x%size(), x%p_%key_(1:x%size()), key)
    if (pos <= x%size()) then !> `key` <= `x%p_%key(s)`, where s == x%size().
       if (key == x%p_%key_(pos)) then !> `key` already exists in B-tree.
          nullify(res%nptr_%p_)
          res%idx_ = -1
          return
       else !> expand for insertion.
          call x%expand_right(pos)
       end if
    else !> `key` > `x%p_%key(s)`, where s == x%size().
       x%p_%nelem_ = x%p_%nelem_ + 1
    end if
    ! write(error_unit, '(a, i0, 2(1x, i0))') "insert: ", pos+1, key, x%p_%key_(pos+1)
    x%p_%key_(pos) = key
    x%p_%val_(pos) = val
    res%nptr_%p_ => x%p_
    res%idx_ = pos
  contains
    <<btree_sub_lower_bound>>
  end function insert_${btree_node_ptr}
#+end_src
***** remove
B木から `key` を削除する.
採用したアルゴリズムは "アルゴリズムイントロダクション 第3版 総合版 (世界標準MIT教科書)" を参考にしている.
#+name: remove_btree_node_ptr
#+begin_src fortran :exports code :noweb no-export
  !> remove_${btree_node_ptr}: Remove `key` from B-tree.
  !> invariant condition: the node `this%p_` has at least `t` keys.
  recursive subroutine remove_${btree_node_ptr}(this, key)
    class(${btree_node_ptr}), intent(in) :: this
    ${key}, intent(in) :: key
    type(${btree_node_ptr}) :: x, c
    integer(int32) :: pos, s
    ! write(error_unit, '(a, i0)') "search: ", key
    x%p_ => this%p_
    pos = lower_bound(1, x%size(), x%p_%key_(1:x%size()), key)
    if (x%p_%key_(min(pos, x%size())) == key) then !> `key` exists in current internal node.
       call x%remove_key(key, pos)
       return
    end if
    !> `key` does not exist in current internal node.
    if (x%is_leaf()) then
       write(error_unit, '(a, i0, a)') "key: ", key, " is not found."
       call this%print(error_unit, 0)
       error stop 2
       return
    end if
    c%p_ => x%p_%children_(pos)%p_
    if (c%size() >= t) then
       ! write(error_unit, '(a)') "pattern 3, recursive remove"
       ! remove `key` recurrently.
       call c%remove(key)
       ! write(error_unit, '(a, i0)') "pattern 3 end: ", key
       return
    end if
    !> size of child has `t - 1` keys.
    s = x%size()
    if (pos == s + 1) then
       if (x%p_%children_(s)%size() == t - 1) then
          !> x: _w      key (== x(s))
          !>      \    /   \
          !>       c_to     c_from
          !> ------------------------------
          !> x: _w
          !>       \
          !>         (c_to//key//c_from)
          call x%merge_children(s)
          call x%p_%children_(x%size() + 1)%remove(key)
          ! write(error_unit, '(a, i0)') "pattern 3b end: ", key
          return
       end if
    else !> pos: [1, s]
       if (x%p_%children_(pos+1)%size() == t - 1) then
          !>        key            _w
          !>      /     \        /    \
          !> c_to         c_from        c3
          !> ------------------------------
          !>                    _w
          !>                   /   \
          !> c(c_to//x//c_from)      c3
          call x%merge_children(pos)
          call x%p_%children_(pos)%remove(key)
          ! write(error_unit, '(a, i0)') "pattern 3b end: ", key
          return
       end if
    end if
    !> left or right child have n (>= t) keys.
    ! write(error_unit, '(a, i0)') "pattern 3a: ", key
    if (pos == s + 1) then
       ! write(error_unit, '(a, i0)') "pattern 3a-1: ", key
       !> x:            key
       !>             /     \
       !> (c_from:v1)         c_to
       !> ------------------------------
       !> x:         v1
       !>          /    \
       !>   c_from        (x:c_to)
       call x%rotate_right(s)
       call x%p_%children_(x%size() + 1)%remove(key)
    else !> pos: [1, s]
       ! write(error_unit, '(a, i0)') "pattern 3a-2: ", key
       !>      x
       !> c_to   (v1:c_from)
       !> ------------------------------
       !>          v1
       !> (c_to:x)    c_from
       call x%rotate_left(pos)
       call x%p_%children_(pos)%remove(key)
    end if
    ! write(error_unit, '(a, i0)') "pattern 3a end: ", key
    return
  contains
    <<btree_sub_lower_bound>>
  end subroutine remove_${btree_node_ptr}
#+end_src
***** remove_key
`key` のあるノードから `key` を削除する.
#+name: remove_key_btree_node_ptr
#+begin_src fortran :exports code
  !> remove_key_${btree_node_ptr}: If some of current nodes have `key`, call this.
  recursive subroutine remove_key_${btree_node_ptr}(x, key, pos)
    class(${btree_node_ptr}), intent(in) :: x
    ${key}, intent(in) :: key
    integer(int32), intent(in) :: pos
    !> pos: [1, x%size()].
    if (x%is_leaf()) then
       ! write(error_unit, '(a, i0)') "pattern 1: ", key
       call x%shrink_left(pos, pos)
       return
    end if
    !> x is not leaf.
    if (x%p_%children_(pos)%size() >= t) then
       !> Exchange previous `key` if left child has n (>= t) keys.
       ! write(error_unit, '(a)') "pattern 2a"
       !>   x             _y
       !>  /
       !> c           _c2
       !>  \
       !>   (c':v1)
       !> ------------------------------
       !>   v1     _y
       !>  /
       !> c    _c2
       !>  \
       !>   c'
       block
         ${key} :: key_tmp
         type(${btree_node_ptr}) :: prev
         prev%p_ => x%p_%children_(pos)%p_
         do while (.not. prev%is_leaf())
            prev%p_ => prev%p_%children_(prev%size()+1)%p_
         end do
         key_tmp = prev%p_%key_(prev%size())
         ! write(error_unit, '(a, *(i0, 1x))') "prev: ", key_tmp, key
         call x%remove(key_tmp)
         x%p_%key_(pos) = key_tmp
         ! write(error_unit, '(a, 2(i0, 1x))') "pattern 2a end: ", key, key_tmp
         return
       end block
    else if (x%p_%children_(pos+1)%size() >= t) then !> right child has n (>= t) keys.
       ! write(error_unit, '(a)') "pattern 2b"
       !>     x         _y
       !>           \
       !> _c1         c
       !>            /
       !>     (v1:c')
       !> ------------------------------
       !>     v1   _y
       !>       \
       !> _c1    c
       !>       /
       !>     c'
       block
         ${key} :: key_tmp
         type(${btree_node_ptr}) :: next
         next%p_ => x%p_%children_(pos+1)%p_
         do while (.not. next%is_leaf())
            next%p_ => next%p_%children_(1)%p_
         end do
         key_tmp = next%p_%key_(1)
         ! write(error_unit, '(a, *(i0, 1x))') "next: ", key, key_tmp
         call x%remove(key_tmp)
         x%p_%key_(pos) = key_tmp
         ! write(error_unit, '(a, 2(i0, 1x))') "pattern 2b end: ", key, key_tmp
         return
       end block
    else !> left and right children have `t - 1` keys.
       ! write(error_unit, '(a)') "pattern 2c"
       !>   x                _y
       !> c   c2(deallocate)    _c3
       !> --------------------------------
       !>            _y
       !> (c//x//c2)    _c3
       call x%merge_children(pos)
       call x%p_%children_(pos)%remove(key)
       ! write(error_unit, '(a, i0)') "pattern 2c end: ", key
       return
    end if
  end subroutine remove_key_${btree_node_ptr}
#+end_src
***** merge_children
#+name: merge_children_btree_node_ptr
#+begin_src fortran :exports code
  !> merge_${btree_node_ptr}: Merge left child, middle key and right child.
  !> Then shrink left and deallocate right child.
  !>      x                   _y
  !> left   right(deallocate)    _c
  !> --------------------------------
  !>                  _y
  !> (left//x//right)    _c
  subroutine merge_children_${btree_node_ptr}(x, pos)
    class(${btree_node_ptr}), intent(in) :: x
    integer(int32), intent(in) :: pos
    type(${btree_node_ptr}) :: left, right
    integer(int32) :: i
    left%p_  => x%p_%children_(pos)%p_
    right%p_ => x%p_%children_(pos+1)%p_

    left%p_%key_(t) = x%p_%key_(pos)
    left%p_%val_(t) = x%p_%val_(pos)
    left%p_%key_(t+1:2*t-1) = right%p_%key_(1:t-1)
    left%p_%val_(t+1:2*t-1) = right%p_%val_(1:t-1)
    do i = t+1, 2*t
       left%p_%children_(i)%p_ => right%p_%children_(i-t)%p_
    end do
    left%p_%nelem_ = 2*t - 1
    deallocate(right%p_)
    nullify(right%p_)
    call x%shrink_left(pos, pos+1) ! unlink right child.
  end subroutine merge_children_${btree_node_ptr}
#+end_src
***** rotate_left
#+name: rotate_left_btree_node_ptr
#+begin_src fortran :exports code
  !> rotate_left_${btree_node_ptr}: Rotate keys.
  !> Increase the number of left node keys and decrease that of right node keys.
  !> The number of right node keys must have at least `t` keys.
  !> x:     key
  !>      /     \
  !> left         right(v1:rest)
  !> ------------------------------
  !> x:           v1
  !>            /    \
  !> (left:key)        rest
  subroutine rotate_left_${btree_node_ptr}(x, pos)
    class(${btree_node_ptr}), intent(in) :: x
    integer(int32), intent(in) :: pos
    type(${btree_node_ptr}) :: left, right
    integer(int32) :: ls
    left%p_  => x%p_%children_(pos)%p_
    right%p_ => x%p_%children_(pos+1)%p_
    ls = left%size() + 1
    left%p_%key_(ls) = x%p_%key_(pos)
    left%p_%val_(ls) = x%p_%val_(pos)
    left%p_%children_(ls+1)%p_ => right%p_%children_(1)%p_
    left%p_%nelem_ = ls
    x%p_%key_(pos) = right%p_%key_(1)
    x%p_%val_(pos) = right%p_%val_(1)
    call right%shrink_left(1, 1) !> right%size() -= 1
  end subroutine rotate_left_${btree_node_ptr}
#+end_src
***** rotate_right
#+name: rotate_right_btree_node_ptr
#+begin_src fortran :exports code
  !> rotate_right_${btree_node_ptr}: Rotate keys.
  !> Increase the number of right node keys and decrease that of left node keys.
  !> The number of left node keys must have at least `t` keys.
  !> x:              key
  !>               /     \
  !> left(init:v1)         right
  !> ------------------------------
  !> x:       v1
  !>        /    \
  !>   init        (key:right)
  subroutine rotate_right_${btree_node_ptr}(x, pos)
    class(${btree_node_ptr}), intent(in) :: x
    integer(int32), intent(in) :: pos
    type(${btree_node_ptr}) :: left, right
    left%p_  => x%p_%children_(pos)%p_
    right%p_ => x%p_%children_(pos+1)%p_
    call right%expand_right(1) !> right%size() += 1
    right%p_%key_(1) = x%p_%key_(pos)
    right%p_%val_(1) = x%p_%val_(pos)
    right%p_%children_(1)%p_ => left%p_%children_(left%size() + 1)%p_
    x%p_%key_(pos) = left%p_%key_(left%size())
    x%p_%val_(pos) = left%p_%val_(left%size())
    call left%shrink_left(left%size(), left%size()+1) !> unlink right child.
  end subroutine rotate_right_${btree_node_ptr}
#+end_src
***** shrink_left
#+name: shrink_left_btree_node_ptr
#+begin_src fortran :exports code
  !> shrink_left_${btree_node_ptr}: Remove the `key` and `val` from the `pos` of `this%p_` and shrink it.
  !> before: key(1), key(2), ... key(pos-1), key(pos), key(pos+1), ..., key(s)
  !> after : key(1), key(2), ... key(pos-1), key(pos+1), ..., key(s)
  !> before: child(1), child(2), ... child(pos_child-1), child(pos_child), child(pos_child+1), ..., child(s+1)
  !> after : child(1), child(2), ... child(pos_child-1),                   child(pos_child+1), ..., child(s+1)
  subroutine shrink_left_${btree_node_ptr}(this, pos, pos_child)
    class(${btree_node_ptr}), intent(in) :: this
    integer(int32), intent(in) :: pos, pos_child
    type(${btree_node_ptr}) :: x
    integer(int32) :: s
    integer(int32) :: i
    x%p_ => this%p_
    s = x%size()
    !> copy [pos+1, s] to [pos, s-1].
    !> delete `pos` of array.
    x%p_%key_(pos:s-1) = x%p_%key_(pos+1:s)
    x%p_%val_(pos:s-1) = x%p_%val_(pos+1:s)
    x%p_%nelem_ = s - 1
    if (x%is_leaf()) return
    do i = pos_child, s
       x%p_%children_(i)%p_ => x%p_%children_(i+1)%p_
    end do
  end subroutine shrink_left_${btree_node_ptr}
#+end_src
***** expand_right
#+name: expand_right_btree_node_ptr
#+begin_src fortran :exports code
  subroutine expand_right_${btree_node_ptr}(this, pos)
    class(${btree_node_ptr}), intent(in) :: this
    integer(int32), intent(in) :: pos
    type(${btree_node_ptr}) :: x
    integer(int32) :: s
    integer(int32) :: i
    x%p_ => this%p_
    s = x%size()
    !> copy [pos, s] to [pos+1, s+1].
    !> `pos` of array is empty.
    x%p_%key_(pos+1:s+1) = x%p_%key_(pos:s)
    x%p_%val_(pos+1:s+1) = x%p_%val_(pos:s)
    x%p_%nelem_ = s + 1
    if (x%is_leaf()) return
    do i = s+1, pos, -1
       x%p_%children_(i+1)%p_ => x%p_%children_(i)%p_
    end do
  end subroutine expand_right_${btree_node_ptr}
#+end_src
***** print
#+name: print_btree_node_ptr
#+begin_src fortran :exports code
  recursive subroutine print_${btree_node_ptr}(this, unit, depth)
    class(${btree_node_ptr}), intent(in) :: this
    integer(int32), intent(in) :: unit, depth
    type(${btree_node_ptr}) :: x
    integer(int32) :: i
    x%p_ => this%p_
    write(unit, *) repeat("|", min(1, depth))//repeat("-", depth), depth, ": ", x%p_%key_(1:x%size())
    if (x%is_leaf()) return
    do i = 1, x%p_%nelem_ + 1
       call x%p_%children_(i)%print(unit, depth + 1)
    end do
  end subroutine print_${btree_node_ptr}
#+end_src
***** check_invariant
#+name: check_invariant_btree_node_ptr
#+begin_src fortran :exports code
  recursive subroutine check_invariant_${btree_node_ptr}(this)
    class(${btree_node_ptr}), intent(in) :: this
    integer(int32) :: i
    if (this%size() < t - 1) then
       write(error_unit, '(a)') "Error: invariant, node must have at least `t - 1` keys."
       error stop 1
    end if
    if (this%is_leaf()) return
    do i = 1, this%size() + 1
       call this%p_%children_(i)%check_invariant()
    end do
  end subroutine check_invariant_${btree_node_ptr}
#+end_src
**** btreee_node_iter のメソッド
***** key
#+name: key_btree_node_ptr
#+begin_src fortran :exports code
  impure ${key} function key_${btree_node_iter}(this) result(res)
    class(${btree_node_iter}), intent(in) :: this
    res = this%nptr_%p_%key_(this%idx_)
  end function key_${btree_node_iter}
#+end_src
***** val
#+name: val_btree_node_iter
#+begin_src fortran :exports code
  impure ${val} function val_${btree_node_iter}(this) result(res)
    class(${btree_node_iter}), intent(in) :: this
    res = this%nptr_%p_%val_(this%idx_)
  end function val_${btree_node_iter}
#+end_src
***** mut_val
#+name: mut_val_btree_node_iter
#+begin_src fortran :exports code
  subroutine mut_val_${btree_node_iter}(this, val)
    class(${btree_node_iter}), intent(in) :: this
    ${val}, intent(in) :: val
    type(${btree_node_ptr}) :: x
    x%p_ => this%nptr_%p_
    x%p_%val_(this%idx_) = val
  end subroutine mut_val_${btree_node_iter}
#+end_src
***** next
#+name: next_btree_node_iter
#+begin_src fortran :exports code
  subroutine next_${btree_node_iter}(this)
    class(${btree_node_iter}), intent(inout) :: this
    if (this%is_end()) then
       write(error_unit, '(a)') "Error in `next`: exceed end of iterator."
       error stop 4
    end if
    if (this%nptr_%is_leaf()) then
       this%idx_ = this%idx_ + 1
       if (this%idx_ <= this%nptr_%size()) return
       !> this%idx_ == this%nptr_%size() + 1.
       do !> visit parent of current node if `this%idx_` exceeds the range of `this%nptr_%p_%key_(1:s)`, where s == this%nptr_%size().
          if (this%depth_ == 1) return !> end of iterator if `this%idx_ == this%nptr_%size() + 1` and `this%nptr_%p_` is root of B-tree.
          this%depth_ = this%depth_ - 1
          this%nptr_%p_ => this%parents_(this%depth_)%p_
          this%idx_ = this%indices_(this%depth_)
          nullify(this%parents_(this%depth_)%p_)
          if (this%idx_ <= this%nptr_%size()) return !> this%idx_: [1:s], where s == this%nptr_%size().
       end do
    else !> visit right node and then visit the most left value.
       this%parents_(this%depth_)%p_ => this%nptr_%p_
       this%indices_(this%depth_) = this%idx_ + 1
       this%depth_ = this%depth_ + 1
       this%nptr_%p_ => this%nptr_%p_%children_(this%idx_ + 1)%p_
       do while (.not. this%nptr_%is_leaf())
          this%parents_(this%depth_)%p_ => this%nptr_%p_
          this%indices_(this%depth_) = 1
          this%depth_ = this%depth_ + 1
          this%nptr_%p_ => this%nptr_%p_%children_(1)%p_
       end do
       !> this%nptr_%is_leaf() is .true..
       this%idx_ = 1
    end if
  end subroutine next_${btree_node_iter}
#+end_src
***** prev
#+name: prev_btree_node_iter
#+begin_src fortran :exports code
  subroutine prev_${btree_node_iter}(this)
    class(${btree_node_iter}), intent(inout) :: this
    if (this%is_begin()) then !> `this%idx_ == 0` and `this%p_` is root of B-tree.
       !> beginning of iterator.
       write(error_unit, '(a)') "Error in `prev`: beginning of iterator."
       error stop 4
    end if
    if (this%nptr_%is_leaf()) then
       this%idx_ = this%idx_ - 1
       if (this%idx_ >= 1) return
       !> this%idx_ == 0
       do !> visit parent of current node if `this%idx_` exceeds the range of `this%nptr_%p_%key_(1:s)`, where s == this%nptr_%size().
          if (this%depth_ == 1) return !> beginning of iterator if `this%idx_ == 0` and `this%p_` is root of B-tree.
          this%depth_ = this%depth_ - 1
          this%nptr_%p_ => this%parents_(this%depth_)%p_
          nullify(this%parents_(this%depth_)%p_)
          this%idx_ = this%indices_(this%depth_) - 1
          if (this%idx_ >= 1) return !> this%idx_: [1:s], where s == this%nptr_%size().
       end do
    else !> visit left node and then visit the most right value.
       this%parents_(this%depth_)%p_ => this%nptr_%p_
       this%indices_(this%depth_) = this%idx_
       this%depth_ = this%depth_ + 1
       this%nptr_%p_ => this%nptr_%p_%children_(this%idx_)%p_
       do while (.not. this%nptr_%is_leaf())
          this%parents_(this%depth_)%p_ => this%nptr_%p_
          this%indices_(this%depth_) = this%nptr_%size() + 1
          this%depth_ = this%depth_ + 1
          this%nptr_%p_ => this%nptr_%p_%children_(this%nptr_%size() + 1)%p_
       end do
       !> this%nptr_%is_leaf() is .true.
       this%idx_ = this%nptr_%size()
    end if
  end subroutine prev_${btree_node_iter}
#+end_src
***** is_begin
#+name: is_begin_btree_node_iter
#+begin_src fortran :exports code
  !> is_begin_${btree_node_iter}: return iter is begining of B-tree.
  logical function is_begin_${btree_node_iter}(this) result(res)
    class(${btree_node_iter}), intent(in) :: this
    res = this%depth_ == 1 .and. this%idx_ == 0
  end function is_begin_${btree_node_iter}
#+end_src
***** is_not_begin
#+name: is_not_begin_btree_node_iter
#+begin_src fortran :exports code
  !> is_not_begin_${btree_node_iter}: return iter is not begining of B-tree.
  logical function is_not_begin_${btree_node_iter}(this) result(res)
    class(${btree_node_iter}), intent(in) :: this
    res = .not. this%is_begin()
  end function is_not_begin_${btree_node_iter}
#+end_src
***** is_end
#+name: is_end_btree_node_iter
#+begin_src fortran :exports code
  !> is_end_${btree_node_iter}: return iter is end of B-tree.
  logical function is_end_${btree_node_iter}(this) result(res)
    class(${btree_node_iter}), intent(in) :: this
    res = this%depth_ == 1 .and. this%idx_ == this%nptr_%size() + 1
  end function is_end_${btree_node_iter}
#+end_src
***** is_not_end
#+name: is_not_end_btree_node_iter
#+begin_src fortran :exports code
  !> is_not_end_${btree_node_iter}: return iter is not end of B-tree.
  logical function is_not_end_${btree_node_iter}(this) result(res)
    class(${btree_node_iter}), intent(in) :: this
    res = .not. this%is_end()
  end function is_not_end_${btree_node_iter}
#+end_src
***** exist
#+name: exist_btree_node_iter
#+begin_src fortran :exports code
  logical function exist_${btree_node_iter}(this) result(res)
    class(${btree_node_iter}), intent(in) :: this
    res = this%idx_ /= -1
  end function exist_${btree_node_iter}
#+end_src
***** not_exist
#+name: not_exist_btree_node_iter
#+begin_src fortran :exports code
  logical function not_exist_${btree_node_iter}(this) result(res)
    class(${btree_node_iter}), intent(in) :: this
    res = .not. this%exist()
  end function not_exist_${btree_node_iter}
#+end_src
*** 補助関数
**** lower_bound
#+name: btree_sub_lower_bound
#+begin_src fortran :exports code
  !> lower_bound: search `i+1`, which satisfied arr(i) < key <= arr(i+1), arr(0) == -infinity.
  pure integer(int32) function lower_bound(lb, ub, arr, key) result(res)
    integer(int32), intent(in) :: lb, ub
    ${key}, intent(in) :: arr(lb:ub)
    ${key}, intent(in) :: key
    integer(int32) :: p, q, r
    p = lb
    r = ub
    if (key <= arr(p)) then
       res = p
    else if (arr(r) < key) then
       res = r + 1
    else !> arr(p) < key <= arr(r)
       ! invariant condition:
       ! key > arr(p) .and. key <= arr(r)
       binary_search: do while(p + 1 < r)
          q = (p+r) / 2
          if (arr(q) < key) then
             p = q
          else !> key <= arr(q)
             r = q
          end if
       end do binary_search
       res = r
    end if
  end function lower_bound
#+end_src

*** B木の展開
**** 変数の宣言
#+name: btree-var
#+begin_src bash :exports code :cache no :shebang #!/bin/bash
  case "${key_base}" in
      "character")
          key="${key_base}(${key_kind})"
          suffix="${key_base}${key_kind}"
          ;;
      "type")
          key="type(${key_kind})"
          suffix="${key_kind}"
          ;;
      ,*)
          key="${key_base}(${key_kind})"
          suffix="${key_kind}"
          ;;
  esac
  case "${val_base}" in
      "character")
          val="${val_base}(${val_kind})"
          suffix="${suffix}_to_${val_base}${val_kind}"
          ;;
      "type")
          val="type(${val_kind})"
          suffix="${suffix}_to_${val_kind}"
          ;;
      ,*)
          val="${val_base}(${val_kind})"
          suffix="${suffix}_to_${val_kind}"
          ;;
  esac
  btree="btree_${suffix}"
  btree_node="btree_node_${suffix}"
  btree_node_ptr="btree_node_ptr_${suffix}"
  btree_node_iter="btree_node_iter_${suffix}"
#+end_src
**** 宣言の展開
#+name: declaration-btree-var
#+begin_src bash :exports code :var key_base="integer" key_kind="int32" val_base="integer" val_kind="int32" :results output :noweb no-export :cache no :shebang #!/bin/bash
  <<btree-var>>
  cat <<EOF
  <<declaration-btree>>
  EOF
#+end_src
#+name: procedures-btree-var
#+begin_src bash :exports code :var key_base="integer" key_kind="int32" val_base="integer" val_kind="int32" :results output :noweb no-export :cache no :shebang #!/bin/bash
  <<btree-var>>
  cat <<EOF
  <<procedures-btree>>
  EOF
#+end_src
*** B木のテスト
**** test本体.
#+name: test-btree
#+begin_src fortran :flags "-cpp -g -fbacktrace -fcheck=bounds" :exports code :results output file :file "btree.log" :noweb no-export :cache yes
<<btree-module>>
<<btree-test>>
#+end_src

#+RESULTS[a7886dd625a79f94ce2a5543fe9fbf627bf7da3d]: test-btree
[[file:btree.log]]

**** testプログラム
#+name: btree-test
#+begin_src fortran :exports code :tangle "test/test_btree.F90" :noweb no-export
  program test_btree_m
    use, intrinsic :: iso_fortran_env
    use btree_m
    implicit none
    type(btree_int32_to_int32) :: m
    integer(int32), parameter :: n = 3*10**4
    call m%init()
    ! write(error_unit, '(a, *(i0, 1x))') "random insertion: s, h: ", m%size(), m%height()
    call check_insertion_random(n)
    ! write(error_unit, '(a, *(i0, 1x))') "ascending insertion: s, h: ", m%size(), m%height()
    call check_insertion_ascending(n)
    ! write(error_unit, '(a, *(i0, 1x))') "descending insertion: s, h: ", m%size(), m%height()
    call check_insertion_descending(n)
    call check_deletion_latter_to_former(n)
    call check_deletion_latter_to_former(n-1)
    call check_deletion_front_back_in_turn(n)
    call check_deletion_front_back_in_turn(n-1)
    call check_deletion_minimum(n)
    call check_deletion_minimum(n-1)
    call check_insertion_character100()
    ! write(error_unit, '(a, *(i0, 1x))') "all done: s, h: ", m%size(), m%height()
    call check_iterator_next(n)
    call check_iterator_prev(n)
    ! write(error_unit, '(a)') "Success!"
  contains
    <<btree-test-check_insertion_random>>
    <<btree-test-check_insertion_ascending>>
    <<btree-test-check_insertion_descending>>
    <<btree-test-check_deletion_latter_to_former>>
    <<btree-test-check_deletion_front_back_in_turn>>
    <<btree-test-check_deletion_minimum>>
    <<btree-test-check_insertion_character100>>
    <<btree-test-check_iterator_next>>
    <<btree-test-check_iterator_prev>>
  end program test_btree_m
#+end_src
**** ランダムな大きさの要素を挿入.
#+name: btree-test-check_insertion_random
#+begin_src fortran :exports code :noweb no-export
  subroutine check_insertion_random(n)
    integer(int32), intent(in) :: n
    integer(int32) :: seedsize
    integer(int32), allocatable :: seed(:)
    integer(int32), allocatable :: arr(:)
    logical, allocatable :: used(:)
    integer(int32) :: i
    real(real64) :: r
    allocate(arr(n))
    allocate(used(0:10*n-1), source = .false.)
    call random_seed(size = seedsize)
    allocate(seed(seedsize))
    ! call random_seed(get=seed)
    ! write(output_unit, '(*(i0, 1x))') seed(:)
    ! stop
    ! seed(:) = [1491111790, -1572383, 827114786, -2082456701, 1635664076, -1541841097, -1561155676, -20848911]
    ! seed(:) = [-200678384, 1172132809, 124451245, 104878683, 643972878, 359873178, 1075753119, -200657478, 554946086, 24937149&
    !      , -268657053, -197381607, 216039971, 1432749834, 990875914, -2110703970, 2126530906, 1473942311, 1489084070, -932897027&
    !      , -620123104, 1538555552, 715169866, -426413934, 1522025556, -432716, -882668547, -346073549, -1849722518, 111186990&
    !      , -50097180, 1633091563, 0]
    seed(:) = [(i, i = 1, seedsize)]
    call random_seed(put=seed)
    do i = 1, n
       do
          call random_number(r)
          arr(i) = floor(10*n*r)
          if (.not. used(arr(i))) then
             used(arr(i)) = .true.
             exit
          end if
       end do
       call m%insert(arr(i), i)
    end do
    call m%check_invariant()
    ! write(error_unit, '(a, *(i0, 1x))') "s, h: ", m%size(), m%height()
    do i = 1, n
       <<assert-eq(eq1="m%get(arr(i))", eq2="i", code=4, message="Btree method `insert` or `get` are something wrong.")>>
    end do
    do i = 1, n
       call m%remove(arr(i))
    end do
    <<assert-eq(eq1="m%size()", eq2="0", code=5, message="Btree method `remove` are something wrong.")>>
  end subroutine check_insertion_random
#+end_src
**** 昇順に挿入.
#+name: btree-test-check_insertion_ascending
#+begin_src fortran :exports code :noweb no-export
  subroutine check_insertion_ascending(n)
    integer(int32), intent(in) :: n
    integer(int32) :: i
    type(btree_node_iter_int32_to_int32) :: iter
    do i = 1, n
       call m%insert(i, i)
    end do
    <<assert-eq(eq1="m%size()", eq2="n", code=11, message="Btree method `insert` are something wrong.")>>
    call m%check_invariant()
    do i = 1, n
       call m%remove(i)
    end do
    <<assert-eq(eq1="m%size()", eq2="0", code=12, message="Btree method `remove` are something wrong.")>>
    do i = 1, n
       call m%insert(i, i)
    end do
    ! call m%print(output_unit)
    call m%check_invariant()
    <<assert-eq(eq1="m%size()", eq2="n", code=13, message="Btree method `insert` are something wrong.")>>
    do i = n, 1, -1
       call m%remove(i)
    end do
    <<assert-eq(eq1="m%size()", eq2="0", code=14, message="Btree method `remove` are something wrong.")>>
  end subroutine check_insertion_ascending
#+end_src
**** 降順に要素を挿入
#+name: btree-test-check_insertion_descending
#+begin_src fortran :exports code :noweb no-export
  subroutine check_insertion_descending(n)
    integer(int32), intent(in) :: n
    integer(int32) :: i
    do i = n, 1, -1
       call m%insert(i, i)
    end do
    call m%check_invariant()
    <<assert-eq(eq1="m%size()", eq2="n", code=21, message="Btree method `insert` are something wrong.")>>
    do i = 1, n
       call m%remove(i)
    end do
    call m%check_invariant()
    <<assert-eq(eq1="m%size()", eq2="0", code=22, message="Btree method `remove` are something wrong.")>>
    do i = n, 1, -1
       call m%insert(i, i)
    end do
    call m%check_invariant()
    <<assert-eq(eq1="m%size()", eq2="n", code=23, message="Btree method `insert` are something wrong.")>>
    do i = n, 1, -1
       call m%remove(i)
    end do
    call m%check_invariant()
    <<assert-eq(eq1="m%size()", eq2="0", code=24, message="Btree method `remove` are something wrong.")>>
  end subroutine check_insertion_descending
#+end_src
**** 要素を後ろ半分を削除して前半分を削除
#+name: btree-test-check_deletion_latter_to_former
#+begin_src fortran :exports code :noweb no-export
  subroutine check_deletion_latter_to_former(n)
    integer(int32), intent(in) :: n
    integer(int32) :: i
    do i = 1, n
       call m%insert(i, i)
    end do
    call m%check_invariant()
    <<assert-eq(eq1="m%size()", eq2="n", code=21, message="Btree method `insert` are something wrong.")>>
    do i = n/2, n
       call m%remove(i)
    end do
    <<assert-eq(eq1="m%size()", eq2="n-(n-n/2+1)", code=22, message="Btree method `remove` are something wrong.")>>
    do i = 1, n/2-1
       call m%remove(i)
    end do
    call m%check_invariant()
    <<assert-eq(eq1="m%size()", eq2="0", code=23, message="Btree method `remove` are something wrong.")>>
    do i = n, 1, -1
       call m%insert(i, i)
    end do
    call m%check_invariant()
    <<assert-eq(eq1="m%size()", eq2="n", code=24, message="Btree method `insert` are something wrong.")>>
    do i = n, n/2, -1
       call m%remove(i)
    end do
    call m%check_invariant()
    <<assert-eq(eq1="m%size()", eq2="n-(n-n/2+1)", code=25, message="Btree method `remove` are something wrong.")>>
    do i = n/2-1, 1, -1
       call m%remove(i)
    end do
    call m%check_invariant()
    <<assert-eq(eq1="m%size()", eq2="0", code=26, message="Btree method `remove` are something wrong.")>>
  end subroutine check_deletion_latter_to_former
#+end_src
**** 要素を前と後ろで交互に
#+name: btree-test-check_deletion_front_back_in_turn
#+begin_src fortran :exports code :noweb no-export
  subroutine check_deletion_front_back_in_turn(n)
    integer(int32), intent(in) :: n
    integer(int32) :: i
    do i = 1, n
       call m%insert(i, i)
    end do
    call m%check_invariant()
    <<assert-eq(eq1="m%size()", eq2="n", code=21, message="Btree method `insert` are something wrong.")>>
    do i = 1, (n+1)/2
       call m%remove(i)
       if (i == n-i+1) exit
       call m%remove(n-i+1)
    end do
    <<assert-eq(eq1="m%size()", eq2="0", code=22, message="Btree method `remove` are something wrong.")>>
    call m%check_invariant()
    do i = n, 1, -1
       call m%insert(i, i)
    end do
    call m%check_invariant()
    <<assert-eq(eq1="m%size()", eq2="n", code=24, message="Btree method `insert` are something wrong.")>>
    do i = 1, (n+1)/2
       call m%remove(i)
       if (i == n-i+1) exit
       call m%remove(n-i+1)
    end do
    call m%check_invariant()
    <<assert-eq(eq1="m%size()", eq2="0", code=26, message="Btree method `remove` are something wrong.")>>
  end subroutine check_deletion_front_back_in_turn
#+end_src
**** minimumの要素を削除
#+name: btree-test-check_deletion_minimum
#+begin_src fortran :exports code :noweb no-export
  subroutine check_deletion_minimum(n)
    integer(int32), intent(in) :: n
    integer(int32) :: mini
    integer(int32) :: i
    do i = 1, n
       call m%insert(i, i)
    end do
    call m%check_invariant()
    <<assert-eq(eq1="m%size()", eq2="n", code=21, message="Btree method `insert` are something wrong.")>>
    do i = 1, n
       if (m%size() == 0) exit
       mini = m%minimum()
       if (i + n/2 >= 29952) then
          write(error_unit, '(*(i0, 1x))') m%size(), i, mini
          call m%print(error_unit)
       end if
       <<assert(cond="m%contains(mini)", code=19, message="Btree method `remove` or `minimum` are something wrong.")>>
       call m%remove(mini)
       <<assert-eq(eq1="mini", eq2="i", code=20, message="Btree method `remove` are something wrong.")>>
       call m%remove(i+n/2)
    end do
    call m%check_invariant()
    do i = n, 1, -1
       call m%insert(i, i)
    end do
    call m%check_invariant()
    <<assert-eq(eq1="m%size()", eq2="n", code=24, message="Btree method `insert` are something wrong.")>>
    do i = 1, n
       if (m%size() == 0) exit
       mini = m%minimum()
       <<assert(cond="m%contains(mini)", code=26, message="Btree method `remove` or `minimum` are something wrong.")>>
       call m%remove(mini)
       <<assert-eq(eq1="mini", eq2="i", code=25, message="Btree method `remove` are something wrong.")>>
       call m%remove(i+n/2)
    end do
    call m%check_invariant()
  end subroutine check_deletion_minimum
#+end_src
**** character(len=100)を挿入
#+name: btree-test-check_insertion_character100
#+begin_src fortran :exports code :noweb no-export
  subroutine check_insertion_character100()
    type(btree_character100_to_int32) :: m_c100
    character(len=10), parameter :: cs(*) = ["apple     ", "banana    ", "chocolate ", "donuts    ", "egg       ", "chocobanan"]
    character(len=100) :: c
    integer(int32) :: i
    call m_c100%init()
    do i = 1, size(cs)
       c = cs(i)
       call m_c100%insert(c, i)
    end do
    do i = 1, size(cs)
       c = cs(i)
       <<assert-eq(eq1="m_c100%get(c)", eq2="i", code="40", "Btree method `insert` or `get` are something wrong.")>>
    end do
  end subroutine check_insertion_character100
#+end_src
**** iteratorを前へ操作(next)
#+name: btree-test-check_iterator_next
#+begin_src fortran :exports code :noweb no-export
  subroutine check_iterator_next(n)
    integer(int32), intent(in) :: n
    type(btree_int32_to_int32) :: m
    type(btree_node_iter_int32_to_int32) :: iter
    integer(int32) :: i
    call m%init()
    do i = 1, n
       call m%insert(i, i)
    end do
    iter = m%minimum_iter()
    i = 1
    do while (iter%is_not_end())
       <<assert-eq(eq1="iter%key()", eq2="i", code="50", "Btree iter method `minimum_iter`, `next` are something wrong.")>>
       i = i + 1
       call iter%next()
    end do
    <<assert-eq(eq1="i", eq2="n+1", code="51", "Btree iter method `minimum_iter`, `next` are something wrong.")>>
    iter = m%get_iter(n/2)
    i = n/2
    do while (iter%is_not_end())
       <<assert-eq(eq1="iter%key()", eq2="i", code="52", "Btree iter method `get_iter`, `next` are something wrong.")>>
       i = i + 1
       call iter%next()
    end do
    <<assert-eq(eq1="i", eq2="n+1", code="53", "Btree iter method `get_iter`, `next` are something wrong.")>>
  end subroutine check_iterator_next
#+end_src
**** iteratorを後ろへ操作(prev)
#+name: btree-test-check_iterator_prev
#+begin_src fortran :exports code :noweb no-export
  subroutine check_iterator_prev(n)
    integer(int32), intent(in) :: n
    type(btree_int32_to_int32) :: m
    type(btree_node_iter_int32_to_int32) :: iter
    integer(int32) :: i
    call m%init()
    do i = 1, n
       call m%insert(i, i)
    end do
    iter = m%maximum_iter()
    i = n
    do while (iter%is_not_begin())
       <<assert-eq(eq1="iter%key()", eq2="i", code="61", "Btree iter method `maximum_reti`,  `prev` are something wrong.")>>
       i = i - 1
       call iter%prev()
    end do
    <<assert-eq(eq1="i", eq2="0", code="62", "Btree iter method `maximum_iter`, `prev` are something wrong.")>>
    iter = m%get_iter(n/2)
    i = n/2
    do while (iter%is_not_begin())
       <<assert-eq(eq1="iter%key()", eq2="i", code="63", "Btree iter method `get_iter`, `prev` are something wrong.")>>
       i = i - 1
       call iter%prev()
    end do
    <<assert-eq(eq1="i", eq2="0", code="64", "Btree iter method `get_iter`, `prev` are something wrong.")>>
  end subroutine check_iterator_prev
#+end_src

*** 解けたAtCoderの問題
- ABC296C
  [[https://atcoder.jp/contests/ABC296/submissions/43783893]]
- 鉄則本A54
  [[https://atcoder.jp/contests/tessoku-book/submissions/43783501]]
- 鉄則本B54
  [[https://atcoder.jp/contests/tessoku-book/submissions/43783609]]

** COMMENT skip list(未実装)
*** スキップリストのモジュールの全容
スキップリストでmapを実現する.
ツリーマップと同様に, mapの要素に順序関係を持つことを要請する.
~i32~, ~i64~, ~type(string)~ でユーザ定義型とその実装を定義.
スキップリストは確立でリストの高さを決めて, 文字通りスキップして, 一部のリストをスキップすることで, 高速に探索できる?
#+name: skip_list-module
#+begin_src fortran :exports code :tangle "src/skip_list_m.F90" :comment link :noweb no-export
  module skip_list_m
    use, intrinsic :: iso_fortran_env
    implicit none
    private
    <<declaration-skip_list-var(key="integer", key_kind="int32", val="interger", val_kind="int32")>>
    <<declaration-skip_list-var(key="integer", key_kind="int32", val="interger", val_kind="int64")>>
    <<declaration-skip_list-var(key="integer", key_kind="int32", val="real", val_kind="real32")>>
    <<declaration-skip_list-var(key="integer", key_kind="int32", val="real", val_kind="real64")>>
    <<declaration-skip_list-var(key="integer", key_kind="int64", val="interger", val_kind="int32")>>
    <<declaration-skip_list-var(key="integer", key_kind="int64", val="interger", val_kind="int64")>>
    <<declaration-skip_list-var(key="integer", key_kind="int64", val="real", val_kind="real32")>>
    <<declaration-skip_list-var(key="integer", key_kind="int64", val="real", val_kind="real64")>>
  contains
    <<procedures-skip_list-var(key="integer", key_kind="int32", val="integer", val_kind="int32")>>
    <<procedures-skip_list-var(key="integer", key_kind="int32", val="integer", val_kind="int64")>>
    <<procedures-skip_list-var(key="integer", key_kind="int32", val="real", val_kind="real32")>>
    <<procedures-skip_list-var(key="integer", key_kind="int32", val="real", val_kind="real64")>>
    <<procedures-skip_list-var(key="integer", key_kind="int64", val="integer", val_kind="int32")>>
    <<procedures-skip_list-var(key="integer", key_kind="int64", val="integer", val_kind="int64")>>
    <<procedures-skip_list-var(key="integer", key_kind="int64", val="real", val_kind="real32")>>
    <<procedures-skip_list-var(key="integer", key_kind="int64", val="real", val_kind="real64")>>
  end module skip_list_m
#+end_src
*** skip_list型の宣言
まず, skip_list型とskip_list_node型の宣言をする.
skip_list型の振舞いとして
- =subroutine init(arr(:))= で配列 =arr(:)= で初期化する.
- =i32 size()= でサイズを返す.
- =subroutine insert(k, v)= で 対応 =(k, v)= を要素に加える.
- =subroutine insert_with(k, v, op, default)= で キー =k= に対応する値がある場合は, 2項演算子 =op(lookup(k), v)= の値をキー =k= に対応付ける.
  ない場合は =default= の値を加える.
- =${val} lookup(k)= で =k= に対応付けられた値を返す.
- =subroutine delete(k)= で =k= を消す.
- =i32 at(idx)= で =idx= 番目の要素を返す.
- =i32 find_loc(k)= で =k= のある位置を返す.
- デコンストラクタ =destroy_${skip_list}= はskip_list型とskip_list_node型を解放する.
とする.

skip_list_node型はモジュール内の ~private~ な型である.

~bash~ 変数を後で展開して, ソースコードを生み出す.
~bash~ 変数一覧.
- ~${skip_list}~ はskip_list型の名前, ~skip_list_int32~ など.
- ~${skip_list_node}~ はskip_list_node型の名前, ~skip_list_node_int32~ など.
- ~${key}~ は配列のキーの型, ~integer(int64)~ など.
- ~${val}~ は配列の要素の型, ~integer(int64)~, ~real(real32)~ など.
- ~${probability}~ 高さを伸ばす確率.
#+name: declaration-skip_list
#+begin_src fortran :exports code
  public :: ${skip_list}
  !> ${skip_list}: is map that contains ordered elements.
  type :: ${skip_list}
     private
     type(${skip_list_node}), pointer :: head_ => null(), last_ => null()
     integer(int32) :: size_ = 0, level_ = 0
     real(real64) :: probability_ = 0.5_real64
   contains
     procedure, pass :: init => init_${skip_list}
     procedure, pass :: size => size_${skip_list}
     procedure, pass :: insert      => insert_${skip_list}
     procedure, pass :: insert_with => insert_with_${skip_list}
     procedure, pass :: lookup      => lookup_${skip_list}
     procedure, pass :: delete      => delete_${skip_list}
     procedure, pass :: at       => at_${skip_list}
     procedure, pass :: find_loc => find_loc_${skip_list}
     final :: destroy_${skip_list}
  end type ${skip_list}
  private :: ${skip_list_node}
  type :: ${skip_list_node}
     private
     ${key} :: key_
     ${val} :: val_
     integer(int32) :: length_ = 0
     type(${skip_list_node}), pointer :: prev => null(), next   => null()
     type(${skip_list_node}), pointer :: top  => null(), bottom => null()
  end type ${skip_list_node}
#+end_src
*** スキップリストのprocedures
:PROPERTIES:
:header-args: :noweb-ref procedures-skip_list
:END:
***** init
=subroutine init= は skip listを配列 =arr(:)= で初期化する.
#+name: init-skip_list
#+begin_src fortran :exports code :noweb no-export
  !> init_${skip_list}: Initialize the ${skip_list} using an array of `keys` and `vals`.
  subroutine init_${skip_list}(this, keys, vals)
    class(${skip_list}), intent(inout) :: this
    ${key}, intent(in) ::keys(:)
    ${val}, intent(in) ::vals(:)
    integer(int32) :: i, arr_size
    arr_size = size(keys)
    <<assert(cond="arr_size == size(vals)", code=1, message="Initialization failed. `keys(:)` and `vals(:)` must be same size.")>>
    call this%init(arr_size)
    do i = 1, arr_size
       call this%insert(keys(i), vals(i))
    end do
  end subroutine init_${skip_list}
#+end_src
***** size
=function size= はサイズを返す.
#+name: size-skip_list
#+begin_src fortran :exports code
  !> size_${skip_list}: Return current size of the ${skip_list}.
  pure integer(int32) function size_${skip_list}(this) result(res)
    class(${skip_list}), intent(in) :: this
    res = this%size_
  end function size_${skip_list}
#+end_src
***** insert
=subroutine insert= は =(key, val)= の対応をmapに加える.
#+name: insert-skip_list
#+begin_src fortran :exports code :noweb no-export
  !> insert_{skip_list}: Insert the correspondece between `key` and `val`.
  subroutine insert_${skip_list}(this, key, val)
    class(${skip_list}), intent(inout) :: this
    ${key}, intent(in) :: key
    ${val}, intent(in) :: val
  end subroutine insert_${skip_list}
#+end_src
***** final
=subroutine destroy_${skip_list}= は skip_list を開放する.
#+name: destroy-skip_list
#+begin_src fortran :exports code :noweb no-export
  !> destroy_${skip_list}: Replace `this%arr_(:)` with `0`.
  subroutine destroy_${skip_list}(this)
    type(${skip_list}), intent(inout) :: this
    if (allocated(this%arr_)) then
       deallocate(this%arr_)
    end if
  end subroutine destroy_${skip_list}
#+end_src
*** bash で展開
上で定義したものを NOWEB (この場合はbash)で展開する.
型を ~case~ 分で ~Fortran~ 用に処理する.
#+name: skip_list-var
#+begin_src bash :exports code :cache no :shebang #!/bin/bash
  type="${type}(${type_kind})"
  suffix="${type_kind}"
  skip_list="skip_list_${suffix}"
  skip_list_node="skip_list_node_${suffix}"
#+end_src
#+name: declaration-skip_list-var
#+begin_src bash :exports code :var type="integer" type_kind="int32" :results output :noweb no-export :cache no :shebang #!/bin/bash
  <<skip_list-var>>
  cat <<EOF
  <<declaration-skip_list>>
  EOF
#+end_src
#+name: procedures-skip_list-var
#+begin_src bash :exports code :var type="integer" type_kind="int32" :results output :noweb no-export :cache no :shebang #!/bin/bash
  <<skip_list-var>>
  cat <<EOF
  <<procedures-skip_list>>
  EOF
#+end_src
*** test
#+name: skip_list-test
#+begin_src fortran :exports code :tangle "test/test_binary_indexed_tree.F90" :noweb no-export
  program test_skip_list
    use, intrinsic :: iso_fortran_env
    use skip_list_m
    implicit none
    integer(int32), parameter :: n = 10
    integer(int32) :: i
    integer(int32) :: arr(n)
    type(skip_list_int32) :: sl
    !> ok
  end program test_skip_list
#+end_src
#+name: test-skip_list
#+begin_src fortran :flags "-cpp -g -fbacktrace -fcheck=bounds" :exports code :results output :noweb no-export :cache yes
<<skip_list-module>>
<<skip_list-test>>
#+end_src

** COMMENT stream of output
*** type definition
#+name: stream_out-module
#+begin_src fortran :exports code :tangle "src/stream_out_m.f90"
  module stream_out_m
    use, intrinsic :: iso_fortran_env
    implicit none
    private
    public :: stream_out
    type :: stream_out
       private
       integer(int32) :: iounit_ = output_unit
       character(len=:), allocatable :: sep_
     contains
       procedure, pass :: sep => sep_stream_out
       procedure, private, pass :: &
            print_i32, print_i64, print_r32, print_r64, &
            print_char, print_logical, &
            print_el
       generic :: operator(.o.) => &
            print_i32, print_i64, print_r32, print_r64, &
            print_char, print_logical, &
            print_el
    end type stream_out
    interface stream_out
       module procedure :: init_stream
    end interface stream_out
    type(stream_out), public, parameter :: stdout = stream_out(iounit_ = output_unit)
    type(stream_out), public, parameter :: stderr = stream_out(iounit_ = error_unit)
    interface
       module subroutine unit_stream_out(out, unit)
         class(stream_out), intent(inout) :: out
         integer(int32), intent(in) :: unit
       end subroutine unit_stream_out
       module subroutine sep_stream_out(out, sep)
         class(stream_out), intent(inout) :: out
         character(len=*), intent(in) :: sep
       end subroutine sep_stream_out
       module impure type(stream_out) function print_i32(out, i)
         class(stream_out), intent(in) :: out
         integer(int32), intent(in) :: i
       end function print_i32
       module pure type(stream_out) function init_stream(unit, sep) result(res)
         integer(int32), intent(in) :: unit
         character(len=*), intent(in) :: sep
       end function init_stream
       module impure type(stream_out) function print_i64(out, i)
         class(stream_out), intent(in) :: out
         integer(int64), intent(in) :: i
       end function print_i64
       module impure type(stream_out) function print_r32(out, r)
         class(stream_out), intent(in) :: out
         real(real32), intent(in) :: r
       end function print_r32
       module impure type(stream_out) function print_r64(out, r)
         class(stream_out), intent(in) :: out
         real(real64), intent(in) :: r
       end function print_r64
       module impure type(stream_out) function print_char(out, c)
         class(stream_out), intent(in) :: out
         character(len=*), intent(in) :: c
       end function print_char
       module impure type(stream_out) function print_logical(out, b)
         class(stream_out), intent(in) :: out
         logical, intent(in) :: b
       end function print_logical
    end interface

    public :: stream_endl
    type :: stream_endl
    end type stream_endl
    type(stream_endl), public :: endl
    interface
       module impure type(stream_out) function print_el(out, el)
         class(stream_out), intent(in) :: out
         type(stream_endl), intent(in) :: el
       end function print_el
    end interface

    private :: stream_const
    type :: stream_const
     contains
       procedure, pass :: stream_const_nothing
       generic :: assignment(=) => stream_const_nothing
    end type stream_const
    type(stream_const), public :: const_stream
    interface
       module subroutine stream_const_nothing(const_stream, out)
         class(stream_const), intent(out) :: const_stream
         type(stream_out), intent(in) :: out
       end subroutine stream_const_nothing
    end interface

  end module stream_out_m

  submodule (stream_out_m) stream_out_implement_sm
    implicit none
  contains
    module pure type(stream_out) function init_stream(unit, sep) result(res)
      integer(int32), intent(in) :: unit
      character(len=*), intent(in) :: sep
      res%iounit_ = unit
      res%sep_ = sep
    end function init_stream
    module subroutine unit_stream_out(out, unit)
      class(stream_out), intent(inout) :: out
      integer(int32), intent(in) :: unit
      out%iounit_ = unit
    end subroutine unit_stream_out
    module subroutine sep_stream_out(out, sep)
      class(stream_out), intent(inout) :: out
      character(len=*), intent(in) :: sep
      out%sep_ = sep
    end subroutine sep_stream_out
    module impure type(stream_out) function print_i32(out, i)
      class(stream_out), intent(in) :: out
      integer(int32), intent(in) :: i
      integer(int32) :: len_i
      print_i32 = out
      write(out%iounit_, '(i0, a)', advance = "no") i, out%sep_
    end function print_i32
    module impure type(stream_out) function print_i64(out, i)
      class(stream_out), intent(in) :: out
      integer(int64), intent(in) :: i
      print_i64 = out
      write(out%iounit_, '(i0, a)', advance = "no") i, out%sep_
    end function print_i64
    module impure type(stream_out) function print_r32(out, r)
      class(stream_out), intent(in) :: out
      real(real32), intent(in) :: r
      character(len=20) :: str
      write(str, '(f20.8)') r
      print_r32 = out
      write(out%iounit_, '(a, a)', advance = "no") trim(adjustl(str)), out%sep_
    end function print_r32
    module impure type(stream_out) function print_r64(out, r)
      class(stream_out), intent(in) :: out
      real(real64), intent(in) :: r
      character(len=40) :: str
      write(str, *) r
      print_r64 = out
      write(out%iounit_, '(a, a)', advance = "no") trim(adjustl(str)), out%sep_
    end function print_r64
    module impure type(stream_out) function print_char(out, c)
      class(stream_out), intent(in) :: out
      character(len=*), intent(in) :: c
      print_char = out
      write(out%iounit_, '(a, a)', advance = "no") c, out%sep_
    end function print_char
    module impure type(stream_out) function print_logical(out, b)
      class(stream_out), intent(in) :: out
      logical, intent(in) :: b
      print_logical = out
      write(out%iounit_, '(L, a)', advance = "no") b, out%sep_
    end function print_logical
    module impure type(stream_out) function print_el(out, el)
      class(stream_out), intent(in) :: out
      type(stream_endl), intent(in) :: el
      print_el = out
      write(out%iounit_, *)
    end function print_el
    module subroutine stream_const_nothing(const_stream, out)
      class(stream_const), intent(out) :: const_stream
      type(stream_out), intent(in) :: out
      ! do nothing.
    end subroutine stream_const_nothing
  end submodule stream_out_implement_sm
#+end_src
*** test
#+name: stream_out-test
#+begin_src fortran :exports code :tangle "test/test_steam_out.f90"
  program test_stream_out
    use, intrinsic :: iso_fortran_env
    use stream_out_m, cstream => const_stream
    implicit none
    type(stream_out) :: myout
    myout = stdout
    call myout%sep(" ")
    cstream = stdout .o. 3 .o. 4_int64 .o. 30.2/3 .o. 40.6d40/3 .o. endl
    cstream = myout  .o. 3 .o. 4_int64 .o. 30.2/3 .o. 40.6d40/3 .o. endl
    cstream = stderr .o. 3 .o. 4_int64 .o. 30.2/3 .o. 40.6d40/3 .o. endl
    cstream = stdout .o. 2 .o. 4.2 .o. .true. .o. "hi" .o. endl
  end program test_stream_out
#+end_src
#+name: test-stream_out
#+begin_src fortran :flags -g -fbacktrace :exports code :results output :noweb no-export :cache yes
<<stream_out-module>>
<<stream_out-test>>
#+end_src

#+RESULTS[7180d27cac49410c73102321bde729aff897011d]: test-stream_out
: 3410.066666601.3533333333333333E+041
: 3 4 10.06666660 1.3533333333333333E+041
: 24.19999981Thi
** modint
*** type declaration
#+begin_src fortran :exports code :noweb no-export
  module modint_m
    use, intrinsic :: iso_fortran_env
    implicit none
    private
    integer(int64), parameter :: modulo = 10**9 + 7
    public :: modint
    public :: assignment(=), operator(+), operator(-), operator(*), operator(/), inv, operator(**), combination
    type :: modint
       integer(int64) :: val_
     contains
       procedure, pass :: to_i64 => to_i64_modint
    end type modint
    interface modint
       module procedure :: init_modint_i32, init_modint_i64
    end interface modint
    interface assignment(=)
       module procedure :: assign_m_from_m, assign_m_from_i32, assign_m_from_i64
    end interface assignment(=)
    interface operator(+)
       module procedure :: add_m_m, add_i32_m, add_i64_m, add_m_i32, add_m_i64
    end interface operator(+)
    interface operator(-)
       module procedure :: sub_m_m, sub_i32_m, sub_i64_m, sub_m_i32, sub_m_i64
    end interface operator(-)
    interface operator(*)
       module procedure :: mul_m_m, mul_i32_m, mul_i64_m, mul_m_i32, mul_m_i64
    end interface operator(*)
    interface inv
       module procedure :: inv_modint, inv_i32, inv_i64
    end interface inv
    interface operator(/)
       module procedure :: div_m_m, div_i32_m, div_i64_m, div_m_i32, div_m_i64
    end interface operator(/)
    interface operator(**)
       module procedure :: pow_m_i32, pow_m_i64
    end interface operator(**)
    interface combination
       module procedure :: combination_m_m, combination_m_i32, combination_m_i64, combination_i32_m, combination_i64_m
    end interface combination
  contains
    pure integer(int64) function to_i64_modint(mx) result(res)
      class(modint), intent(in) :: mx
      res = mx%val_
    end function to_i64_modint
    pure elemental type(modint) function init_modint_i32(x) result(res)
      integer(int32), intent(in) :: x
      res = modint(int(x, int64))
    end function init_modint_i32
    pure elemental type(modint) function init_modint_i64(x) result(res)
      integer(int64), intent(in) :: x
      res%val_ = mod(x, modulo)
      if (res%val_ < 0) res%val_ = res%val_ + modulo
    end function init_modint_i64
    pure subroutine assign_m_from_m(this, x)
      type(modint), intent(out) :: this
      type(modint), intent(in) :: x
      this%val_ = x%val_
    end subroutine assign_m_from_m
    pure subroutine assign_m_from_i32(this, x)
      type(modint), intent(out) :: this
      integer(int32), intent(in) :: x
      this = modint(x)
    end subroutine assign_m_from_i32
    pure subroutine assign_m_from_i64(this, x)
      type(modint), intent(out) :: this
      integer(int64), intent(in) :: x
      this = modint(x)
    end subroutine assign_m_from_i64
    pure type(modint) function add_m_m(mx, my) result(res)
      type(modint), intent(in) :: mx, my
      res%val_ = mod(mx%val_ + my%val_, modulo)
    end function add_m_m
    pure type(modint) function add_i32_m(x, my) result(res)
      integer(int32), intent(in) :: x
      type(modint), intent(in) :: my
      res = int(x, int64) + my
    end function add_i32_m
    pure type(modint) function add_i64_m(x, my) result(res)
      integer(int64), intent(in) :: x
      type(modint), intent(in) :: my
      res = modint(x) + my
    end function add_i64_m
    pure type(modint) function add_m_i32(mx, y) result(res)
      type(modint), intent(in) :: mx
      integer(int32), intent(in) :: y
      res = mx + modint(y)
    end function add_m_i32
    pure type(modint) function add_m_i64(mx, y) result(res)
      type(modint), intent(in) :: mx
      integer(int64), intent(in) :: y
      res = mx + modint(y)
    end function add_m_i64
    pure type(modint) function sub_m_m(mx, my) result(res)
      type(modint), intent(in) :: mx, my
      res%val_ = mod(mx%val_ - my%val_, modulo)
      if (res%val_ < 0) res%val_ = res%val_ + modulo
    end function sub_m_m
    pure type(modint) function sub_i32_m(x, my) result(res)
      integer(int32), intent(in) :: x
      type(modint), intent(in) :: my
      res = modint(x) - my
    end function sub_i32_m
    pure type(modint) function sub_i64_m(x, my) result(res)
      integer(int64), intent(in) :: x
      type(modint), intent(in) :: my
      res = modint(x) - my
    end function sub_i64_m
    pure type(modint) function sub_m_i32(mx, y) result(res)
      type(modint), intent(in) :: mx
      integer(int32), intent(in) :: y
      res = mx - modint(y)
    end function sub_m_i32
    pure type(modint) function sub_m_i64(mx, y) result(res)
      type(modint), intent(in) :: mx
      integer(int64), intent(in) :: y
      res = mx - modint(y)
    end function sub_m_i64
    pure type(modint) function mul_m_m(mx, my) result(res)
      type(modint), intent(in) :: mx, my
      res%val_ = mod(mx%val_ * my%val_, modulo)
    end function mul_m_m
    pure type(modint) function mul_i32_m(x, my) result(res)
      integer(int32), intent(in) :: x
      type(modint), intent(in) :: my
      res = modint(x) * my
    end function mul_i32_m
    pure type(modint) function mul_i64_m(x, my) result(res)
      integer(int64), intent(in) :: x
      type(modint), intent(in) :: my
      res = modint(x) * my
    end function mul_i64_m
    pure type(modint) function mul_m_i32(mx, y) result(res)
      type(modint), intent(in) :: mx
      integer(int32), intent(in) :: y
      res = mx * modint(y)
    end function mul_m_i32
    pure type(modint) function mul_m_i64(mx, y) result(res)
      type(modint), intent(in) :: mx
      integer(int64), intent(in) :: y
      res = mx * modint(y)
    end function mul_m_i64

    pure type(modint) function inv_modint(mx) result(res)
      type(modint), intent(in) :: mx
      integer(int64) :: g, a_inv, y
      call extend_euclid(mx%val_, modulo, g, a_inv, y)
      !> if (g /= 1) error stop 1, something wrong...
      !> g == 1.
      res = modint(a_inv)
    end function inv_modint
    pure type(modint) function inv_i32(x) result(res)
      integer(int32), intent(in) :: x
      res = inv_modint(modint(x))
    end function inv_i32
    pure type(modint) function inv_i64(x) result(res)
      integer(int64), intent(in) :: x
      res = inv_modint(modint(x))
    end function inv_i64
    !> a*x + b*y == g
    pure subroutine extend_euclid(a, b, g, x, y)
      integer(int64), intent(in)  :: a, b
      integer(int64), intent(out) :: g, x, y
      integer(int64) :: q
      integer(int64) :: zs(0:1), xs(0:1), ys(0:1)
      integer(int32) :: old, next
      zs(0) = a; zs(1) = b
      xs(0) = 1; xs(1) = 0
      ys(0) = 0; ys(1) = 1
      old = 1
      do
         next = ieor(old, 1)
         if (zs(old) == 0) exit
         q = zs(next) / zs(old)
         zs(next) = zs(next) - q*zs(old)
         xs(next) = xs(next) - q*xs(old)
         ys(next) = ys(next) - q*ys(old)
         old = next
      end do
      x = xs(next)
      y = ys(next)
      g = a*x + b*y
    end subroutine extend_euclid

    pure type(modint) function div_m_m(mx, my) result(res)
      type(modint), intent(in) :: mx, my
      res = mx * inv(my)
    end function div_m_m
    pure type(modint) function div_i32_m(x, my) result(res)
      integer(int32), intent(in) :: x
      type(modint), intent(in) :: my
      res = modint(x) / my
    end function div_i32_m
    pure type(modint) function div_i64_m(x, my) result(res)
      integer(int64), intent(in) :: x
      type(modint), intent(in) :: my
      res = modint(x) / my
    end function div_i64_m
    pure type(modint) function div_m_i32(mx, y) result(res)
      type(modint), intent(in) :: mx
      integer(int32), intent(in) :: y
      res = mx / modint(y)
    end function div_m_i32
    pure type(modint) function div_m_i64(mx, y) result(res)
      type(modint), intent(in) :: mx
      integer(int64), intent(in) :: y
      res = mx / modint(y)
    end function div_m_i64

    pure type(modint) function pow_m_i32(mx, p) result(res)
      type(modint), intent(in) :: mx
      integer(int32), intent(in) :: p
      res = mx ** int(p, int64)
    end function pow_m_i32
    pure type(modint) function pow_m_i64(mx, p) result(res)
      type(modint), intent(in) :: mx
      integer(int64), intent(in) :: p
      type(modint) :: mv, mx_powered
      integer(int64) :: pow
      mv = 1
      mx_powered = mx
      pow = p
      do while (pow /= 0)
         if (iand(pow, b'1') == 1) then
            mv = mv * mx_powered
         end if
         mx_powered = mx_powered * mx_powered
         pow = ishft(pow, -1)
      end do
      res = mv
    end function pow_m_i64
    pure type(modint) function combination_m_m(mn, mr) result(res)
      type(modint), intent(in) :: mn, mr
      integer(int64) :: i
      res = modint(1)
      do i = 1, mr%to_i64()
         res = res * (mn%to_i64()-i+1) / i
      end do
    end function combination_m_m
    pure type(modint) function combination_m_i32(mn, r) result(res)
      type(modint), intent(in) :: mn
      integer(int32), intent(in) :: r
      res = combination(mn, modint(r))
    end function combination_m_i32
    pure type(modint) function combination_m_i64(mn, r) result(res)
      type(modint), intent(in) :: mn
      integer(int64), intent(in) :: r
      res = combination(mn, modint(r))
    end function combination_m_i64
    pure type(modint) function combination_i32_m(n, mr) result(res)
      integer(int32), intent(in) :: n
      type(modint), intent(in) :: mr
      res = combination(modint(n), mr)
    end function combination_i32_m
    pure type(modint) function combination_i64_m(n, mr) result(res)
      integer(int64), intent(in) :: n
      type(modint), intent(in) :: mr
      res = combination(modint(n), mr)
    end function combination_i64_m
  end module modint_m
#+end_src
*** procedures
** Binary Indexed Tree(BIT)
*** BITモジュールの全容
~i32~, ~i64~, ~r32~, ~r64~ でユーザ定義型とその実装を定義.
BITは =n= 個の値の区間 =[1, r]= までの部分和を =O(\log n)= で求めることができる.
更新も =O(\log n)= である.
#+name: binary_indexed_tree-module
#+begin_src fortran :exports code :tangle "src/binary_indexed_tree_m.F90" :comment link :noweb no-export
  module binary_indexed_tree_m
    use, intrinsic :: iso_fortran_env
    implicit none
    private
    <<declaration-binary_indexed_tree-var(type="integer", type_kind="int32")>>
    <<declaration-binary_indexed_tree-var(type="integer", type_kind="int64")>>
    <<declaration-binary_indexed_tree-var(type="real", type_kind="real32")>>
    <<declaration-binary_indexed_tree-var(type="real", type_kind="real64")>>
  contains
    <<procedures-binary_indexed_tree-var(type="integer", type_kind="int32")>>
    <<procedures-binary_indexed_tree-var(type="integer", type_kind="int64")>>
    <<procedures-binary_indexed_tree-var(type="real", type_kind="real32")>>
    <<procedures-binary_indexed_tree-var(type="real", type_kind="real64")>>
  end module binary_indexed_tree_m
#+end_src
*** BIT型の宣言
まず, BIT型の宣言をする.
BIT型の振舞いとして
- =subroutine init(n)= でサイズ =n= , 値 =0= で初期化する.
- =subroutine init(arr(:))= で配列 =arr(:)= で初期化する.
- =subroutine reset()= でサイズを変えずに値を =0= にする.
- =i32 size()= でサイズを返す.
- =subroutine add(i, v)= でインデックス =i= へ =v= を加算する.
- =${type} sum1(r)= で 閉区間 =[1, r]= の和を返す.
- =${type} sum_range(l, r)= で 閉区間 =[l, r]= の和を返す.
- =i32 lower_bound(w)= は和がw以上になる最小のインデックスを返す.
- デコンストラクタ =destroy_${BIT}= はBIT型の配列を開放する.
とする. 配列のインデックスはFortranらしく, =1= 始まりとする.

~bash~ 変数を後で展開して, ソースコードを生み出す.
~bash~ 変数一覧.
- ~${BIT}~ はBIT型の名前, ~binary_indexed_tree_int32~ など.
- ~${type}~ は配列の要素の型, ~integer(int64)~ など.
- ~${zero}~ は ~${type}~ 型での =0=, ~0.0_real32~ など.
#+name: declaration-binary_indexed_tree
#+begin_src fortran :exports code
  public :: ${BIT}
  !> ${BIT}: can calculate the range sum O(log n).
  type :: ${BIT}
     private
     ${type}, allocatable :: arr_(:)
     integer(int32) :: size_ = 0
   contains
     procedure, pass :: init_${BIT}_by_size, init_${BIT}_by_arr
     generic         :: init  => init_${BIT}_by_size, init_${BIT}_by_arr
     procedure, pass :: reset => reset_${BIT}
     procedure, pass :: size  => size_${BIT}
     procedure, pass :: add       => add_${BIT}
     procedure, pass :: sum1      => sum1_${BIT}
     procedure, pass :: sum_range => sum_range_${BIT}
     procedure, pass :: lower_bound => lower_bound_${BIT}
     final :: destroy_${BIT}
  end type ${BIT}
#+end_src
*** BITのprocedures
:PROPERTIES:
:header-args: :noweb-ref procedures-binary_indexed_tree
:END:
***** init
=subroutine init= はBITを初期化する.
BITのサイズ =n= を渡すと, 全ての要素が =0= のBITができる.
BITへ配列 =arr(:)= を渡すと, その配列のBITができる.
#+name: init-binary_indexed-tree
#+begin_src fortran :exports code :noweb no-export
  !> init_${BIT}_by_size: Initialize the ${BIT} by size.
  !> All elements of ${BIT} is ${zero}.
  subroutine init_${BIT}_by_size(this, n)
    class(${BIT}), intent(inout) :: this
    integer(int32), intent(in) :: n
    !> Error exist if already allocated.
    if (allocated(this%arr_)) then
       <<error-handling-filename>>
       <<error-handling-error_message-exit(err_num=1,string="This ${BIT} is already allocated.")>>
    end if
    allocate(this%arr_(n), source = ${zero})
    this%size_ = n
  end subroutine init_${BIT}_by_size

  !> init_${BIT}_by_arr: Initialize the ${BIT} by array.
  subroutine init_${BIT}_by_arr(this, arr)
    class(${BIT}), intent(inout) :: this
    ${type}, intent(in) ::arr(:)
    integer(int32) :: i, arr_size
    arr_size = size(arr)
    call this%init(arr_size)
    do i = 1, arr_size
       call this%add(i, arr(i))
    end do
  end subroutine init_${BIT}_by_arr
#+end_src
***** reset
=subroutine reset= はBITの配列を全て =0= にする.
#+name: reset-binary_indexed-tree
#+begin_src fortran :exports code :noweb no-export
  !> reset_${BIT}: Replace `this%arr_(:)` with `0`.
  subroutine reset_${BIT}(this)
    class(${BIT}), intent(inout) :: this
    if (allocated(this%arr_)) then
       this%arr_(:) = ${zero}
    end if
  end subroutine reset_${BIT}
#+end_src
***** size
=function size= はサイズを返す.
#+name: size-binary_indexed_tree
#+begin_src fortran :exports code
  !> size_${BIT}: Return current size of the ${BIT}.
  pure integer(int32) function size_${BIT}(this) result(res)
    class(${BIT}), intent(in) :: this
    res = this%size_
  end function size_${BIT}
#+end_src
***** add
=subroutine add= は配列 =arr(:)= の =idx= 番目に =val= を足すことと同義である.
#+name: add-binary_indexed_tree
#+begin_src fortran :exports code :noweb no-export
  !> add_${BIT}: Add the value `val` into the index `idx` of `arr(:)`.
  subroutine add_${BIT}(this, idx, val)
    class(${BIT}), intent(inout) :: this
    integer(int32), intent(in) :: idx
    ${type}, intent(in) :: val
    integer(int32) :: i
    i = idx
    do
       if (i > this%size_) exit
       this%arr_(i) = this%arr_(i) + val
       i = i + iand(i, -i)
    end do
  end subroutine add_${BIT}
#+end_src
***** sum1
=function sum1= は 閉区間 =[1, r]= の和を返す.
#+name: sum-binary_indexed_tree
#+begin_src fortran :exports code :noweb no-export
  !> sum1_${BIT}: Return the summation of `arr(1:r)`.
  !> Return ${zero} if r < 0.
  ${type} function sum1_${BIT}(this, r) result(res)
    class(${BIT}), intent(in) :: this
    integer(int32), intent(in) :: r
    integer(int32) :: i
    res = ${zero}
    i = r
    do
       if (i < 1) return
       res = res + this%arr_(i)
       i = i - iand(i, -i)
    end do
  end function sum1_${BIT}
#+end_src
***** sum_range
==function sum_range= は 閉区間 =[l, r]= の和を返す.
#+name: sum_range-binary_indexed_tree
#+begin_src fortran :exports code :noweb no-export
  !> sum_range_${BIT}: Return the summation of `arr(l:r)`
  !> Returun ${zero} if r < l.
  ${type} function sum_range_${BIT}(this, l, r) result(res)
    class(${BIT}), intent(in) :: this
    integer(int32), intent(in) :: l, r
    res = ${zero}
    if (r < l) return
    res = this%sum1(r) - this%sum1(l-1)
  end function sum_range_${BIT}
#+end_src
***** lower_bound
=function lower_bound= は 和が =w= になるような最小のインデックスを返す.
#+name: lower_bound-binary_indexed_tree
#+begin_src fortran :exports code :noweb no-export
  !> lower_bound_${BIT}: Return the minimum index, which `x1 + x2 + ... + xres >= w`.
  !> Returun 0 if w <= ${zero}.
  integer(int32) function lower_bound_${BIT}(this, w) result(res)
    class(${BIT}), intent(in) :: this
    ${type}, intent(in) :: w
    ${type} :: w_tmp
    integer(int32) :: x, r, l
    if (w <= ${zero}) then
       res = 0_int32
       return
    end if
    w_tmp = w
    x = 0
    r = 1
    do while (r < this%size_)
       r = ishft(r, 1)
    end do
    l = r
    do while (l > 0)
       if (x + l <= this%size_) then
          if (this%arr_(x+l) < w_tmp) then
             w_tmp = w_tmp - this%arr_(x+l)
             x = x + l
          end if
       end if
       l = ishft(l, -1)
    end do
    res = x + 1
  end function lower_bound_${BIT}
#+end_src
***** final
=subroutine destroy_${BIT}= はBITの配列を開放する.
#+name: destroy-binary_indexed-tree
#+begin_src fortran :exports code :noweb no-export
  !> destroy_${BIT}: Replace `this%arr_(:)` with `0`.
  subroutine destroy_${BIT}(this)
    type(${BIT}), intent(inout) :: this
    if (allocated(this%arr_)) then
       deallocate(this%arr_)
    end if
  end subroutine destroy_${BIT}
#+end_src
*** bash で展開
上で定義したものを NOWEB (この場合はbash)で展開する.
型を ~case~ 分で ~Fortran~ 用に処理する.
#+name: binary_indexed_tree-var
#+begin_src bash :exports code :cache no :shebang #!/bin/bash
  case "${type}" in
      "real")
          zero="0.0_${type_kind}"
          ;;
      "integer")
          zero="0_${type_kind}"
          ;;
  esac
  type="${type}(${type_kind})"
  suffix="${type_kind}"
  BIT="binary_indexed_tree_${suffix}"
#+end_src
#+name: declaration-binary_indexed_tree-var
#+begin_src bash :exports code :var type="integer" type_kind="int32" :results output :noweb no-export :cache no :shebang #!/bin/bash
  <<binary_indexed_tree-var>>
  cat <<EOF
  <<declaration-binary_indexed_tree>>
  EOF
#+end_src
#+name: procedures-binary_indexed_tree-var
#+begin_src bash :exports code :var type="integer" type_kind="int32" :results output :noweb no-export :cache no :shebang #!/bin/bash
  <<binary_indexed_tree-var>>
  cat <<EOF
  <<procedures-binary_indexed_tree>>
  EOF
#+end_src
*** test
#+name: binary_indexed_tree-test
#+begin_src fortran :exports code :tangle "test/test_binary_indexed_tree.F90" :noweb no-export
  program test_binary_indexed_tree
    use, intrinsic :: iso_fortran_env
    use binary_indexed_tree_m
    implicit none
    integer(int32), parameter :: n = 10
    call check_summation(n)
    call check_inversion(n)
    call check_kth_element(n)
  contains
    subroutine check_summation(n)
      integer(int32), intent(in) :: n
      integer(int32), allocatable :: arr(:)
      integer(int32) :: i
      type(binary_indexed_tree_int32) :: bit
      allocate(arr, source = [(i, i = 1, n)])
      call bit%init(arr)
      <<assert(eq1="bit%size()", eq2="n", code=2, message="Size of `bit` is wrong.")>>
      do i = 1, n
         <<assert-eq(eq1="bit%sum1(i)", eq2="i*(i+1)/2", code=3, message="The summation of bit is wrong.")>>
      end do
    end subroutine check_summation
    subroutine check_inversion(n)
      integer(int32), intent(in) :: n
      integer(int32), allocatable :: arr(:)
      integer(int32) :: i, cnts
      type(binary_indexed_tree_int32) :: bit
      allocate(arr, source = [(i, i = n, 1, -1)])
      call bit%init(n)
      cnts = 0_int32
      do i = 1, n
         cnts = cnts + (i-1) - bit%sum1(arr(i))
         call bit%add(arr(i), 1)
         <<assert-eq(eq1="cnts", eq2="i*(i-1)/2", code=3, message="The inversion number of bit is wrong.")>>
      end do
      <<assert(eq1="bit%size()", eq2="n", code=2, message="Size of `bit` is wrong.")>>
    end subroutine check_inversion
    subroutine check_kth_element(n)
      integer(int32), intent(in) :: n
      integer(int32), allocatable :: arr(:)
      integer(int32) :: i, idx
      type(binary_indexed_tree_int32) :: bit
      allocate(arr, source = [(i, i = 1, n)])
      call bit%init(maxval(arr))
      do i = 1, n
         call bit%add(arr(i), 1)
      end do
      <<assert(eq1="bit%size()", eq2="n", code=2, message="Size of `bit` is wrong.")>>
      do i = 1, n
         idx = bit%lower_bound(i)
         <<assert-eq(eq1="idx", eq2="i", code=3, message="The `lower_bound` of bit is wrong.")>>
      end do
    end subroutine check_kth_element
  end program test_binary_indexed_tree
#+end_src
#+name: test-binary_indexed_tree
#+begin_src fortran :flags "-cpp -g -fbacktrace -fcheck=bounds" :exports code :results output :noweb no-export :cache yes
<<binary_indexed_tree-module>>
<<binary_indexed_tree-test>>
#+end_src

#+RESULTS[be7144920af4d5b8648030bcbae3963a3f7c6a5b]: test-binary_indexed_tree

** segment tree
*** Implementation
#+begin_src fortran
  module segment_tree_m
    use, intrinsic :: iso_fortran_env
    implicit none
    private
    public :: segment_tree
    public :: monoid_op
    public :: plus_int32_op, min_int32_op, max_int32_op
    type :: segment_tree
       private
       integer(int32) :: arr_size_, tree_size_, depth_
       integer(int32), allocatable :: arr_(:)
       class(monoid_op), allocatable :: monoid
     contains
       procedure, pass :: init   => init_segment_tree
       procedure, pass :: dump   => dump_segment_tree
       procedure, pass :: update => update_segment_tree
       procedure, pass :: query => query_segment_tree
    end type segment_tree
    type, abstract :: monoid_op
       private
     contains
       procedure(identity_int32), nopass, deferred :: identity
       procedure(bin_op_int32)  , nopass, deferred :: bin_op
    end type monoid_op
    abstract interface
       pure integer(int32) function identity_int32() result(res)
         import int32
       end function identity_int32
       pure integer(int32) function bin_op_int32(x, y) result(res)
         import int32
         integer(int32), intent(in) :: x, y
       end function bin_op_int32
    end interface

    type, extends(monoid_op) :: plus_int32_op
       private
     contains
       procedure, nopass :: identity => identity_plus_int32_op
       procedure, nopass :: bin_op   => bin_op_plus_int32_op
    end type plus_int32_op
    type, extends(monoid_op) :: min_int32_op
       private
     contains
       procedure, nopass :: identity => identity_min_int32_op
       procedure, nopass :: bin_op   => bin_op_min_int32_op
    end type min_int32_op
    type, extends(monoid_op) :: max_int32_op
       private
     contains
       procedure, nopass :: identity => identity_max_int32_op
       procedure, nopass :: bin_op   => bin_op_max_int32_op
    end type max_int32_op
  contains
    !> indices rage [1:2^a-1]
    subroutine init_segment_tree (this, arr_size, monoid)
      class(segment_tree), intent(inout) :: this
      integer(int32), intent(in) :: arr_size
      class(monoid_op), intent(in) :: monoid
      integer(int32) :: tree_size
      allocate(this%monoid, source = monoid)
      tree_size = 1
      this%depth_ = 1
      do
         if (tree_size > arr_size) exit
         tree_size = tree_size * 2
         this%depth_ = this%depth_ + 1
      end do
      this%arr_size_  = arr_size
      this%tree_size_ = tree_size
      allocate(this%arr_(2*tree_size - 1), source = this%monoid%identity())
    end subroutine init_segment_tree

    subroutine update_segment_tree (this, i, val)
      class(segment_tree), intent(inout) :: this
      integer(int32), intent(in) :: i, val
      integer(int32) :: x
      x = this%tree_size_ + i - 1
      this%arr_(x) = val
      do while (x > 1)
         x = x/2
         this%arr_(x) = this%monoid%bin_op(this%arr_(2*x), this%arr_(2*x+1))
      end do
    end subroutine update_segment_tree

    ! 閉区間[a, b]で操作.
    pure integer(int32) function query_segment_tree (this, a, b) result(query)
      class(segment_tree), intent(in) :: this
      integer(int32), intent(in) :: a, b
      integer(int32) :: p, r
      query = this%monoid%identity()
      if (a > b) return
      p = this%tree_size_ + a - 1
      r = this%tree_size_ + b - 1
      do while (p <= r)
         if (iand(p, b'1') == 1) then !> right child.
            query = this%monoid%bin_op(query, this%arr_(p))
            p = p + 1
         end if
         if (iand(r, b'1') == 0) then !> left child.
            query = this%monoid%bin_op(query, this%arr_(r))
            r = r - 1
         end if
         p = p/2
         r = r/2
      end do
    end function query_segment_tree

    subroutine dump_segment_tree(this)
      class(segment_tree), intent(in) :: this
      integer(int32) :: i
      do i = 1, this%depth_
         write(error_unit, '(*(i0, 1x))') i, this%arr_(2**(i-1):2**i-1)
      end do
    end subroutine dump_segment_tree

    pure integer(int32) function identity_plus_int32_op() result(res)
      res = 0_int32
    end function identity_plus_int32_op
    pure integer(int32) function bin_op_plus_int32_op(x, y) result(res)
      integer(int32), intent(in) :: x, y
      res = x + y
    end function bin_op_plus_int32_op
    pure integer(int32) function identity_min_int32_op() result(res)
      res = huge(0_int32)
    end function identity_min_int32_op
    pure integer(int32) function bin_op_min_int32_op(x, y) result(res)
      integer(int32), intent(in) :: x, y
      res = min(x, y)
    end function bin_op_min_int32_op
    pure integer(int32) function identity_max_int32_op() result(res)
      res = -huge(0_int32)-1
    end function identity_max_int32_op
    pure integer(int32) function bin_op_max_int32_op(x, y) result(res)
      integer(int32), intent(in) :: x, y
      res = max(x, y)
    end function bin_op_max_int32_op
  end module segment_tree_m

  program test_segree
    use, intrinsic :: iso_fortran_env
    use segment_tree_m
    implicit none
    integer(int32) :: i
    integer(int32) :: arr(8) = [100, 2, 30, 4, 500, 6, 7, -1]
    type(segment_tree) :: st
    class(monoid_op), allocatable :: add_int32, min_int32
    allocate(min_int32, source = min_int32_op())
    call st%init(size(arr), min_int32)
    do i = 1, size(arr)
       call st%dump()
       call st%update(i, arr(i))
    end do
    call st%dump()
    write(*,'("query [",i0,",",i0,"]: ",i0)') 1, 3, st%query(1, 3)
    write(*,'("query [",i0,",",i0,"]: ",i0)') 5, 7, st%query(5, 7)
    write(*,'("query [",i0,",",i0,"]: ",i0)') 4, 4, st%query(4, 4)
    write(*,'("query [",i0,",",i0,"]: ",i0)') 4, 1, st%query(4, 1)
  end program test_segree
#+end_src
