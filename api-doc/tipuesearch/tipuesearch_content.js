var tipuesearch = {"pages":[{"title":" Fortran Program ","text":"Fortran Program","tags":"home","loc":"index.html"},{"title":"merge_sort_m.f90 â€“ Fortran Program","text":"Contents Modules merge_sort_m Source Code merge_sort_m.f90 Source Code module merge_sort_m use , intrinsic :: iso_fortran_env implicit none private public :: merge_sort interface merge_sentinel module procedure :: merge_sentinel_int32 , merge_sentinel_int64 module procedure :: merge_sentinel_real32 , merge_sentinel_real64 end interface merge_sentinel interface merge module procedure :: merge_int32 , merge_int64 module procedure :: merge_real32 , merge_real64 end interface merge interface merge_sort module procedure :: merge_sort_int32 , merge_sort_int64 module procedure :: merge_sort_real32 , merge_sort_real64 end interface merge_sort interface merge_sort_sub module procedure :: merge_sort_sub_int32 , merge_sort_sub_int64 module procedure :: merge_sort_sub_real32 , merge_sort_sub_real64 end interface merge_sort_sub contains subroutine merge_sentinel_int32 ( arr , p , q , r ) integer ( int32 ), intent ( inout ) :: arr (:) integer ( int32 ) :: Left ( 1 : q - p + 2 ), Right ( 1 : r - q + 1 ) !> merge_sentinel: Algorithm for merge_sort, set sentinel in end of Left and, Right. !> arguments: !> arr: array of some type, (out) arr(p:r) is sorted. !> p, q, r: integer, indices p is start, r is end, q = floor( (p+q)/2 ). !> variables: !> Left, Right: array of typeof(arr), sorted !> i, j, k: integer, loop counter. integer ( int32 ), intent ( in ) :: p , q , r integer ( int32 ) :: i , j , k Left ( 1 : q - p + 1 ) = arr ( p : q ) Right ( 1 : r - q ) = arr ( q + 1 : r ) Left ( q - p + 2 ) = huge ( arr ( p )) Right ( r - q + 1 ) = huge ( arr ( p )) i = 1 j = 1 do k = p , r if ( Left ( i ) <= Right ( j )) then arr ( k ) = Left ( i ) i = i + 1 else arr ( k ) = Right ( j ) j = j + 1 end if end do end subroutine merge_sentinel_int32 subroutine merge_sentinel_int64 ( arr , p , q , r ) integer ( int64 ), intent ( inout ) :: arr (:) integer ( int64 ) :: Left ( 1 : q - p + 2 ), Right ( 1 : r - q + 1 ) !> merge_sentinel: Algorithm for merge_sort, set sentinel in end of Left and, Right. !> arguments: !> arr: array of some type, (out) arr(p:r) is sorted. !> p, q, r: integer, indices p is start, r is end, q = floor( (p+q)/2 ). !> variables: !> Left, Right: array of typeof(arr), sorted !> i, j, k: integer, loop counter. integer ( int32 ), intent ( in ) :: p , q , r integer ( int32 ) :: i , j , k Left ( 1 : q - p + 1 ) = arr ( p : q ) Right ( 1 : r - q ) = arr ( q + 1 : r ) Left ( q - p + 2 ) = huge ( arr ( p )) Right ( r - q + 1 ) = huge ( arr ( p )) i = 1 j = 1 do k = p , r if ( Left ( i ) <= Right ( j )) then arr ( k ) = Left ( i ) i = i + 1 else arr ( k ) = Right ( j ) j = j + 1 end if end do end subroutine merge_sentinel_int64 subroutine merge_sentinel_real32 ( arr , p , q , r ) real ( real32 ), intent ( inout ) :: arr (:) real ( real32 ) :: Left ( 1 : q - p + 2 ), Right ( 1 : r - q + 1 ) !> merge_sentinel: Algorithm for merge_sort, set sentinel in end of Left and, Right. !> arguments: !> arr: array of some type, (out) arr(p:r) is sorted. !> p, q, r: integer, indices p is start, r is end, q = floor( (p+q)/2 ). !> variables: !> Left, Right: array of typeof(arr), sorted !> i, j, k: integer, loop counter. integer ( int32 ), intent ( in ) :: p , q , r integer ( int32 ) :: i , j , k Left ( 1 : q - p + 1 ) = arr ( p : q ) Right ( 1 : r - q ) = arr ( q + 1 : r ) Left ( q - p + 2 ) = huge ( arr ( p )) Right ( r - q + 1 ) = huge ( arr ( p )) i = 1 j = 1 do k = p , r if ( Left ( i ) <= Right ( j )) then arr ( k ) = Left ( i ) i = i + 1 else arr ( k ) = Right ( j ) j = j + 1 end if end do end subroutine merge_sentinel_real32 subroutine merge_sentinel_real64 ( arr , p , q , r ) real ( real64 ), intent ( inout ) :: arr (:) real ( real64 ) :: Left ( 1 : q - p + 2 ), Right ( 1 : r - q + 1 ) !> merge_sentinel: Algorithm for merge_sort, set sentinel in end of Left and, Right. !> arguments: !> arr: array of some type, (out) arr(p:r) is sorted. !> p, q, r: integer, indices p is start, r is end, q = floor( (p+q)/2 ). !> variables: !> Left, Right: array of typeof(arr), sorted !> i, j, k: integer, loop counter. integer ( int32 ), intent ( in ) :: p , q , r integer ( int32 ) :: i , j , k Left ( 1 : q - p + 1 ) = arr ( p : q ) Right ( 1 : r - q ) = arr ( q + 1 : r ) Left ( q - p + 2 ) = huge ( arr ( p )) Right ( r - q + 1 ) = huge ( arr ( p )) i = 1 j = 1 do k = p , r if ( Left ( i ) <= Right ( j )) then arr ( k ) = Left ( i ) i = i + 1 else arr ( k ) = Right ( j ) j = j + 1 end if end do end subroutine merge_sentinel_real64 subroutine merge_int32 ( arr , p , q , r ) integer ( int32 ), intent ( inout ) :: arr (:) integer ( int32 ) :: Left ( 1 : q - p + 1 ), Right ( 1 : r - q ) integer ( int32 ), intent ( in ) :: p , q , r integer ( int32 ) :: l_max , r_max !> merge: Algorithm for merge_sort, check if Left or Right is end in each loop. !> arguments: !> arr: array of some type, (out) arr(p:r) is sorted. !> p, q, r: integer, indices p is start, r is end, q = floor( (p+q)/2 ). !> variables: !> Left, Right: array of typeof(arr), sorted !> l_max, r_max: integer, max index of Left or Right. l_max = q - p + 1 r_max = r - q block !> i, j, k: integer, loop counters. integer ( int32 ) :: i , j , k Left ( 1 : l_max ) = arr ( p : q ) Right ( 1 : r_max ) = arr ( q + 1 : r ) i = 1 j = 1 do k = p , r if ( Left ( i ) <= Right ( j )) then arr ( k ) = Left ( i ) i = i + 1 if ( i > l_max ) then arr ( k + 1 : r ) = Right ( j :) return end if else arr ( k ) = Right ( j ) j = j + 1 if ( j > r_max ) then arr ( k + 1 : r ) = Left ( i :) return end if end if end do end block end subroutine merge_int32 subroutine merge_int64 ( arr , p , q , r ) integer ( int64 ), intent ( inout ) :: arr (:) integer ( int64 ) :: Left ( 1 : q - p + 1 ), Right ( 1 : r - q ) integer ( int32 ), intent ( in ) :: p , q , r integer ( int32 ) :: l_max , r_max !> merge: Algorithm for merge_sort, check if Left or Right is end in each loop. !> arguments: !> arr: array of some type, (out) arr(p:r) is sorted. !> p, q, r: integer, indices p is start, r is end, q = floor( (p+q)/2 ). !> variables: !> Left, Right: array of typeof(arr), sorted !> l_max, r_max: integer, max index of Left or Right. l_max = q - p + 1 r_max = r - q block !> i, j, k: integer, loop counters. integer ( int32 ) :: i , j , k Left ( 1 : l_max ) = arr ( p : q ) Right ( 1 : r_max ) = arr ( q + 1 : r ) i = 1 j = 1 do k = p , r if ( Left ( i ) <= Right ( j )) then arr ( k ) = Left ( i ) i = i + 1 if ( i > l_max ) then arr ( k + 1 : r ) = Right ( j :) return end if else arr ( k ) = Right ( j ) j = j + 1 if ( j > r_max ) then arr ( k + 1 : r ) = Left ( i :) return end if end if end do end block end subroutine merge_int64 subroutine merge_real32 ( arr , p , q , r ) real ( real32 ), intent ( inout ) :: arr (:) real ( real32 ) :: Left ( 1 : q - p + 1 ), Right ( 1 : r - q ) integer ( int32 ), intent ( in ) :: p , q , r integer ( int32 ) :: l_max , r_max !> merge: Algorithm for merge_sort, check if Left or Right is end in each loop. !> arguments: !> arr: array of some type, (out) arr(p:r) is sorted. !> p, q, r: integer, indices p is start, r is end, q = floor( (p+q)/2 ). !> variables: !> Left, Right: array of typeof(arr), sorted !> l_max, r_max: integer, max index of Left or Right. l_max = q - p + 1 r_max = r - q block !> i, j, k: integer, loop counters. integer ( int32 ) :: i , j , k Left ( 1 : l_max ) = arr ( p : q ) Right ( 1 : r_max ) = arr ( q + 1 : r ) i = 1 j = 1 do k = p , r if ( Left ( i ) <= Right ( j )) then arr ( k ) = Left ( i ) i = i + 1 if ( i > l_max ) then arr ( k + 1 : r ) = Right ( j :) return end if else arr ( k ) = Right ( j ) j = j + 1 if ( j > r_max ) then arr ( k + 1 : r ) = Left ( i :) return end if end if end do end block end subroutine merge_real32 subroutine merge_real64 ( arr , p , q , r ) real ( real64 ), intent ( inout ) :: arr (:) real ( real64 ) :: Left ( 1 : q - p + 1 ), Right ( 1 : r - q ) integer ( int32 ), intent ( in ) :: p , q , r integer ( int32 ) :: l_max , r_max !> merge: Algorithm for merge_sort, check if Left or Right is end in each loop. !> arguments: !> arr: array of some type, (out) arr(p:r) is sorted. !> p, q, r: integer, indices p is start, r is end, q = floor( (p+q)/2 ). !> variables: !> Left, Right: array of typeof(arr), sorted !> l_max, r_max: integer, max index of Left or Right. l_max = q - p + 1 r_max = r - q block !> i, j, k: integer, loop counters. integer ( int32 ) :: i , j , k Left ( 1 : l_max ) = arr ( p : q ) Right ( 1 : r_max ) = arr ( q + 1 : r ) i = 1 j = 1 do k = p , r if ( Left ( i ) <= Right ( j )) then arr ( k ) = Left ( i ) i = i + 1 if ( i > l_max ) then arr ( k + 1 : r ) = Right ( j :) return end if else arr ( k ) = Right ( j ) j = j + 1 if ( j > r_max ) then arr ( k + 1 : r ) = Left ( i :) return end if end if end do end block end subroutine merge_real64 recursive subroutine merge_sort_sub_int32 ( arr , p , r ) integer ( int32 ), intent ( inout ) :: arr (:) integer ( int32 ), intent ( in ) :: p , r integer ( int32 ) :: q !> merge_sort_sub: Recursive function used by merge_sort. !> arguments: !> arr: array of some type. !> p, r: integer, p is start of arr, r is end of arr. !> variables: !> q: integer, q = floor( (p+q)/2 ) if ( p < r ) then q = int (( r + p ) / 2 , int32 ) call merge_sort_sub ( arr , p , q ) call merge_sort_sub ( arr , q + 1 , r ) call merge ( arr , p , q , r ) end if end subroutine merge_sort_sub_int32 recursive subroutine merge_sort_sub_int64 ( arr , p , r ) integer ( int64 ), intent ( inout ) :: arr (:) integer ( int32 ), intent ( in ) :: p , r integer ( int32 ) :: q !> merge_sort_sub: Recursive function used by merge_sort. !> arguments: !> arr: array of some type. !> p, r: integer, p is start of arr, r is end of arr. !> variables: !> q: integer, q = floor( (p+q)/2 ) if ( p < r ) then q = int (( r + p ) / 2 , int32 ) call merge_sort_sub ( arr , p , q ) call merge_sort_sub ( arr , q + 1 , r ) call merge ( arr , p , q , r ) end if end subroutine merge_sort_sub_int64 recursive subroutine merge_sort_sub_real32 ( arr , p , r ) real ( real32 ), intent ( inout ) :: arr (:) integer ( int32 ), intent ( in ) :: p , r integer ( int32 ) :: q !> merge_sort_sub: Recursive function used by merge_sort. !> arguments: !> arr: array of some type. !> p, r: integer, p is start of arr, r is end of arr. !> variables: !> q: integer, q = floor( (p+q)/2 ) if ( p < r ) then q = int (( r + p ) / 2 , int32 ) call merge_sort_sub ( arr , p , q ) call merge_sort_sub ( arr , q + 1 , r ) call merge ( arr , p , q , r ) end if end subroutine merge_sort_sub_real32 recursive subroutine merge_sort_sub_real64 ( arr , p , r ) real ( real64 ), intent ( inout ) :: arr (:) integer ( int32 ), intent ( in ) :: p , r integer ( int32 ) :: q !> merge_sort_sub: Recursive function used by merge_sort. !> arguments: !> arr: array of some type. !> p, r: integer, p is start of arr, r is end of arr. !> variables: !> q: integer, q = floor( (p+q)/2 ) if ( p < r ) then q = int (( r + p ) / 2 , int32 ) call merge_sort_sub ( arr , p , q ) call merge_sort_sub ( arr , q + 1 , r ) call merge ( arr , p , q , r ) end if end subroutine merge_sort_sub_real64 subroutine merge_sort_int32 ( arr ) integer ( int32 ), intent ( inout ) :: arr (:) !> merge_sort: Sort arr(:) by sub function merge_sort_sub. !> arguments: !> arr: array of some type. call merge_sort_sub ( arr , 1 , size ( arr )) end subroutine merge_sort_int32 subroutine merge_sort_int64 ( arr ) integer ( int64 ), intent ( inout ) :: arr (:) !> merge_sort: Sort arr(:) by sub function merge_sort_sub. !> arguments: !> arr: array of some type. call merge_sort_sub ( arr , 1 , size ( arr )) end subroutine merge_sort_int64 subroutine merge_sort_real32 ( arr ) real ( real32 ), intent ( inout ) :: arr (:) !> merge_sort: Sort arr(:) by sub function merge_sort_sub. !> arguments: !> arr: array of some type. call merge_sort_sub ( arr , 1 , size ( arr )) end subroutine merge_sort_real32 subroutine merge_sort_real64 ( arr ) real ( real64 ), intent ( inout ) :: arr (:) !> merge_sort: Sort arr(:) by sub function merge_sort_sub. !> arguments: !> arr: array of some type. call merge_sort_sub ( arr , 1 , size ( arr )) end subroutine merge_sort_real64 end module merge_sort_m","tags":"","loc":"sourcefile/merge_sort_m.f90.html"},{"title":"algorithms.f90 â€“ Fortran Program","text":"Contents Modules algorithms Source Code algorithms.f90 Source Code module algorithms implicit none private public :: say_hello contains subroutine say_hello print * , \"Hello, algorithms!\" end subroutine say_hello end module algorithms","tags":"","loc":"sourcefile/algorithms.f90.html"},{"title":"insertion_sort_m.f90 â€“ Fortran Program","text":"Contents Modules insertion_sort_m Source Code insertion_sort_m.f90 Source Code module insertion_sort_m use , intrinsic :: iso_fortran_env implicit none private public :: insertion_sort interface insertion_sort module procedure :: insertion_sort_int32 , insertion_sort_int64 module procedure :: insertion_sort_real32 , insertion_sort_real64 end interface insertion_sort contains subroutine insertion_sort_int32 ( arr ) integer ( int32 ), intent ( inout ) :: arr (:) integer ( int32 ) :: key integer :: arr_size , i , j arr_size = size ( arr ) do i = 2 , arr_size key = arr ( i ) do j = i - 1 , 1 , - 1 if ( arr ( j ) < key ) exit arr ( j + 1 ) = arr ( j ) end do arr ( j + 1 ) = key end do end subroutine insertion_sort_int32 subroutine insertion_sort_int64 ( arr ) integer ( int64 ), intent ( inout ) :: arr (:) integer ( int64 ) :: key integer :: arr_size , i , j arr_size = size ( arr ) do i = 2 , arr_size key = arr ( i ) do j = i - 1 , 1 , - 1 if ( arr ( j ) < key ) exit arr ( j + 1 ) = arr ( j ) end do arr ( j + 1 ) = key end do end subroutine insertion_sort_int64 subroutine insertion_sort_real32 ( arr ) real ( real32 ), intent ( inout ) :: arr (:) real ( real32 ) :: key integer :: arr_size , i , j arr_size = size ( arr ) do i = 2 , arr_size key = arr ( i ) do j = i - 1 , 1 , - 1 if ( arr ( j ) < key ) exit arr ( j + 1 ) = arr ( j ) end do arr ( j + 1 ) = key end do end subroutine insertion_sort_real32 subroutine insertion_sort_real64 ( arr ) real ( real64 ), intent ( inout ) :: arr (:) real ( real64 ) :: key integer :: arr_size , i , j arr_size = size ( arr ) do i = 2 , arr_size key = arr ( i ) do j = i - 1 , 1 , - 1 if ( arr ( j ) < key ) exit arr ( j + 1 ) = arr ( j ) end do arr ( j + 1 ) = key end do end subroutine insertion_sort_real64 end module insertion_sort_m","tags":"","loc":"sourcefile/insertion_sort_m.f90.html"},{"title":"swap_m.f90 â€“ Fortran Program","text":"Files dependent on this one sourcefile~~swap_m.f90~~AfferentGraph sourcefile~swap_m.f90 swap_m.f90 sourcefile~selection_sort_m.f90 selection_sort_m.f90 sourcefile~selection_sort_m.f90->sourcefile~swap_m.f90 Help Ã— Graph Key Nodes of different colours represent the following: Graph Key Source File Source File This Page's Entity This Page's Entity Solid arrows point from a file to a file which it depends on. A file\n    is dependent upon another if the latter must be compiled before the former\n    can be. Contents Modules swap_m Source Code swap_m.f90 Source Code module swap_m use , intrinsic :: iso_fortran_env implicit none interface swap module procedure :: swap_int32 , swap_int64 module procedure :: swap_real32 , swap_real64 end interface swap contains subroutine swap_int32 ( arr , i , j ) integer ( int32 ), intent ( inout ) :: arr (:) integer ( int32 ), intent ( in ) :: i , j integer ( int32 ) :: tmp !> swap: Swap two elements of arr. !> arguments: !> arr: array of some type. !> i, j: integer indices. !> variables: !> tmp: typeof(arr). tmp = arr ( i ) arr ( i ) = arr ( j ) arr ( j ) = tmp end subroutine swap_int32 subroutine swap_int64 ( arr , i , j ) integer ( int64 ), intent ( inout ) :: arr (:) integer ( int32 ), intent ( in ) :: i , j integer ( int64 ) :: tmp !> swap: Swap two elements of arr. !> arguments: !> arr: array of some type. !> i, j: integer indices. !> variables: !> tmp: typeof(arr). tmp = arr ( i ) arr ( i ) = arr ( j ) arr ( j ) = tmp end subroutine swap_int64 subroutine swap_real32 ( arr , i , j ) real ( real32 ) , intent ( inout ) :: arr (:) integer ( int32 ), intent ( in ) :: i , j real ( real32 ) :: tmp !> swap: Swap two elements of arr. !> arguments: !> arr: array of some type. !> i, j: integer indices. !> variables: !> tmp: typeof(arr). tmp = arr ( i ) arr ( i ) = arr ( j ) arr ( j ) = tmp end subroutine swap_real32 subroutine swap_real64 ( arr , i , j ) real ( real64 ) , intent ( inout ) :: arr (:) integer ( int32 ), intent ( in ) :: i , j real ( real64 ) :: tmp !> swap: Swap two elements of arr. !> arguments: !> arr: array of some type. !> i, j: integer indices. !> variables: !> tmp: typeof(arr). tmp = arr ( i ) arr ( i ) = arr ( j ) arr ( j ) = tmp end subroutine swap_real64 end module swap_m","tags":"","loc":"sourcefile/swap_m.f90.html"},{"title":"selection_sort_m.f90 â€“ Fortran Program","text":"This file depends on sourcefile~~selection_sort_m.f90~~EfferentGraph sourcefile~selection_sort_m.f90 selection_sort_m.f90 sourcefile~swap_m.f90 swap_m.f90 sourcefile~selection_sort_m.f90->sourcefile~swap_m.f90 Help Ã— Graph Key Nodes of different colours represent the following: Graph Key Source File Source File This Page's Entity This Page's Entity Solid arrows point from a file to a file which it depends on. A file\n    is dependent upon another if the latter must be compiled before the former\n    can be. Contents Modules selection_sort_m Source Code selection_sort_m.f90 Source Code module selection_sort_m use , intrinsic :: iso_fortran_env use swap_m implicit none private public :: selection_sort interface selection_sort module procedure :: selection_sort_int32 , selection_sort_int64 module procedure :: selection_sort_real32 , selection_sort_real64 end interface selection_sort contains subroutine selection_sort_int32 ( arr ) integer ( int32 ), intent ( inout ) :: arr (:) integer :: arr_size , mini_index , i , j !> selection_sort: Sort arr of some type by selection-sort. !> arguments: !> arr: array of some type. !> variables: !> arr_size: integer, size of arr(:). !> mini_index: integer, index of minimum value in arr(j:arr_size). !> i, j: integer, loop counters. arr_size = size ( arr ) do j = 1 , arr_size mini_index = j do i = j + 1 , arr_size if ( arr ( i ) < arr ( mini_index )) then mini_index = i end if end do call swap ( arr , j , mini_index ) end do end subroutine selection_sort_int32 subroutine selection_sort_int64 ( arr ) integer ( int64 ), intent ( inout ) :: arr (:) integer :: arr_size , mini_index , i , j !> selection_sort: Sort arr of some type by selection-sort. !> arguments: !> arr: array of some type. !> variables: !> arr_size: integer, size of arr(:). !> mini_index: integer, index of minimum value in arr(j:arr_size). !> i, j: integer, loop counters. arr_size = size ( arr ) do j = 1 , arr_size mini_index = j do i = j + 1 , arr_size if ( arr ( i ) < arr ( mini_index )) then mini_index = i end if end do call swap ( arr , j , mini_index ) end do end subroutine selection_sort_int64 subroutine selection_sort_real32 ( arr ) real ( real32 ), intent ( inout ) :: arr (:) integer :: arr_size , mini_index , i , j !> selection_sort: Sort arr of some type by selection-sort. !> arguments: !> arr: array of some type. !> variables: !> arr_size: integer, size of arr(:). !> mini_index: integer, index of minimum value in arr(j:arr_size). !> i, j: integer, loop counters. arr_size = size ( arr ) do j = 1 , arr_size mini_index = j do i = j + 1 , arr_size if ( arr ( i ) < arr ( mini_index )) then mini_index = i end if end do call swap ( arr , j , mini_index ) end do end subroutine selection_sort_real32 subroutine selection_sort_real64 ( arr ) real ( real64 ), intent ( inout ) :: arr (:) integer :: arr_size , mini_index , i , j !> selection_sort: Sort arr of some type by selection-sort. !> arguments: !> arr: array of some type. !> variables: !> arr_size: integer, size of arr(:). !> mini_index: integer, index of minimum value in arr(j:arr_size). !> i, j: integer, loop counters. arr_size = size ( arr ) do j = 1 , arr_size mini_index = j do i = j + 1 , arr_size if ( arr ( i ) < arr ( mini_index )) then mini_index = i end if end do call swap ( arr , j , mini_index ) end do end subroutine selection_sort_real64 end module selection_sort_m","tags":"","loc":"sourcefile/selection_sort_m.f90.html"},{"title":"compare_m.f90 â€“ Fortran Program","text":"Contents Modules compare_m Source Code compare_m.f90 Source Code module compare_m use , intrinsic :: iso_fortran_env implicit none private public :: less , greater public :: less_int32 , less_int64 , less_real32 , less_real64 public :: greater_int32 , greater_int64 , greater_real32 , greater_real64 public :: compare_int32 , compare_int64 , compare_real32 , compare_real64 interface less module procedure :: less_int32 , less_int64 , less_real32 , less_real64 end interface interface greater module procedure :: greater_int32 , greater_int64 , greater_real32 , greater_real64 end interface interface logical function compare_int32 ( x , y ) import int32 integer ( int32 ), intent ( in ) :: x , y end function compare_int32 logical function compare_int64 ( x , y ) import int64 integer ( int64 ), intent ( in ) :: x , y end function compare_int64 logical function compare_real32 ( x , y ) import real32 real ( real32 ), intent ( in ) :: x , y end function compare_real32 logical function compare_real64 ( x , y ) import real64 real ( real64 ), intent ( in ) :: x , y end function compare_real64 end interface contains pure logical function less_int32 ( x , y ) integer ( int32 ), intent ( in ) :: x , y less_int32 = x < y return end function less_int32 pure logical function less_int64 ( x , y ) integer ( int64 ), intent ( in ) :: x , y less_int64 = x < y return end function less_int64 pure logical function less_real32 ( x , y ) real ( real32 ), intent ( in ) :: x , y less_real32 = x < y return end function less_real32 pure logical function less_real64 ( x , y ) real ( real64 ), intent ( in ) :: x , y less_real64 = x < y return end function less_real64 pure logical function greater_int32 ( x , y ) integer ( int32 ), intent ( in ) :: x , y greater_int32 = x > y return end function greater_int32 pure logical function greater_int64 ( x , y ) integer ( int64 ), intent ( in ) :: x , y greater_int64 = x > y return end function greater_int64 pure logical function greater_real32 ( x , y ) real ( real32 ), intent ( in ) :: x , y greater_real32 = x > y return end function greater_real32 pure logical function greater_real64 ( x , y ) real ( real64 ), intent ( in ) :: x , y greater_real64 = x > y return end function greater_real64 end module compare_m","tags":"","loc":"sourcefile/compare_m.f90.html"},{"title":"merge_sort â€“ Fortran Program","text":"public interface merge_sort Contents Module Procedures merge_sort_int32 merge_sort_int64 merge_sort_real32 merge_sort_real64 Module Procedures private subroutine merge_sort_int32(arr) Arguments Type Intent Optional Attributes Name integer(kind=int32), intent(inout) :: arr (:) private subroutine merge_sort_int64(arr) Arguments Type Intent Optional Attributes Name integer(kind=int64), intent(inout) :: arr (:) private subroutine merge_sort_real32(arr) Arguments Type Intent Optional Attributes Name real(kind=real32), intent(inout) :: arr (:) private subroutine merge_sort_real64(arr) Arguments Type Intent Optional Attributes Name real(kind=real64), intent(inout) :: arr (:)","tags":"","loc":"interface/merge_sort.html"},{"title":"say_hello â€“ Fortran Program","text":"public subroutine say_hello() Arguments None Contents None","tags":"","loc":"proc/say_hello.html"},{"title":"insertion_sort â€“ Fortran Program","text":"public interface insertion_sort Contents Module Procedures insertion_sort_int32 insertion_sort_int64 insertion_sort_real32 insertion_sort_real64 Module Procedures private subroutine insertion_sort_int32(arr) Arguments Type Intent Optional Attributes Name integer(kind=int32), intent(inout) :: arr (:) private subroutine insertion_sort_int64(arr) Arguments Type Intent Optional Attributes Name integer(kind=int64), intent(inout) :: arr (:) private subroutine insertion_sort_real32(arr) Arguments Type Intent Optional Attributes Name real(kind=real32), intent(inout) :: arr (:) private subroutine insertion_sort_real64(arr) Arguments Type Intent Optional Attributes Name real(kind=real64), intent(inout) :: arr (:)","tags":"","loc":"interface/insertion_sort.html"},{"title":"swap_int32 â€“ Fortran Program","text":"public subroutine swap_int32(arr, i, j) i, j: integer indices.\nvariables:\ntmp: typeof(arr). Arguments Type Intent Optional Attributes Name integer(kind=int32), intent(inout) :: arr (:) integer(kind=int32), intent(in) :: i integer(kind=int32), intent(in) :: j Called by proc~~swap_int32~~CalledByGraph proc~swap_int32 swap_int32 interface~swap swap interface~swap->proc~swap_int32 Help Ã— Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Contents None","tags":"","loc":"proc/swap_int32.html"},{"title":"swap_int64 â€“ Fortran Program","text":"public subroutine swap_int64(arr, i, j) i, j: integer indices.\nvariables:\ntmp: typeof(arr). Arguments Type Intent Optional Attributes Name integer(kind=int64), intent(inout) :: arr (:) integer(kind=int32), intent(in) :: i integer(kind=int32), intent(in) :: j Called by proc~~swap_int64~~CalledByGraph proc~swap_int64 swap_int64 interface~swap swap interface~swap->proc~swap_int64 Help Ã— Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Contents None","tags":"","loc":"proc/swap_int64.html"},{"title":"swap_real32 â€“ Fortran Program","text":"public subroutine swap_real32(arr, i, j) i, j: integer indices.\nvariables:\ntmp: typeof(arr). Arguments Type Intent Optional Attributes Name real(kind=real32), intent(inout) :: arr (:) integer(kind=int32), intent(in) :: i integer(kind=int32), intent(in) :: j Called by proc~~swap_real32~~CalledByGraph proc~swap_real32 swap_real32 interface~swap swap interface~swap->proc~swap_real32 Help Ã— Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Contents None","tags":"","loc":"proc/swap_real32.html"},{"title":"swap_real64 â€“ Fortran Program","text":"public subroutine swap_real64(arr, i, j) i, j: integer indices.\nvariables:\ntmp: typeof(arr). Arguments Type Intent Optional Attributes Name real(kind=real64), intent(inout) :: arr (:) integer(kind=int32), intent(in) :: i integer(kind=int32), intent(in) :: j Called by proc~~swap_real64~~CalledByGraph proc~swap_real64 swap_real64 interface~swap swap interface~swap->proc~swap_real64 Help Ã— Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Contents None","tags":"","loc":"proc/swap_real64.html"},{"title":"swap â€“ Fortran Program","text":"public interface swap Calls interface~~swap~~CallsGraph interface~swap swap proc~swap_real64 swap_real64 interface~swap->proc~swap_real64 proc~swap_real32 swap_real32 interface~swap->proc~swap_real32 proc~swap_int32 swap_int32 interface~swap->proc~swap_int32 proc~swap_int64 swap_int64 interface~swap->proc~swap_int64 Help Ã— Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Contents Module Procedures swap_int32 swap_int64 swap_real32 swap_real64 Module Procedures public subroutine swap_int32 (arr, i, j) i, j: integer indices.\nvariables:\ntmp: typeof(arr). Arguments Type Intent Optional Attributes Name integer(kind=int32), intent(inout) :: arr (:) integer(kind=int32), intent(in) :: i integer(kind=int32), intent(in) :: j public subroutine swap_int64 (arr, i, j) i, j: integer indices.\nvariables:\ntmp: typeof(arr). Arguments Type Intent Optional Attributes Name integer(kind=int64), intent(inout) :: arr (:) integer(kind=int32), intent(in) :: i integer(kind=int32), intent(in) :: j public subroutine swap_real32 (arr, i, j) i, j: integer indices.\nvariables:\ntmp: typeof(arr). Arguments Type Intent Optional Attributes Name real(kind=real32), intent(inout) :: arr (:) integer(kind=int32), intent(in) :: i integer(kind=int32), intent(in) :: j public subroutine swap_real64 (arr, i, j) i, j: integer indices.\nvariables:\ntmp: typeof(arr). Arguments Type Intent Optional Attributes Name real(kind=real64), intent(inout) :: arr (:) integer(kind=int32), intent(in) :: i integer(kind=int32), intent(in) :: j","tags":"","loc":"interface/swap.html"},{"title":"selection_sort â€“ Fortran Program","text":"public interface selection_sort Contents Module Procedures selection_sort_int32 selection_sort_int64 selection_sort_real32 selection_sort_real64 Module Procedures private subroutine selection_sort_int32(arr) i, j: integer, loop counters. Arguments Type Intent Optional Attributes Name integer(kind=int32), intent(inout) :: arr (:) private subroutine selection_sort_int64(arr) i, j: integer, loop counters. Arguments Type Intent Optional Attributes Name integer(kind=int64), intent(inout) :: arr (:) private subroutine selection_sort_real32(arr) i, j: integer, loop counters. Arguments Type Intent Optional Attributes Name real(kind=real32), intent(inout) :: arr (:) private subroutine selection_sort_real64(arr) i, j: integer, loop counters. Arguments Type Intent Optional Attributes Name real(kind=real64), intent(inout) :: arr (:)","tags":"","loc":"interface/selection_sort.html"},{"title":"less_int32 â€“ Fortran Program","text":"public pure function less_int32(x, y) Arguments Type Intent Optional Attributes Name integer(kind=int32), intent(in) :: x integer(kind=int32), intent(in) :: y Return Value logical Called by proc~~less_int32~~CalledByGraph proc~less_int32 less_int32 interface~less less interface~less->proc~less_int32 Help Ã— Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Contents None","tags":"","loc":"proc/less_int32.html"},{"title":"less_int64 â€“ Fortran Program","text":"public pure function less_int64(x, y) Arguments Type Intent Optional Attributes Name integer(kind=int64), intent(in) :: x integer(kind=int64), intent(in) :: y Return Value logical Called by proc~~less_int64~~CalledByGraph proc~less_int64 less_int64 interface~less less interface~less->proc~less_int64 Help Ã— Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Contents None","tags":"","loc":"proc/less_int64.html"},{"title":"less_real32 â€“ Fortran Program","text":"public pure function less_real32(x, y) Arguments Type Intent Optional Attributes Name real(kind=real32), intent(in) :: x real(kind=real32), intent(in) :: y Return Value logical Called by proc~~less_real32~~CalledByGraph proc~less_real32 less_real32 interface~less less interface~less->proc~less_real32 Help Ã— Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Contents None","tags":"","loc":"proc/less_real32.html"},{"title":"less_real64 â€“ Fortran Program","text":"public pure function less_real64(x, y) Arguments Type Intent Optional Attributes Name real(kind=real64), intent(in) :: x real(kind=real64), intent(in) :: y Return Value logical Called by proc~~less_real64~~CalledByGraph proc~less_real64 less_real64 interface~less less interface~less->proc~less_real64 Help Ã— Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Contents None","tags":"","loc":"proc/less_real64.html"},{"title":"greater_int32 â€“ Fortran Program","text":"public pure function greater_int32(x, y) Arguments Type Intent Optional Attributes Name integer(kind=int32), intent(in) :: x integer(kind=int32), intent(in) :: y Return Value logical Called by proc~~greater_int32~~CalledByGraph proc~greater_int32 greater_int32 interface~greater greater interface~greater->proc~greater_int32 Help Ã— Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Contents None","tags":"","loc":"proc/greater_int32.html"},{"title":"greater_int64 â€“ Fortran Program","text":"public pure function greater_int64(x, y) Arguments Type Intent Optional Attributes Name integer(kind=int64), intent(in) :: x integer(kind=int64), intent(in) :: y Return Value logical Called by proc~~greater_int64~~CalledByGraph proc~greater_int64 greater_int64 interface~greater greater interface~greater->proc~greater_int64 Help Ã— Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Contents None","tags":"","loc":"proc/greater_int64.html"},{"title":"greater_real32 â€“ Fortran Program","text":"public pure function greater_real32(x, y) Arguments Type Intent Optional Attributes Name real(kind=real32), intent(in) :: x real(kind=real32), intent(in) :: y Return Value logical Called by proc~~greater_real32~~CalledByGraph proc~greater_real32 greater_real32 interface~greater greater interface~greater->proc~greater_real32 Help Ã— Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Contents None","tags":"","loc":"proc/greater_real32.html"},{"title":"greater_real64 â€“ Fortran Program","text":"public pure function greater_real64(x, y) Arguments Type Intent Optional Attributes Name real(kind=real64), intent(in) :: x real(kind=real64), intent(in) :: y Return Value logical Called by proc~~greater_real64~~CalledByGraph proc~greater_real64 greater_real64 interface~greater greater interface~greater->proc~greater_real64 Help Ã— Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Contents None","tags":"","loc":"proc/greater_real64.html"},{"title":"less â€“ Fortran Program","text":"public interface less Calls interface~~less~~CallsGraph interface~less less proc~less_real32 less_real32 interface~less->proc~less_real32 proc~less_int64 less_int64 interface~less->proc~less_int64 proc~less_int32 less_int32 interface~less->proc~less_int32 proc~less_real64 less_real64 interface~less->proc~less_real64 Help Ã— Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Contents Module Procedures less_int32 less_int64 less_real32 less_real64 Module Procedures public pure function less_int32 (x, y) Arguments Type Intent Optional Attributes Name integer(kind=int32), intent(in) :: x integer(kind=int32), intent(in) :: y Return Value logical public pure function less_int64 (x, y) Arguments Type Intent Optional Attributes Name integer(kind=int64), intent(in) :: x integer(kind=int64), intent(in) :: y Return Value logical public pure function less_real32 (x, y) Arguments Type Intent Optional Attributes Name real(kind=real32), intent(in) :: x real(kind=real32), intent(in) :: y Return Value logical public pure function less_real64 (x, y) Arguments Type Intent Optional Attributes Name real(kind=real64), intent(in) :: x real(kind=real64), intent(in) :: y Return Value logical","tags":"","loc":"interface/less.html"},{"title":"greater â€“ Fortran Program","text":"public interface greater Calls interface~~greater~~CallsGraph interface~greater greater proc~greater_int64 greater_int64 interface~greater->proc~greater_int64 proc~greater_int32 greater_int32 interface~greater->proc~greater_int32 proc~greater_real64 greater_real64 interface~greater->proc~greater_real64 proc~greater_real32 greater_real32 interface~greater->proc~greater_real32 Help Ã— Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Contents Module Procedures greater_int32 greater_int64 greater_real32 greater_real64 Module Procedures public pure function greater_int32 (x, y) Arguments Type Intent Optional Attributes Name integer(kind=int32), intent(in) :: x integer(kind=int32), intent(in) :: y Return Value logical public pure function greater_int64 (x, y) Arguments Type Intent Optional Attributes Name integer(kind=int64), intent(in) :: x integer(kind=int64), intent(in) :: y Return Value logical public pure function greater_real32 (x, y) Arguments Type Intent Optional Attributes Name real(kind=real32), intent(in) :: x real(kind=real32), intent(in) :: y Return Value logical public pure function greater_real64 (x, y) Arguments Type Intent Optional Attributes Name real(kind=real64), intent(in) :: x real(kind=real64), intent(in) :: y Return Value logical","tags":"","loc":"interface/greater.html"},{"title":"compare_int32 â€“ Fortran Program","text":"interface public function compare_int32(x, y) Arguments Type Intent Optional Attributes Name integer(kind=int32), intent(in) :: x integer(kind=int32), intent(in) :: y Return Value logical","tags":"","loc":"interface/compare_int32.html"},{"title":"compare_int64 â€“ Fortran Program","text":"interface public function compare_int64(x, y) Arguments Type Intent Optional Attributes Name integer(kind=int64), intent(in) :: x integer(kind=int64), intent(in) :: y Return Value logical","tags":"","loc":"interface/compare_int64.html"},{"title":"compare_real32 â€“ Fortran Program","text":"interface public function compare_real32(x, y) Arguments Type Intent Optional Attributes Name real(kind=real32), intent(in) :: x real(kind=real32), intent(in) :: y Return Value logical","tags":"","loc":"interface/compare_real32.html"},{"title":"compare_real64 â€“ Fortran Program","text":"interface public function compare_real64(x, y) Arguments Type Intent Optional Attributes Name real(kind=real64), intent(in) :: x real(kind=real64), intent(in) :: y Return Value logical","tags":"","loc":"interface/compare_real64.html"},{"title":"merge_sort_m â€“ Fortran Program","text":"Uses iso_fortran_env module~~merge_sort_m~~UsesGraph module~merge_sort_m merge_sort_m iso_fortran_env iso_fortran_env module~merge_sort_m->iso_fortran_env Help Ã— Graph Key Nodes of different colours represent the following: Graph Key Module Module Submodule Submodule Subroutine Subroutine Function Function Program Program This Page's Entity This Page's Entity Solid arrows point from a submodule to the (sub)module which it is\n    descended from. Dashed arrows point from a module or program unit to \n    modules which it uses. Contents Interfaces merge_sort Interfaces public interface merge_sort private subroutine merge_sort_int32(arr) Arguments Type Intent Optional Attributes Name integer(kind=int32), intent(inout) :: arr (:) private subroutine merge_sort_int64(arr) Arguments Type Intent Optional Attributes Name integer(kind=int64), intent(inout) :: arr (:) private subroutine merge_sort_real32(arr) Arguments Type Intent Optional Attributes Name real(kind=real32), intent(inout) :: arr (:) private subroutine merge_sort_real64(arr) Arguments Type Intent Optional Attributes Name real(kind=real64), intent(inout) :: arr (:)","tags":"","loc":"module/merge_sort_m.html"},{"title":"algorithms â€“ Fortran Program","text":"Contents Subroutines say_hello Subroutines public subroutine say_hello () Arguments None","tags":"","loc":"module/algorithms.html"},{"title":"insertion_sort_m â€“ Fortran Program","text":"Uses iso_fortran_env module~~insertion_sort_m~~UsesGraph module~insertion_sort_m insertion_sort_m iso_fortran_env iso_fortran_env module~insertion_sort_m->iso_fortran_env Help Ã— Graph Key Nodes of different colours represent the following: Graph Key Module Module Submodule Submodule Subroutine Subroutine Function Function Program Program This Page's Entity This Page's Entity Solid arrows point from a submodule to the (sub)module which it is\n    descended from. Dashed arrows point from a module or program unit to \n    modules which it uses. Contents Interfaces insertion_sort Interfaces public interface insertion_sort private subroutine insertion_sort_int32(arr) Arguments Type Intent Optional Attributes Name integer(kind=int32), intent(inout) :: arr (:) private subroutine insertion_sort_int64(arr) Arguments Type Intent Optional Attributes Name integer(kind=int64), intent(inout) :: arr (:) private subroutine insertion_sort_real32(arr) Arguments Type Intent Optional Attributes Name real(kind=real32), intent(inout) :: arr (:) private subroutine insertion_sort_real64(arr) Arguments Type Intent Optional Attributes Name real(kind=real64), intent(inout) :: arr (:)","tags":"","loc":"module/insertion_sort_m.html"},{"title":"swap_m â€“ Fortran Program","text":"Uses iso_fortran_env module~~swap_m~~UsesGraph module~swap_m swap_m iso_fortran_env iso_fortran_env module~swap_m->iso_fortran_env Help Ã— Graph Key Nodes of different colours represent the following: Graph Key Module Module Submodule Submodule Subroutine Subroutine Function Function Program Program This Page's Entity This Page's Entity Solid arrows point from a submodule to the (sub)module which it is\n    descended from. Dashed arrows point from a module or program unit to \n    modules which it uses. Used by module~~swap_m~~UsedByGraph module~swap_m swap_m module~selection_sort_m selection_sort_m module~selection_sort_m->module~swap_m Help Ã— Graph Key Nodes of different colours represent the following: Graph Key Module Module Submodule Submodule Subroutine Subroutine Function Function Program Program This Page's Entity This Page's Entity Solid arrows point from a submodule to the (sub)module which it is\n    descended from. Dashed arrows point from a module or program unit to \n    modules which it uses. Contents Interfaces swap Subroutines swap_int32 swap_int64 swap_real32 swap_real64 Interfaces public interface swap public subroutine swap_int32 (arr, i, j) i, j: integer indices.\nvariables:\ntmp: typeof(arr). Arguments Type Intent Optional Attributes Name integer(kind=int32), intent(inout) :: arr (:) integer(kind=int32), intent(in) :: i integer(kind=int32), intent(in) :: j public subroutine swap_int64 (arr, i, j) i, j: integer indices.\nvariables:\ntmp: typeof(arr). Arguments Type Intent Optional Attributes Name integer(kind=int64), intent(inout) :: arr (:) integer(kind=int32), intent(in) :: i integer(kind=int32), intent(in) :: j public subroutine swap_real32 (arr, i, j) i, j: integer indices.\nvariables:\ntmp: typeof(arr). Arguments Type Intent Optional Attributes Name real(kind=real32), intent(inout) :: arr (:) integer(kind=int32), intent(in) :: i integer(kind=int32), intent(in) :: j public subroutine swap_real64 (arr, i, j) i, j: integer indices.\nvariables:\ntmp: typeof(arr). Arguments Type Intent Optional Attributes Name real(kind=real64), intent(inout) :: arr (:) integer(kind=int32), intent(in) :: i integer(kind=int32), intent(in) :: j Subroutines public subroutine swap_int32 (arr, i, j) i, j: integer indices.\nvariables:\ntmp: typeof(arr). Arguments Type Intent Optional Attributes Name integer(kind=int32), intent(inout) :: arr (:) integer(kind=int32), intent(in) :: i integer(kind=int32), intent(in) :: j public subroutine swap_int64 (arr, i, j) i, j: integer indices.\nvariables:\ntmp: typeof(arr). Arguments Type Intent Optional Attributes Name integer(kind=int64), intent(inout) :: arr (:) integer(kind=int32), intent(in) :: i integer(kind=int32), intent(in) :: j public subroutine swap_real32 (arr, i, j) i, j: integer indices.\nvariables:\ntmp: typeof(arr). Arguments Type Intent Optional Attributes Name real(kind=real32), intent(inout) :: arr (:) integer(kind=int32), intent(in) :: i integer(kind=int32), intent(in) :: j public subroutine swap_real64 (arr, i, j) i, j: integer indices.\nvariables:\ntmp: typeof(arr). Arguments Type Intent Optional Attributes Name real(kind=real64), intent(inout) :: arr (:) integer(kind=int32), intent(in) :: i integer(kind=int32), intent(in) :: j","tags":"","loc":"module/swap_m.html"},{"title":"selection_sort_m â€“ Fortran Program","text":"Uses iso_fortran_env swap_m module~~selection_sort_m~~UsesGraph module~selection_sort_m selection_sort_m module~swap_m swap_m module~selection_sort_m->module~swap_m iso_fortran_env iso_fortran_env module~selection_sort_m->iso_fortran_env module~swap_m->iso_fortran_env Help Ã— Graph Key Nodes of different colours represent the following: Graph Key Module Module Submodule Submodule Subroutine Subroutine Function Function Program Program This Page's Entity This Page's Entity Solid arrows point from a submodule to the (sub)module which it is\n    descended from. Dashed arrows point from a module or program unit to \n    modules which it uses. Contents Interfaces selection_sort Interfaces public interface selection_sort private subroutine selection_sort_int32(arr) i, j: integer, loop counters. Arguments Type Intent Optional Attributes Name integer(kind=int32), intent(inout) :: arr (:) private subroutine selection_sort_int64(arr) i, j: integer, loop counters. Arguments Type Intent Optional Attributes Name integer(kind=int64), intent(inout) :: arr (:) private subroutine selection_sort_real32(arr) i, j: integer, loop counters. Arguments Type Intent Optional Attributes Name real(kind=real32), intent(inout) :: arr (:) private subroutine selection_sort_real64(arr) i, j: integer, loop counters. Arguments Type Intent Optional Attributes Name real(kind=real64), intent(inout) :: arr (:)","tags":"","loc":"module/selection_sort_m.html"},{"title":"compare_m â€“ Fortran Program","text":"Uses iso_fortran_env module~~compare_m~~UsesGraph module~compare_m compare_m iso_fortran_env iso_fortran_env module~compare_m->iso_fortran_env Help Ã— Graph Key Nodes of different colours represent the following: Graph Key Module Module Submodule Submodule Subroutine Subroutine Function Function Program Program This Page's Entity This Page's Entity Solid arrows point from a submodule to the (sub)module which it is\n    descended from. Dashed arrows point from a module or program unit to \n    modules which it uses. Contents Interfaces less greater compare_int32 compare_int64 compare_real32 compare_real64 Functions less_int32 less_int64 less_real32 less_real64 greater_int32 greater_int64 greater_real32 greater_real64 Interfaces public interface less public pure function less_int32 (x, y) Arguments Type Intent Optional Attributes Name integer(kind=int32), intent(in) :: x integer(kind=int32), intent(in) :: y Return Value logical public pure function less_int64 (x, y) Arguments Type Intent Optional Attributes Name integer(kind=int64), intent(in) :: x integer(kind=int64), intent(in) :: y Return Value logical public pure function less_real32 (x, y) Arguments Type Intent Optional Attributes Name real(kind=real32), intent(in) :: x real(kind=real32), intent(in) :: y Return Value logical public pure function less_real64 (x, y) Arguments Type Intent Optional Attributes Name real(kind=real64), intent(in) :: x real(kind=real64), intent(in) :: y Return Value logical public interface greater public pure function greater_int32 (x, y) Arguments Type Intent Optional Attributes Name integer(kind=int32), intent(in) :: x integer(kind=int32), intent(in) :: y Return Value logical public pure function greater_int64 (x, y) Arguments Type Intent Optional Attributes Name integer(kind=int64), intent(in) :: x integer(kind=int64), intent(in) :: y Return Value logical public pure function greater_real32 (x, y) Arguments Type Intent Optional Attributes Name real(kind=real32), intent(in) :: x real(kind=real32), intent(in) :: y Return Value logical public pure function greater_real64 (x, y) Arguments Type Intent Optional Attributes Name real(kind=real64), intent(in) :: x real(kind=real64), intent(in) :: y Return Value logical interface public function compare_int32(x, y) Arguments Type Intent Optional Attributes Name integer(kind=int32), intent(in) :: x integer(kind=int32), intent(in) :: y Return Value logical interface public function compare_int64(x, y) Arguments Type Intent Optional Attributes Name integer(kind=int64), intent(in) :: x integer(kind=int64), intent(in) :: y Return Value logical interface public function compare_real32(x, y) Arguments Type Intent Optional Attributes Name real(kind=real32), intent(in) :: x real(kind=real32), intent(in) :: y Return Value logical interface public function compare_real64(x, y) Arguments Type Intent Optional Attributes Name real(kind=real64), intent(in) :: x real(kind=real64), intent(in) :: y Return Value logical Functions public pure function less_int32 (x, y) Arguments Type Intent Optional Attributes Name integer(kind=int32), intent(in) :: x integer(kind=int32), intent(in) :: y Return Value logical public pure function less_int64 (x, y) Arguments Type Intent Optional Attributes Name integer(kind=int64), intent(in) :: x integer(kind=int64), intent(in) :: y Return Value logical public pure function less_real32 (x, y) Arguments Type Intent Optional Attributes Name real(kind=real32), intent(in) :: x real(kind=real32), intent(in) :: y Return Value logical public pure function less_real64 (x, y) Arguments Type Intent Optional Attributes Name real(kind=real64), intent(in) :: x real(kind=real64), intent(in) :: y Return Value logical public pure function greater_int32 (x, y) Arguments Type Intent Optional Attributes Name integer(kind=int32), intent(in) :: x integer(kind=int32), intent(in) :: y Return Value logical public pure function greater_int64 (x, y) Arguments Type Intent Optional Attributes Name integer(kind=int64), intent(in) :: x integer(kind=int64), intent(in) :: y Return Value logical public pure function greater_real32 (x, y) Arguments Type Intent Optional Attributes Name real(kind=real32), intent(in) :: x real(kind=real32), intent(in) :: y Return Value logical public pure function greater_real64 (x, y) Arguments Type Intent Optional Attributes Name real(kind=real64), intent(in) :: x real(kind=real64), intent(in) :: y Return Value logical","tags":"","loc":"module/compare_m.html"}]}